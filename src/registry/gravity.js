import * as $protobuf from "protobufjs";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const cosmos = $root.cosmos = (() => {

  /**
   * Namespace cosmos.
   * @exports cosmos
   * @namespace
   */
  const cosmos = {};

  cosmos.base = (function() {

    /**
     * Namespace base.
     * @memberof cosmos
     * @namespace
     */
    const base = {};

    base.v1beta1 = (function() {

      /**
       * Namespace v1beta1.
       * @memberof cosmos.base
       * @namespace
       */
      const v1beta1 = {};

      v1beta1.Coin = (function() {

        /**
         * Properties of a Coin.
         * @memberof cosmos.base.v1beta1
         * @interface ICoin
         * @property {string|null} [denom] Coin denom
         * @property {string|null} [amount] Coin amount
         */

        /**
         * Constructs a new Coin.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a Coin.
         * @implements ICoin
         * @constructor
         * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set
         */
        function Coin(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coin denom.
         * @member {string} denom
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         */
        Coin.prototype.denom = "";

        /**
         * Coin amount.
         * @member {string} amount
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         */
        Coin.prototype.amount = "";

        /**
         * Creates a new Coin instance using the specified properties.
         * @function create
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set
         * @returns {cosmos.base.v1beta1.Coin} Coin instance
         */
        Coin.create = function create(properties) {
          return new Coin(properties);
        };

        /**
         * Encodes the specified Coin message. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified Coin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coin message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.Coin();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Coin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coin message.
         * @function verify
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coin.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.denom != null && message.hasOwnProperty("denom"))
            if (!$util.isString(message.denom))
              return "denom: string expected";
          if (message.amount != null && message.hasOwnProperty("amount"))
            if (!$util.isString(message.amount))
              return "amount: string expected";
          return null;
        };

        /**
         * Creates a Coin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.Coin} Coin
         */
        Coin.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.Coin)
            return object;
          let message = new $root.cosmos.base.v1beta1.Coin();
          if (object.denom != null)
            message.denom = String(object.denom);
          if (object.amount != null)
            message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from a Coin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.Coin} message Coin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coin.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.denom = "";
            object.amount = "";
          }
          if (message.denom != null && message.hasOwnProperty("denom"))
            object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty("amount"))
            object.amount = message.amount;
          return object;
        };

        /**
         * Converts this Coin to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coin;
      })();

      v1beta1.DecCoin = (function() {

        /**
         * Properties of a DecCoin.
         * @memberof cosmos.base.v1beta1
         * @interface IDecCoin
         * @property {string|null} [denom] DecCoin denom
         * @property {string|null} [amount] DecCoin amount
         */

        /**
         * Constructs a new DecCoin.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a DecCoin.
         * @implements IDecCoin
         * @constructor
         * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set
         */
        function DecCoin(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecCoin denom.
         * @member {string} denom
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         */
        DecCoin.prototype.denom = "";

        /**
         * DecCoin amount.
         * @member {string} amount
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         */
        DecCoin.prototype.amount = "";

        /**
         * Creates a new DecCoin instance using the specified properties.
         * @function create
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin instance
         */
        DecCoin.create = function create(properties) {
          return new DecCoin(properties);
        };

        /**
         * Encodes the specified DecCoin message. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecCoin.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified DecCoin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecCoin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecCoin message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecCoin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.DecCoin();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DecCoin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecCoin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecCoin message.
         * @function verify
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecCoin.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.denom != null && message.hasOwnProperty("denom"))
            if (!$util.isString(message.denom))
              return "denom: string expected";
          if (message.amount != null && message.hasOwnProperty("amount"))
            if (!$util.isString(message.amount))
              return "amount: string expected";
          return null;
        };

        /**
         * Creates a DecCoin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         */
        DecCoin.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.DecCoin)
            return object;
          let message = new $root.cosmos.base.v1beta1.DecCoin();
          if (object.denom != null)
            message.denom = String(object.denom);
          if (object.amount != null)
            message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from a DecCoin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.DecCoin} message DecCoin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecCoin.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.denom = "";
            object.amount = "";
          }
          if (message.denom != null && message.hasOwnProperty("denom"))
            object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty("amount"))
            object.amount = message.amount;
          return object;
        };

        /**
         * Converts this DecCoin to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecCoin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecCoin;
      })();

      v1beta1.IntProto = (function() {

        /**
         * Properties of an IntProto.
         * @memberof cosmos.base.v1beta1
         * @interface IIntProto
         * @property {string|null} [int] IntProto int
         */

        /**
         * Constructs a new IntProto.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents an IntProto.
         * @implements IIntProto
         * @constructor
         * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set
         */
        function IntProto(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntProto int.
         * @member {string} int
         * @memberof cosmos.base.v1beta1.IntProto
         * @instance
         */
        IntProto.prototype.int = "";

        /**
         * Creates a new IntProto instance using the specified properties.
         * @function create
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set
         * @returns {cosmos.base.v1beta1.IntProto} IntProto instance
         */
        IntProto.create = function create(properties) {
          return new IntProto(properties);
        };

        /**
         * Encodes the specified IntProto message. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.int != null && Object.hasOwnProperty.call(message, "int"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.int);
          return writer;
        };

        /**
         * Encodes the specified IntProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IntProto message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.IntProto();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.int = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an IntProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IntProto message.
         * @function verify
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.int != null && message.hasOwnProperty("int"))
            if (!$util.isString(message.int))
              return "int: string expected";
          return null;
        };

        /**
         * Creates an IntProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         */
        IntProto.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.IntProto)
            return object;
          let message = new $root.cosmos.base.v1beta1.IntProto();
          if (object.int != null)
            message.int = String(object.int);
          return message;
        };

        /**
         * Creates a plain object from an IntProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IntProto} message IntProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults)
            object.int = "";
          if (message.int != null && message.hasOwnProperty("int"))
            object.int = message.int;
          return object;
        };

        /**
         * Converts this IntProto to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.IntProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IntProto;
      })();

      v1beta1.DecProto = (function() {

        /**
         * Properties of a DecProto.
         * @memberof cosmos.base.v1beta1
         * @interface IDecProto
         * @property {string|null} [dec] DecProto dec
         */

        /**
         * Constructs a new DecProto.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a DecProto.
         * @implements IDecProto
         * @constructor
         * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set
         */
        function DecProto(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecProto dec.
         * @member {string} dec
         * @memberof cosmos.base.v1beta1.DecProto
         * @instance
         */
        DecProto.prototype.dec = "";

        /**
         * Creates a new DecProto instance using the specified properties.
         * @function create
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set
         * @returns {cosmos.base.v1beta1.DecProto} DecProto instance
         */
        DecProto.create = function create(properties) {
          return new DecProto(properties);
        };

        /**
         * Encodes the specified DecProto message. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.dec != null && Object.hasOwnProperty.call(message, "dec"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.dec);
          return writer;
        };

        /**
         * Encodes the specified DecProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecProto message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.base.v1beta1.DecProto();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.dec = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DecProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecProto message.
         * @function verify
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.dec != null && message.hasOwnProperty("dec"))
            if (!$util.isString(message.dec))
              return "dec: string expected";
          return null;
        };

        /**
         * Creates a DecProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         */
        DecProto.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.DecProto)
            return object;
          let message = new $root.cosmos.base.v1beta1.DecProto();
          if (object.dec != null)
            message.dec = String(object.dec);
          return message;
        };

        /**
         * Creates a plain object from a DecProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.DecProto} message DecProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults)
            object.dec = "";
          if (message.dec != null && message.hasOwnProperty("dec"))
            object.dec = message.dec;
          return object;
        };

        /**
         * Converts this DecProto to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.DecProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecProto;
      })();

      return v1beta1;
    })();

    return base;
  })();

  cosmos.bank = (function() {

    /**
     * Namespace bank.
     * @memberof cosmos
     * @namespace
     */
    const bank = {};

    bank.v1beta1 = (function() {

      /**
       * Namespace v1beta1.
       * @memberof cosmos.bank
       * @namespace
       */
      const v1beta1 = {};

      v1beta1.Params = (function() {

        /**
         * Properties of a Params.
         * @memberof cosmos.bank.v1beta1
         * @interface IParams
         * @property {Array.<cosmos.bank.v1beta1.ISendEnabled>|null} [sendEnabled] Params sendEnabled
         * @property {boolean|null} [defaultSendEnabled] Params defaultSendEnabled
         */

        /**
         * Constructs a new Params.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents a Params.
         * @implements IParams
         * @constructor
         * @param {cosmos.bank.v1beta1.IParams=} [properties] Properties to set
         */
        function Params(properties) {
          this.sendEnabled = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Params sendEnabled.
         * @member {Array.<cosmos.bank.v1beta1.ISendEnabled>} sendEnabled
         * @memberof cosmos.bank.v1beta1.Params
         * @instance
         */
        Params.prototype.sendEnabled = $util.emptyArray;

        /**
         * Params defaultSendEnabled.
         * @member {boolean} defaultSendEnabled
         * @memberof cosmos.bank.v1beta1.Params
         * @instance
         */
        Params.prototype.defaultSendEnabled = false;

        /**
         * Creates a new Params instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {cosmos.bank.v1beta1.IParams=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.Params} Params instance
         */
        Params.create = function create(properties) {
          return new Params(properties);
        };

        /**
         * Encodes the specified Params message. Does not implicitly {@link cosmos.bank.v1beta1.Params.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {cosmos.bank.v1beta1.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sendEnabled != null && message.sendEnabled.length)
            for (let i = 0; i < message.sendEnabled.length; ++i)
              $root.cosmos.bank.v1beta1.SendEnabled.encode(message.sendEnabled[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.defaultSendEnabled != null && Object.hasOwnProperty.call(message, "defaultSendEnabled"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.defaultSendEnabled);
          return writer;
        };

        /**
         * Encodes the specified Params message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.Params.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {cosmos.bank.v1beta1.IParams} message Params message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Params.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Params message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.Params();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.sendEnabled && message.sendEnabled.length))
                  message.sendEnabled = [];
                message.sendEnabled.push($root.cosmos.bank.v1beta1.SendEnabled.decode(reader, reader.uint32()));
                break;
              case 2:
                message.defaultSendEnabled = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Params message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.Params} Params
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Params.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Params message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Params.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.sendEnabled != null && message.hasOwnProperty("sendEnabled")) {
            if (!Array.isArray(message.sendEnabled))
              return "sendEnabled: array expected";
            for (let i = 0; i < message.sendEnabled.length; ++i) {
              let error = $root.cosmos.bank.v1beta1.SendEnabled.verify(message.sendEnabled[i]);
              if (error)
                return "sendEnabled." + error;
            }
          }
          if (message.defaultSendEnabled != null && message.hasOwnProperty("defaultSendEnabled"))
            if (typeof message.defaultSendEnabled !== "boolean")
              return "defaultSendEnabled: boolean expected";
          return null;
        };

        /**
         * Creates a Params message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.Params} Params
         */
        Params.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.Params)
            return object;
          let message = new $root.cosmos.bank.v1beta1.Params();
          if (object.sendEnabled) {
            if (!Array.isArray(object.sendEnabled))
              throw TypeError(".cosmos.bank.v1beta1.Params.sendEnabled: array expected");
            message.sendEnabled = [];
            for (let i = 0; i < object.sendEnabled.length; ++i) {
              if (typeof object.sendEnabled[i] !== "object")
                throw TypeError(".cosmos.bank.v1beta1.Params.sendEnabled: object expected");
              message.sendEnabled[i] = $root.cosmos.bank.v1beta1.SendEnabled.fromObject(object.sendEnabled[i]);
            }
          }
          if (object.defaultSendEnabled != null)
            message.defaultSendEnabled = Boolean(object.defaultSendEnabled);
          return message;
        };

        /**
         * Creates a plain object from a Params message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.Params
         * @static
         * @param {cosmos.bank.v1beta1.Params} message Params
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Params.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.sendEnabled = [];
          if (options.defaults)
            object.defaultSendEnabled = false;
          if (message.sendEnabled && message.sendEnabled.length) {
            object.sendEnabled = [];
            for (let j = 0; j < message.sendEnabled.length; ++j)
              object.sendEnabled[j] = $root.cosmos.bank.v1beta1.SendEnabled.toObject(message.sendEnabled[j], options);
          }
          if (message.defaultSendEnabled != null && message.hasOwnProperty("defaultSendEnabled"))
            object.defaultSendEnabled = message.defaultSendEnabled;
          return object;
        };

        /**
         * Converts this Params to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.Params
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Params.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Params;
      })();

      v1beta1.SendEnabled = (function() {

        /**
         * Properties of a SendEnabled.
         * @memberof cosmos.bank.v1beta1
         * @interface ISendEnabled
         * @property {string|null} [denom] SendEnabled denom
         * @property {boolean|null} [enabled] SendEnabled enabled
         */

        /**
         * Constructs a new SendEnabled.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents a SendEnabled.
         * @implements ISendEnabled
         * @constructor
         * @param {cosmos.bank.v1beta1.ISendEnabled=} [properties] Properties to set
         */
        function SendEnabled(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendEnabled denom.
         * @member {string} denom
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @instance
         */
        SendEnabled.prototype.denom = "";

        /**
         * SendEnabled enabled.
         * @member {boolean} enabled
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @instance
         */
        SendEnabled.prototype.enabled = false;

        /**
         * Creates a new SendEnabled instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {cosmos.bank.v1beta1.ISendEnabled=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.SendEnabled} SendEnabled instance
         */
        SendEnabled.create = function create(properties) {
          return new SendEnabled(properties);
        };

        /**
         * Encodes the specified SendEnabled message. Does not implicitly {@link cosmos.bank.v1beta1.SendEnabled.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {cosmos.bank.v1beta1.ISendEnabled} message SendEnabled message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendEnabled.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
          if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
          return writer;
        };

        /**
         * Encodes the specified SendEnabled message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.SendEnabled.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {cosmos.bank.v1beta1.ISendEnabled} message SendEnabled message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendEnabled.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendEnabled message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.SendEnabled} SendEnabled
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendEnabled.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.SendEnabled();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.enabled = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SendEnabled message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.SendEnabled} SendEnabled
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendEnabled.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendEnabled message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendEnabled.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.denom != null && message.hasOwnProperty("denom"))
            if (!$util.isString(message.denom))
              return "denom: string expected";
          if (message.enabled != null && message.hasOwnProperty("enabled"))
            if (typeof message.enabled !== "boolean")
              return "enabled: boolean expected";
          return null;
        };

        /**
         * Creates a SendEnabled message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.SendEnabled} SendEnabled
         */
        SendEnabled.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.SendEnabled)
            return object;
          let message = new $root.cosmos.bank.v1beta1.SendEnabled();
          if (object.denom != null)
            message.denom = String(object.denom);
          if (object.enabled != null)
            message.enabled = Boolean(object.enabled);
          return message;
        };

        /**
         * Creates a plain object from a SendEnabled message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @static
         * @param {cosmos.bank.v1beta1.SendEnabled} message SendEnabled
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendEnabled.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.denom = "";
            object.enabled = false;
          }
          if (message.denom != null && message.hasOwnProperty("denom"))
            object.denom = message.denom;
          if (message.enabled != null && message.hasOwnProperty("enabled"))
            object.enabled = message.enabled;
          return object;
        };

        /**
         * Converts this SendEnabled to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.SendEnabled
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendEnabled.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendEnabled;
      })();

      v1beta1.Input = (function() {

        /**
         * Properties of an Input.
         * @memberof cosmos.bank.v1beta1
         * @interface IInput
         * @property {string|null} [address] Input address
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [coins] Input coins
         */

        /**
         * Constructs a new Input.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents an Input.
         * @implements IInput
         * @constructor
         * @param {cosmos.bank.v1beta1.IInput=} [properties] Properties to set
         */
        function Input(properties) {
          this.coins = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Input address.
         * @member {string} address
         * @memberof cosmos.bank.v1beta1.Input
         * @instance
         */
        Input.prototype.address = "";

        /**
         * Input coins.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} coins
         * @memberof cosmos.bank.v1beta1.Input
         * @instance
         */
        Input.prototype.coins = $util.emptyArray;

        /**
         * Creates a new Input instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {cosmos.bank.v1beta1.IInput=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.Input} Input instance
         */
        Input.create = function create(properties) {
          return new Input(properties);
        };

        /**
         * Encodes the specified Input message. Does not implicitly {@link cosmos.bank.v1beta1.Input.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {cosmos.bank.v1beta1.IInput} message Input message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Input.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
          if (message.coins != null && message.coins.length)
            for (let i = 0; i < message.coins.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Input message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.Input.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {cosmos.bank.v1beta1.IInput} message Input message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Input.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Input message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.Input} Input
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Input.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.Input();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.string();
                break;
              case 2:
                if (!(message.coins && message.coins.length))
                  message.coins = [];
                message.coins.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Input message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.Input} Input
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Input.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Input message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Input.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.address != null && message.hasOwnProperty("address"))
            if (!$util.isString(message.address))
              return "address: string expected";
          if (message.coins != null && message.hasOwnProperty("coins")) {
            if (!Array.isArray(message.coins))
              return "coins: array expected";
            for (let i = 0; i < message.coins.length; ++i) {
              let error = $root.cosmos.base.v1beta1.Coin.verify(message.coins[i]);
              if (error)
                return "coins." + error;
            }
          }
          return null;
        };

        /**
         * Creates an Input message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.Input} Input
         */
        Input.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.Input)
            return object;
          let message = new $root.cosmos.bank.v1beta1.Input();
          if (object.address != null)
            message.address = String(object.address);
          if (object.coins) {
            if (!Array.isArray(object.coins))
              throw TypeError(".cosmos.bank.v1beta1.Input.coins: array expected");
            message.coins = [];
            for (let i = 0; i < object.coins.length; ++i) {
              if (typeof object.coins[i] !== "object")
                throw TypeError(".cosmos.bank.v1beta1.Input.coins: object expected");
              message.coins[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.coins[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an Input message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.Input
         * @static
         * @param {cosmos.bank.v1beta1.Input} message Input
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Input.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.coins = [];
          if (options.defaults)
            object.address = "";
          if (message.address != null && message.hasOwnProperty("address"))
            object.address = message.address;
          if (message.coins && message.coins.length) {
            object.coins = [];
            for (let j = 0; j < message.coins.length; ++j)
              object.coins[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.coins[j], options);
          }
          return object;
        };

        /**
         * Converts this Input to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.Input
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Input.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Input;
      })();

      v1beta1.Output = (function() {

        /**
         * Properties of an Output.
         * @memberof cosmos.bank.v1beta1
         * @interface IOutput
         * @property {string|null} [address] Output address
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [coins] Output coins
         */

        /**
         * Constructs a new Output.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents an Output.
         * @implements IOutput
         * @constructor
         * @param {cosmos.bank.v1beta1.IOutput=} [properties] Properties to set
         */
        function Output(properties) {
          this.coins = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Output address.
         * @member {string} address
         * @memberof cosmos.bank.v1beta1.Output
         * @instance
         */
        Output.prototype.address = "";

        /**
         * Output coins.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} coins
         * @memberof cosmos.bank.v1beta1.Output
         * @instance
         */
        Output.prototype.coins = $util.emptyArray;

        /**
         * Creates a new Output instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {cosmos.bank.v1beta1.IOutput=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.Output} Output instance
         */
        Output.create = function create(properties) {
          return new Output(properties);
        };

        /**
         * Encodes the specified Output message. Does not implicitly {@link cosmos.bank.v1beta1.Output.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {cosmos.bank.v1beta1.IOutput} message Output message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Output.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
          if (message.coins != null && message.coins.length)
            for (let i = 0; i < message.coins.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Output message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.Output.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {cosmos.bank.v1beta1.IOutput} message Output message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Output.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Output message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.Output} Output
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Output.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.Output();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.string();
                break;
              case 2:
                if (!(message.coins && message.coins.length))
                  message.coins = [];
                message.coins.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Output message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.Output} Output
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Output.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Output message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Output.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.address != null && message.hasOwnProperty("address"))
            if (!$util.isString(message.address))
              return "address: string expected";
          if (message.coins != null && message.hasOwnProperty("coins")) {
            if (!Array.isArray(message.coins))
              return "coins: array expected";
            for (let i = 0; i < message.coins.length; ++i) {
              let error = $root.cosmos.base.v1beta1.Coin.verify(message.coins[i]);
              if (error)
                return "coins." + error;
            }
          }
          return null;
        };

        /**
         * Creates an Output message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.Output} Output
         */
        Output.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.Output)
            return object;
          let message = new $root.cosmos.bank.v1beta1.Output();
          if (object.address != null)
            message.address = String(object.address);
          if (object.coins) {
            if (!Array.isArray(object.coins))
              throw TypeError(".cosmos.bank.v1beta1.Output.coins: array expected");
            message.coins = [];
            for (let i = 0; i < object.coins.length; ++i) {
              if (typeof object.coins[i] !== "object")
                throw TypeError(".cosmos.bank.v1beta1.Output.coins: object expected");
              message.coins[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.coins[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from an Output message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.Output
         * @static
         * @param {cosmos.bank.v1beta1.Output} message Output
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Output.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.coins = [];
          if (options.defaults)
            object.address = "";
          if (message.address != null && message.hasOwnProperty("address"))
            object.address = message.address;
          if (message.coins && message.coins.length) {
            object.coins = [];
            for (let j = 0; j < message.coins.length; ++j)
              object.coins[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.coins[j], options);
          }
          return object;
        };

        /**
         * Converts this Output to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.Output
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Output.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Output;
      })();

      v1beta1.Supply = (function() {

        /**
         * Properties of a Supply.
         * @memberof cosmos.bank.v1beta1
         * @interface ISupply
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [total] Supply total
         */

        /**
         * Constructs a new Supply.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents a Supply.
         * @implements ISupply
         * @constructor
         * @param {cosmos.bank.v1beta1.ISupply=} [properties] Properties to set
         */
        function Supply(properties) {
          this.total = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Supply total.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} total
         * @memberof cosmos.bank.v1beta1.Supply
         * @instance
         */
        Supply.prototype.total = $util.emptyArray;

        /**
         * Creates a new Supply instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {cosmos.bank.v1beta1.ISupply=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.Supply} Supply instance
         */
        Supply.create = function create(properties) {
          return new Supply(properties);
        };

        /**
         * Encodes the specified Supply message. Does not implicitly {@link cosmos.bank.v1beta1.Supply.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {cosmos.bank.v1beta1.ISupply} message Supply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Supply.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.total != null && message.total.length)
            for (let i = 0; i < message.total.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.total[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified Supply message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.Supply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {cosmos.bank.v1beta1.ISupply} message Supply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Supply.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Supply message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.Supply} Supply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Supply.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.Supply();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.total && message.total.length))
                  message.total = [];
                message.total.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Supply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.Supply} Supply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Supply.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Supply message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Supply.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.total != null && message.hasOwnProperty("total")) {
            if (!Array.isArray(message.total))
              return "total: array expected";
            for (let i = 0; i < message.total.length; ++i) {
              let error = $root.cosmos.base.v1beta1.Coin.verify(message.total[i]);
              if (error)
                return "total." + error;
            }
          }
          return null;
        };

        /**
         * Creates a Supply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.Supply} Supply
         */
        Supply.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.Supply)
            return object;
          let message = new $root.cosmos.bank.v1beta1.Supply();
          if (object.total) {
            if (!Array.isArray(object.total))
              throw TypeError(".cosmos.bank.v1beta1.Supply.total: array expected");
            message.total = [];
            for (let i = 0; i < object.total.length; ++i) {
              if (typeof object.total[i] !== "object")
                throw TypeError(".cosmos.bank.v1beta1.Supply.total: object expected");
              message.total[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.total[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a Supply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.Supply
         * @static
         * @param {cosmos.bank.v1beta1.Supply} message Supply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Supply.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.total = [];
          if (message.total && message.total.length) {
            object.total = [];
            for (let j = 0; j < message.total.length; ++j)
              object.total[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.total[j], options);
          }
          return object;
        };

        /**
         * Converts this Supply to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.Supply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Supply.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Supply;
      })();

      v1beta1.DenomUnit = (function() {

        /**
         * Properties of a DenomUnit.
         * @memberof cosmos.bank.v1beta1
         * @interface IDenomUnit
         * @property {string|null} [denom] DenomUnit denom
         * @property {number|null} [exponent] DenomUnit exponent
         * @property {Array.<string>|null} [aliases] DenomUnit aliases
         */

        /**
         * Constructs a new DenomUnit.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents a DenomUnit.
         * @implements IDenomUnit
         * @constructor
         * @param {cosmos.bank.v1beta1.IDenomUnit=} [properties] Properties to set
         */
        function DenomUnit(properties) {
          this.aliases = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * DenomUnit denom.
         * @member {string} denom
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @instance
         */
        DenomUnit.prototype.denom = "";

        /**
         * DenomUnit exponent.
         * @member {number} exponent
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @instance
         */
        DenomUnit.prototype.exponent = 0;

        /**
         * DenomUnit aliases.
         * @member {Array.<string>} aliases
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @instance
         */
        DenomUnit.prototype.aliases = $util.emptyArray;

        /**
         * Creates a new DenomUnit instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {cosmos.bank.v1beta1.IDenomUnit=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.DenomUnit} DenomUnit instance
         */
        DenomUnit.create = function create(properties) {
          return new DenomUnit(properties);
        };

        /**
         * Encodes the specified DenomUnit message. Does not implicitly {@link cosmos.bank.v1beta1.DenomUnit.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {cosmos.bank.v1beta1.IDenomUnit} message DenomUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DenomUnit.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
          if (message.exponent != null && Object.hasOwnProperty.call(message, "exponent"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.exponent);
          if (message.aliases != null && message.aliases.length)
            for (let i = 0; i < message.aliases.length; ++i)
              writer.uint32(/* id 3, wireType 2 =*/26).string(message.aliases[i]);
          return writer;
        };

        /**
         * Encodes the specified DenomUnit message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.DenomUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {cosmos.bank.v1beta1.IDenomUnit} message DenomUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DenomUnit.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DenomUnit message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.DenomUnit} DenomUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DenomUnit.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.DenomUnit();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.exponent = reader.uint32();
                break;
              case 3:
                if (!(message.aliases && message.aliases.length))
                  message.aliases = [];
                message.aliases.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DenomUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.DenomUnit} DenomUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DenomUnit.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DenomUnit message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DenomUnit.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.denom != null && message.hasOwnProperty("denom"))
            if (!$util.isString(message.denom))
              return "denom: string expected";
          if (message.exponent != null && message.hasOwnProperty("exponent"))
            if (!$util.isInteger(message.exponent))
              return "exponent: integer expected";
          if (message.aliases != null && message.hasOwnProperty("aliases")) {
            if (!Array.isArray(message.aliases))
              return "aliases: array expected";
            for (let i = 0; i < message.aliases.length; ++i)
              if (!$util.isString(message.aliases[i]))
                return "aliases: string[] expected";
          }
          return null;
        };

        /**
         * Creates a DenomUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.DenomUnit} DenomUnit
         */
        DenomUnit.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.DenomUnit)
            return object;
          let message = new $root.cosmos.bank.v1beta1.DenomUnit();
          if (object.denom != null)
            message.denom = String(object.denom);
          if (object.exponent != null)
            message.exponent = object.exponent >>> 0;
          if (object.aliases) {
            if (!Array.isArray(object.aliases))
              throw TypeError(".cosmos.bank.v1beta1.DenomUnit.aliases: array expected");
            message.aliases = [];
            for (let i = 0; i < object.aliases.length; ++i)
              message.aliases[i] = String(object.aliases[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a DenomUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @static
         * @param {cosmos.bank.v1beta1.DenomUnit} message DenomUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DenomUnit.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.aliases = [];
          if (options.defaults) {
            object.denom = "";
            object.exponent = 0;
          }
          if (message.denom != null && message.hasOwnProperty("denom"))
            object.denom = message.denom;
          if (message.exponent != null && message.hasOwnProperty("exponent"))
            object.exponent = message.exponent;
          if (message.aliases && message.aliases.length) {
            object.aliases = [];
            for (let j = 0; j < message.aliases.length; ++j)
              object.aliases[j] = message.aliases[j];
          }
          return object;
        };

        /**
         * Converts this DenomUnit to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.DenomUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DenomUnit.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DenomUnit;
      })();

      v1beta1.Metadata = (function() {

        /**
         * Properties of a Metadata.
         * @memberof cosmos.bank.v1beta1
         * @interface IMetadata
         * @property {string|null} [description] Metadata description
         * @property {Array.<cosmos.bank.v1beta1.IDenomUnit>|null} [denomUnits] Metadata denomUnits
         * @property {string|null} [base] Metadata base
         * @property {string|null} [display] Metadata display
         * @property {string|null} [name] Metadata name
         * @property {string|null} [symbol] Metadata symbol
         * @property {string|null} [uri] Metadata uri
         * @property {string|null} [uriHash] Metadata uriHash
         */

        /**
         * Constructs a new Metadata.
         * @memberof cosmos.bank.v1beta1
         * @classdesc Represents a Metadata.
         * @implements IMetadata
         * @constructor
         * @param {cosmos.bank.v1beta1.IMetadata=} [properties] Properties to set
         */
        function Metadata(properties) {
          this.denomUnits = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Metadata description.
         * @member {string} description
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.description = "";

        /**
         * Metadata denomUnits.
         * @member {Array.<cosmos.bank.v1beta1.IDenomUnit>} denomUnits
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.denomUnits = $util.emptyArray;

        /**
         * Metadata base.
         * @member {string} base
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.base = "";

        /**
         * Metadata display.
         * @member {string} display
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.display = "";

        /**
         * Metadata name.
         * @member {string} name
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.name = "";

        /**
         * Metadata symbol.
         * @member {string} symbol
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.symbol = "";

        /**
         * Metadata uri.
         * @member {string} uri
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.uri = "";

        /**
         * Metadata uriHash.
         * @member {string} uriHash
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         */
        Metadata.prototype.uriHash = "";

        /**
         * Creates a new Metadata instance using the specified properties.
         * @function create
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {cosmos.bank.v1beta1.IMetadata=} [properties] Properties to set
         * @returns {cosmos.bank.v1beta1.Metadata} Metadata instance
         */
        Metadata.create = function create(properties) {
          return new Metadata(properties);
        };

        /**
         * Encodes the specified Metadata message. Does not implicitly {@link cosmos.bank.v1beta1.Metadata.verify|verify} messages.
         * @function encode
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {cosmos.bank.v1beta1.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
          if (message.denomUnits != null && message.denomUnits.length)
            for (let i = 0; i < message.denomUnits.length; ++i)
              $root.cosmos.bank.v1beta1.DenomUnit.encode(message.denomUnits[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.base != null && Object.hasOwnProperty.call(message, "base"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.base);
          if (message.display != null && Object.hasOwnProperty.call(message, "display"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.display);
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
          if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.symbol);
          if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.uri);
          if (message.uriHash != null && Object.hasOwnProperty.call(message, "uriHash"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.uriHash);
          return writer;
        };

        /**
         * Encodes the specified Metadata message, length delimited. Does not implicitly {@link cosmos.bank.v1beta1.Metadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {cosmos.bank.v1beta1.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.bank.v1beta1.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cosmos.bank.v1beta1.Metadata();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.description = reader.string();
                break;
              case 2:
                if (!(message.denomUnits && message.denomUnits.length))
                  message.denomUnits = [];
                message.denomUnits.push($root.cosmos.bank.v1beta1.DenomUnit.decode(reader, reader.uint32()));
                break;
              case 3:
                message.base = reader.string();
                break;
              case 4:
                message.display = reader.string();
                break;
              case 5:
                message.name = reader.string();
                break;
              case 6:
                message.symbol = reader.string();
                break;
              case 7:
                message.uri = reader.string();
                break;
              case 8:
                message.uriHash = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.bank.v1beta1.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Metadata message.
         * @function verify
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Metadata.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
              return "description: string expected";
          if (message.denomUnits != null && message.hasOwnProperty("denomUnits")) {
            if (!Array.isArray(message.denomUnits))
              return "denomUnits: array expected";
            for (let i = 0; i < message.denomUnits.length; ++i) {
              let error = $root.cosmos.bank.v1beta1.DenomUnit.verify(message.denomUnits[i]);
              if (error)
                return "denomUnits." + error;
            }
          }
          if (message.base != null && message.hasOwnProperty("base"))
            if (!$util.isString(message.base))
              return "base: string expected";
          if (message.display != null && message.hasOwnProperty("display"))
            if (!$util.isString(message.display))
              return "display: string expected";
          if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
              return "name: string expected";
          if (message.symbol != null && message.hasOwnProperty("symbol"))
            if (!$util.isString(message.symbol))
              return "symbol: string expected";
          if (message.uri != null && message.hasOwnProperty("uri"))
            if (!$util.isString(message.uri))
              return "uri: string expected";
          if (message.uriHash != null && message.hasOwnProperty("uriHash"))
            if (!$util.isString(message.uriHash))
              return "uriHash: string expected";
          return null;
        };

        /**
         * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.bank.v1beta1.Metadata} Metadata
         */
        Metadata.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.bank.v1beta1.Metadata)
            return object;
          let message = new $root.cosmos.bank.v1beta1.Metadata();
          if (object.description != null)
            message.description = String(object.description);
          if (object.denomUnits) {
            if (!Array.isArray(object.denomUnits))
              throw TypeError(".cosmos.bank.v1beta1.Metadata.denomUnits: array expected");
            message.denomUnits = [];
            for (let i = 0; i < object.denomUnits.length; ++i) {
              if (typeof object.denomUnits[i] !== "object")
                throw TypeError(".cosmos.bank.v1beta1.Metadata.denomUnits: object expected");
              message.denomUnits[i] = $root.cosmos.bank.v1beta1.DenomUnit.fromObject(object.denomUnits[i]);
            }
          }
          if (object.base != null)
            message.base = String(object.base);
          if (object.display != null)
            message.display = String(object.display);
          if (object.name != null)
            message.name = String(object.name);
          if (object.symbol != null)
            message.symbol = String(object.symbol);
          if (object.uri != null)
            message.uri = String(object.uri);
          if (object.uriHash != null)
            message.uriHash = String(object.uriHash);
          return message;
        };

        /**
         * Creates a plain object from a Metadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.bank.v1beta1.Metadata
         * @static
         * @param {cosmos.bank.v1beta1.Metadata} message Metadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Metadata.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.denomUnits = [];
          if (options.defaults) {
            object.description = "";
            object.base = "";
            object.display = "";
            object.name = "";
            object.symbol = "";
            object.uri = "";
            object.uriHash = "";
          }
          if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
          if (message.denomUnits && message.denomUnits.length) {
            object.denomUnits = [];
            for (let j = 0; j < message.denomUnits.length; ++j)
              object.denomUnits[j] = $root.cosmos.bank.v1beta1.DenomUnit.toObject(message.denomUnits[j], options);
          }
          if (message.base != null && message.hasOwnProperty("base"))
            object.base = message.base;
          if (message.display != null && message.hasOwnProperty("display"))
            object.display = message.display;
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.symbol != null && message.hasOwnProperty("symbol"))
            object.symbol = message.symbol;
          if (message.uri != null && message.hasOwnProperty("uri"))
            object.uri = message.uri;
          if (message.uriHash != null && message.hasOwnProperty("uriHash"))
            object.uriHash = message.uriHash;
          return object;
        };

        /**
         * Converts this Metadata to JSON.
         * @function toJSON
         * @memberof cosmos.bank.v1beta1.Metadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Metadata.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Metadata;
      })();

      return v1beta1;
    })();

    return bank;
  })();

  return cosmos;
})();

export const gravity = $root.gravity = (() => {

  /**
   * Namespace gravity.
   * @exports gravity
   * @namespace
   */
  const gravity = {};

  gravity.v1 = (function() {

    /**
     * Namespace v1.
     * @memberof gravity
     * @namespace
     */
    const v1 = {};

    /**
     * ClaimType enum.
     * @name gravity.v1.ClaimType
     * @enum {number}
     * @property {number} CLAIM_TYPE_UNSPECIFIED=0 CLAIM_TYPE_UNSPECIFIED value
     * @property {number} CLAIM_TYPE_SEND_TO_COSMOS=1 CLAIM_TYPE_SEND_TO_COSMOS value
     * @property {number} CLAIM_TYPE_BATCH_SEND_TO_ETH=2 CLAIM_TYPE_BATCH_SEND_TO_ETH value
     * @property {number} CLAIM_TYPE_ERC20_DEPLOYED=3 CLAIM_TYPE_ERC20_DEPLOYED value
     * @property {number} CLAIM_TYPE_LOGIC_CALL_EXECUTED=4 CLAIM_TYPE_LOGIC_CALL_EXECUTED value
     * @property {number} CLAIM_TYPE_VALSET_UPDATED=5 CLAIM_TYPE_VALSET_UPDATED value
     */
    v1.ClaimType = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "CLAIM_TYPE_UNSPECIFIED"] = 0;
      values[valuesById[1] = "CLAIM_TYPE_SEND_TO_COSMOS"] = 1;
      values[valuesById[2] = "CLAIM_TYPE_BATCH_SEND_TO_ETH"] = 2;
      values[valuesById[3] = "CLAIM_TYPE_ERC20_DEPLOYED"] = 3;
      values[valuesById[4] = "CLAIM_TYPE_LOGIC_CALL_EXECUTED"] = 4;
      values[valuesById[5] = "CLAIM_TYPE_VALSET_UPDATED"] = 5;
      return values;
    })();

    v1.Attestation = (function() {

      /**
       * Properties of an Attestation.
       * @memberof gravity.v1
       * @interface IAttestation
       * @property {boolean|null} [observed] Attestation observed
       * @property {Array.<string>|null} [votes] Attestation votes
       * @property {number|Long|null} [height] Attestation height
       * @property {google.protobuf.IAny|null} [claim] Attestation claim
       */

      /**
       * Constructs a new Attestation.
       * @memberof gravity.v1
       * @classdesc Represents an Attestation.
       * @implements IAttestation
       * @constructor
       * @param {gravity.v1.IAttestation=} [properties] Properties to set
       */
      function Attestation(properties) {
        this.votes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Attestation observed.
       * @member {boolean} observed
       * @memberof gravity.v1.Attestation
       * @instance
       */
      Attestation.prototype.observed = false;

      /**
       * Attestation votes.
       * @member {Array.<string>} votes
       * @memberof gravity.v1.Attestation
       * @instance
       */
      Attestation.prototype.votes = $util.emptyArray;

      /**
       * Attestation height.
       * @member {number|Long} height
       * @memberof gravity.v1.Attestation
       * @instance
       */
      Attestation.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Attestation claim.
       * @member {google.protobuf.IAny|null|undefined} claim
       * @memberof gravity.v1.Attestation
       * @instance
       */
      Attestation.prototype.claim = null;

      /**
       * Creates a new Attestation instance using the specified properties.
       * @function create
       * @memberof gravity.v1.Attestation
       * @static
       * @param {gravity.v1.IAttestation=} [properties] Properties to set
       * @returns {gravity.v1.Attestation} Attestation instance
       */
      Attestation.create = function create(properties) {
        return new Attestation(properties);
      };

      /**
       * Encodes the specified Attestation message. Does not implicitly {@link gravity.v1.Attestation.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.Attestation
       * @static
       * @param {gravity.v1.IAttestation} message Attestation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Attestation.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.observed != null && Object.hasOwnProperty.call(message, "observed"))
          writer.uint32(/* id 1, wireType 0 =*/8).bool(message.observed);
        if (message.votes != null && message.votes.length)
          for (let i = 0; i < message.votes.length; ++i)
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.votes[i]);
        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
          writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.height);
        if (message.claim != null && Object.hasOwnProperty.call(message, "claim"))
          $root.google.protobuf.Any.encode(message.claim, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Attestation message, length delimited. Does not implicitly {@link gravity.v1.Attestation.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.Attestation
       * @static
       * @param {gravity.v1.IAttestation} message Attestation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Attestation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an Attestation message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.Attestation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.Attestation} Attestation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Attestation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.Attestation();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.observed = reader.bool();
              break;
            case 2:
              if (!(message.votes && message.votes.length))
                message.votes = [];
              message.votes.push(reader.string());
              break;
            case 3:
              message.height = reader.uint64();
              break;
            case 4:
              message.claim = $root.google.protobuf.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an Attestation message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.Attestation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.Attestation} Attestation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Attestation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an Attestation message.
       * @function verify
       * @memberof gravity.v1.Attestation
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Attestation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.observed != null && message.hasOwnProperty("observed"))
          if (typeof message.observed !== "boolean")
            return "observed: boolean expected";
        if (message.votes != null && message.hasOwnProperty("votes")) {
          if (!Array.isArray(message.votes))
            return "votes: array expected";
          for (let i = 0; i < message.votes.length; ++i)
            if (!$util.isString(message.votes[i]))
              return "votes: string[] expected";
        }
        if (message.height != null && message.hasOwnProperty("height"))
          if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
            return "height: integer|Long expected";
        if (message.claim != null && message.hasOwnProperty("claim")) {
          let error = $root.google.protobuf.Any.verify(message.claim);
          if (error)
            return "claim." + error;
        }
        return null;
      };

      /**
       * Creates an Attestation message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.Attestation
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.Attestation} Attestation
       */
      Attestation.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.Attestation)
          return object;
        let message = new $root.gravity.v1.Attestation();
        if (object.observed != null)
          message.observed = Boolean(object.observed);
        if (object.votes) {
          if (!Array.isArray(object.votes))
            throw TypeError(".gravity.v1.Attestation.votes: array expected");
          message.votes = [];
          for (let i = 0; i < object.votes.length; ++i)
            message.votes[i] = String(object.votes[i]);
        }
        if (object.height != null)
          if ($util.Long)
            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
          else if (typeof object.height === "string")
            message.height = parseInt(object.height, 10);
          else if (typeof object.height === "number")
            message.height = object.height;
          else if (typeof object.height === "object")
            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
        if (object.claim != null) {
          if (typeof object.claim !== "object")
            throw TypeError(".gravity.v1.Attestation.claim: object expected");
          message.claim = $root.google.protobuf.Any.fromObject(object.claim);
        }
        return message;
      };

      /**
       * Creates a plain object from an Attestation message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.Attestation
       * @static
       * @param {gravity.v1.Attestation} message Attestation
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Attestation.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.votes = [];
        if (options.defaults) {
          object.observed = false;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.height = options.longs === String ? "0" : 0;
          object.claim = null;
        }
        if (message.observed != null && message.hasOwnProperty("observed"))
          object.observed = message.observed;
        if (message.votes && message.votes.length) {
          object.votes = [];
          for (let j = 0; j < message.votes.length; ++j)
            object.votes[j] = message.votes[j];
        }
        if (message.height != null && message.hasOwnProperty("height"))
          if (typeof message.height === "number")
            object.height = options.longs === String ? String(message.height) : message.height;
          else
            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
        if (message.claim != null && message.hasOwnProperty("claim"))
          object.claim = $root.google.protobuf.Any.toObject(message.claim, options);
        return object;
      };

      /**
       * Converts this Attestation to JSON.
       * @function toJSON
       * @memberof gravity.v1.Attestation
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Attestation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Attestation;
    })();

    v1.ERC20Token = (function() {

      /**
       * Properties of a ERC20Token.
       * @memberof gravity.v1
       * @interface IERC20Token
       * @property {string|null} [contract] ERC20Token contract
       * @property {string|null} [amount] ERC20Token amount
       */

      /**
       * Constructs a new ERC20Token.
       * @memberof gravity.v1
       * @classdesc Represents a ERC20Token.
       * @implements IERC20Token
       * @constructor
       * @param {gravity.v1.IERC20Token=} [properties] Properties to set
       */
      function ERC20Token(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * ERC20Token contract.
       * @member {string} contract
       * @memberof gravity.v1.ERC20Token
       * @instance
       */
      ERC20Token.prototype.contract = "";

      /**
       * ERC20Token amount.
       * @member {string} amount
       * @memberof gravity.v1.ERC20Token
       * @instance
       */
      ERC20Token.prototype.amount = "";

      /**
       * Creates a new ERC20Token instance using the specified properties.
       * @function create
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {gravity.v1.IERC20Token=} [properties] Properties to set
       * @returns {gravity.v1.ERC20Token} ERC20Token instance
       */
      ERC20Token.create = function create(properties) {
        return new ERC20Token(properties);
      };

      /**
       * Encodes the specified ERC20Token message. Does not implicitly {@link gravity.v1.ERC20Token.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {gravity.v1.IERC20Token} message ERC20Token message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ERC20Token.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.contract);
        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified ERC20Token message, length delimited. Does not implicitly {@link gravity.v1.ERC20Token.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {gravity.v1.IERC20Token} message ERC20Token message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ERC20Token.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ERC20Token message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.ERC20Token} ERC20Token
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ERC20Token.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.ERC20Token();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.contract = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ERC20Token message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.ERC20Token} ERC20Token
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ERC20Token.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ERC20Token message.
       * @function verify
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ERC20Token.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.contract != null && message.hasOwnProperty("contract"))
          if (!$util.isString(message.contract))
            return "contract: string expected";
        if (message.amount != null && message.hasOwnProperty("amount"))
          if (!$util.isString(message.amount))
            return "amount: string expected";
        return null;
      };

      /**
       * Creates a ERC20Token message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.ERC20Token} ERC20Token
       */
      ERC20Token.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.ERC20Token)
          return object;
        let message = new $root.gravity.v1.ERC20Token();
        if (object.contract != null)
          message.contract = String(object.contract);
        if (object.amount != null)
          message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a ERC20Token message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.ERC20Token
       * @static
       * @param {gravity.v1.ERC20Token} message ERC20Token
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ERC20Token.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.contract = "";
          object.amount = "";
        }
        if (message.contract != null && message.hasOwnProperty("contract"))
          object.contract = message.contract;
        if (message.amount != null && message.hasOwnProperty("amount"))
          object.amount = message.amount;
        return object;
      };

      /**
       * Converts this ERC20Token to JSON.
       * @function toJSON
       * @memberof gravity.v1.ERC20Token
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ERC20Token.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ERC20Token;
    })();

    v1.IDSet = (function() {

      /**
       * Properties of a IDSet.
       * @memberof gravity.v1
       * @interface IIDSet
       * @property {Array.<number|Long>|null} [ids] IDSet ids
       */

      /**
       * Constructs a new IDSet.
       * @memberof gravity.v1
       * @classdesc Represents a IDSet.
       * @implements IIDSet
       * @constructor
       * @param {gravity.v1.IIDSet=} [properties] Properties to set
       */
      function IDSet(properties) {
        this.ids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * IDSet ids.
       * @member {Array.<number|Long>} ids
       * @memberof gravity.v1.IDSet
       * @instance
       */
      IDSet.prototype.ids = $util.emptyArray;

      /**
       * Creates a new IDSet instance using the specified properties.
       * @function create
       * @memberof gravity.v1.IDSet
       * @static
       * @param {gravity.v1.IIDSet=} [properties] Properties to set
       * @returns {gravity.v1.IDSet} IDSet instance
       */
      IDSet.create = function create(properties) {
        return new IDSet(properties);
      };

      /**
       * Encodes the specified IDSet message. Does not implicitly {@link gravity.v1.IDSet.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.IDSet
       * @static
       * @param {gravity.v1.IIDSet} message IDSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IDSet.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.ids != null && message.ids.length) {
          writer.uint32(/* id 1, wireType 2 =*/10).fork();
          for (let i = 0; i < message.ids.length; ++i)
            writer.uint64(message.ids[i]);
          writer.ldelim();
        }
        return writer;
      };

      /**
       * Encodes the specified IDSet message, length delimited. Does not implicitly {@link gravity.v1.IDSet.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.IDSet
       * @static
       * @param {gravity.v1.IIDSet} message IDSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IDSet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a IDSet message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.IDSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.IDSet} IDSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IDSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.IDSet();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.ids && message.ids.length))
                message.ids = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.ids.push(reader.uint64());
              } else
                message.ids.push(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a IDSet message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.IDSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.IDSet} IDSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IDSet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a IDSet message.
       * @function verify
       * @memberof gravity.v1.IDSet
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      IDSet.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.ids != null && message.hasOwnProperty("ids")) {
          if (!Array.isArray(message.ids))
            return "ids: array expected";
          for (let i = 0; i < message.ids.length; ++i)
            if (!$util.isInteger(message.ids[i]) && !(message.ids[i] && $util.isInteger(message.ids[i].low) && $util.isInteger(message.ids[i].high)))
              return "ids: integer|Long[] expected";
        }
        return null;
      };

      /**
       * Creates a IDSet message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.IDSet
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.IDSet} IDSet
       */
      IDSet.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.IDSet)
          return object;
        let message = new $root.gravity.v1.IDSet();
        if (object.ids) {
          if (!Array.isArray(object.ids))
            throw TypeError(".gravity.v1.IDSet.ids: array expected");
          message.ids = [];
          for (let i = 0; i < object.ids.length; ++i)
            if ($util.Long)
              (message.ids[i] = $util.Long.fromValue(object.ids[i])).unsigned = true;
            else if (typeof object.ids[i] === "string")
              message.ids[i] = parseInt(object.ids[i], 10);
            else if (typeof object.ids[i] === "number")
              message.ids[i] = object.ids[i];
            else if (typeof object.ids[i] === "object")
              message.ids[i] = new $util.LongBits(object.ids[i].low >>> 0, object.ids[i].high >>> 0).toNumber(true);
        }
        return message;
      };

      /**
       * Creates a plain object from a IDSet message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.IDSet
       * @static
       * @param {gravity.v1.IDSet} message IDSet
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      IDSet.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.ids = [];
        if (message.ids && message.ids.length) {
          object.ids = [];
          for (let j = 0; j < message.ids.length; ++j)
            if (typeof message.ids[j] === "number")
              object.ids[j] = options.longs === String ? String(message.ids[j]) : message.ids[j];
            else
              object.ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ids[j]) : options.longs === Number ? new $util.LongBits(message.ids[j].low >>> 0, message.ids[j].high >>> 0).toNumber(true) : message.ids[j];
        }
        return object;
      };

      /**
       * Converts this IDSet to JSON.
       * @function toJSON
       * @memberof gravity.v1.IDSet
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      IDSet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return IDSet;
    })();

    v1.BatchFees = (function() {

      /**
       * Properties of a BatchFees.
       * @memberof gravity.v1
       * @interface IBatchFees
       * @property {string|null} [token] BatchFees token
       * @property {string|null} [totalFees] BatchFees totalFees
       */

      /**
       * Constructs a new BatchFees.
       * @memberof gravity.v1
       * @classdesc Represents a BatchFees.
       * @implements IBatchFees
       * @constructor
       * @param {gravity.v1.IBatchFees=} [properties] Properties to set
       */
      function BatchFees(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * BatchFees token.
       * @member {string} token
       * @memberof gravity.v1.BatchFees
       * @instance
       */
      BatchFees.prototype.token = "";

      /**
       * BatchFees totalFees.
       * @member {string} totalFees
       * @memberof gravity.v1.BatchFees
       * @instance
       */
      BatchFees.prototype.totalFees = "";

      /**
       * Creates a new BatchFees instance using the specified properties.
       * @function create
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {gravity.v1.IBatchFees=} [properties] Properties to set
       * @returns {gravity.v1.BatchFees} BatchFees instance
       */
      BatchFees.create = function create(properties) {
        return new BatchFees(properties);
      };

      /**
       * Encodes the specified BatchFees message. Does not implicitly {@link gravity.v1.BatchFees.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {gravity.v1.IBatchFees} message BatchFees message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BatchFees.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.token != null && Object.hasOwnProperty.call(message, "token"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
        if (message.totalFees != null && Object.hasOwnProperty.call(message, "totalFees"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.totalFees);
        return writer;
      };

      /**
       * Encodes the specified BatchFees message, length delimited. Does not implicitly {@link gravity.v1.BatchFees.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {gravity.v1.IBatchFees} message BatchFees message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BatchFees.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BatchFees message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.BatchFees} BatchFees
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BatchFees.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.BatchFees();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.token = reader.string();
              break;
            case 2:
              message.totalFees = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BatchFees message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.BatchFees} BatchFees
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BatchFees.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BatchFees message.
       * @function verify
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BatchFees.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.token != null && message.hasOwnProperty("token"))
          if (!$util.isString(message.token))
            return "token: string expected";
        if (message.totalFees != null && message.hasOwnProperty("totalFees"))
          if (!$util.isString(message.totalFees))
            return "totalFees: string expected";
        return null;
      };

      /**
       * Creates a BatchFees message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.BatchFees} BatchFees
       */
      BatchFees.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.BatchFees)
          return object;
        let message = new $root.gravity.v1.BatchFees();
        if (object.token != null)
          message.token = String(object.token);
        if (object.totalFees != null)
          message.totalFees = String(object.totalFees);
        return message;
      };

      /**
       * Creates a plain object from a BatchFees message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.BatchFees
       * @static
       * @param {gravity.v1.BatchFees} message BatchFees
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BatchFees.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.token = "";
          object.totalFees = "";
        }
        if (message.token != null && message.hasOwnProperty("token"))
          object.token = message.token;
        if (message.totalFees != null && message.hasOwnProperty("totalFees"))
          object.totalFees = message.totalFees;
        return object;
      };

      /**
       * Converts this BatchFees to JSON.
       * @function toJSON
       * @memberof gravity.v1.BatchFees
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BatchFees.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BatchFees;
    })();

    v1.OutgoingTxBatch = (function() {

      /**
       * Properties of an OutgoingTxBatch.
       * @memberof gravity.v1
       * @interface IOutgoingTxBatch
       * @property {number|Long|null} [batchNonce] OutgoingTxBatch batchNonce
       * @property {number|Long|null} [batchTimeout] OutgoingTxBatch batchTimeout
       * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [transactions] OutgoingTxBatch transactions
       * @property {string|null} [tokenContract] OutgoingTxBatch tokenContract
       * @property {number|Long|null} [block] OutgoingTxBatch block
       */

      /**
       * Constructs a new OutgoingTxBatch.
       * @memberof gravity.v1
       * @classdesc Represents an OutgoingTxBatch.
       * @implements IOutgoingTxBatch
       * @constructor
       * @param {gravity.v1.IOutgoingTxBatch=} [properties] Properties to set
       */
      function OutgoingTxBatch(properties) {
        this.transactions = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * OutgoingTxBatch batchNonce.
       * @member {number|Long} batchNonce
       * @memberof gravity.v1.OutgoingTxBatch
       * @instance
       */
      OutgoingTxBatch.prototype.batchNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * OutgoingTxBatch batchTimeout.
       * @member {number|Long} batchTimeout
       * @memberof gravity.v1.OutgoingTxBatch
       * @instance
       */
      OutgoingTxBatch.prototype.batchTimeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * OutgoingTxBatch transactions.
       * @member {Array.<gravity.v1.IOutgoingTransferTx>} transactions
       * @memberof gravity.v1.OutgoingTxBatch
       * @instance
       */
      OutgoingTxBatch.prototype.transactions = $util.emptyArray;

      /**
       * OutgoingTxBatch tokenContract.
       * @member {string} tokenContract
       * @memberof gravity.v1.OutgoingTxBatch
       * @instance
       */
      OutgoingTxBatch.prototype.tokenContract = "";

      /**
       * OutgoingTxBatch block.
       * @member {number|Long} block
       * @memberof gravity.v1.OutgoingTxBatch
       * @instance
       */
      OutgoingTxBatch.prototype.block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new OutgoingTxBatch instance using the specified properties.
       * @function create
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {gravity.v1.IOutgoingTxBatch=} [properties] Properties to set
       * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch instance
       */
      OutgoingTxBatch.create = function create(properties) {
        return new OutgoingTxBatch(properties);
      };

      /**
       * Encodes the specified OutgoingTxBatch message. Does not implicitly {@link gravity.v1.OutgoingTxBatch.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {gravity.v1.IOutgoingTxBatch} message OutgoingTxBatch message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OutgoingTxBatch.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.batchNonce != null && Object.hasOwnProperty.call(message, "batchNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.batchNonce);
        if (message.batchTimeout != null && Object.hasOwnProperty.call(message, "batchTimeout"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.batchTimeout);
        if (message.transactions != null && message.transactions.length)
          for (let i = 0; i < message.transactions.length; ++i)
            $root.gravity.v1.OutgoingTransferTx.encode(message.transactions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.tokenContract != null && Object.hasOwnProperty.call(message, "tokenContract"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.tokenContract);
        if (message.block != null && Object.hasOwnProperty.call(message, "block"))
          writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.block);
        return writer;
      };

      /**
       * Encodes the specified OutgoingTxBatch message, length delimited. Does not implicitly {@link gravity.v1.OutgoingTxBatch.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {gravity.v1.IOutgoingTxBatch} message OutgoingTxBatch message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OutgoingTxBatch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OutgoingTxBatch message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OutgoingTxBatch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.OutgoingTxBatch();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.batchNonce = reader.uint64();
              break;
            case 2:
              message.batchTimeout = reader.uint64();
              break;
            case 3:
              if (!(message.transactions && message.transactions.length))
                message.transactions = [];
              message.transactions.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
              break;
            case 4:
              message.tokenContract = reader.string();
              break;
            case 5:
              message.block = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OutgoingTxBatch message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OutgoingTxBatch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OutgoingTxBatch message.
       * @function verify
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OutgoingTxBatch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.batchNonce != null && message.hasOwnProperty("batchNonce"))
          if (!$util.isInteger(message.batchNonce) && !(message.batchNonce && $util.isInteger(message.batchNonce.low) && $util.isInteger(message.batchNonce.high)))
            return "batchNonce: integer|Long expected";
        if (message.batchTimeout != null && message.hasOwnProperty("batchTimeout"))
          if (!$util.isInteger(message.batchTimeout) && !(message.batchTimeout && $util.isInteger(message.batchTimeout.low) && $util.isInteger(message.batchTimeout.high)))
            return "batchTimeout: integer|Long expected";
        if (message.transactions != null && message.hasOwnProperty("transactions")) {
          if (!Array.isArray(message.transactions))
            return "transactions: array expected";
          for (let i = 0; i < message.transactions.length; ++i) {
            let error = $root.gravity.v1.OutgoingTransferTx.verify(message.transactions[i]);
            if (error)
              return "transactions." + error;
          }
        }
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          if (!$util.isString(message.tokenContract))
            return "tokenContract: string expected";
        if (message.block != null && message.hasOwnProperty("block"))
          if (!$util.isInteger(message.block) && !(message.block && $util.isInteger(message.block.low) && $util.isInteger(message.block.high)))
            return "block: integer|Long expected";
        return null;
      };

      /**
       * Creates an OutgoingTxBatch message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch
       */
      OutgoingTxBatch.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.OutgoingTxBatch)
          return object;
        let message = new $root.gravity.v1.OutgoingTxBatch();
        if (object.batchNonce != null)
          if ($util.Long)
            (message.batchNonce = $util.Long.fromValue(object.batchNonce)).unsigned = true;
          else if (typeof object.batchNonce === "string")
            message.batchNonce = parseInt(object.batchNonce, 10);
          else if (typeof object.batchNonce === "number")
            message.batchNonce = object.batchNonce;
          else if (typeof object.batchNonce === "object")
            message.batchNonce = new $util.LongBits(object.batchNonce.low >>> 0, object.batchNonce.high >>> 0).toNumber(true);
        if (object.batchTimeout != null)
          if ($util.Long)
            (message.batchTimeout = $util.Long.fromValue(object.batchTimeout)).unsigned = true;
          else if (typeof object.batchTimeout === "string")
            message.batchTimeout = parseInt(object.batchTimeout, 10);
          else if (typeof object.batchTimeout === "number")
            message.batchTimeout = object.batchTimeout;
          else if (typeof object.batchTimeout === "object")
            message.batchTimeout = new $util.LongBits(object.batchTimeout.low >>> 0, object.batchTimeout.high >>> 0).toNumber(true);
        if (object.transactions) {
          if (!Array.isArray(object.transactions))
            throw TypeError(".gravity.v1.OutgoingTxBatch.transactions: array expected");
          message.transactions = [];
          for (let i = 0; i < object.transactions.length; ++i) {
            if (typeof object.transactions[i] !== "object")
              throw TypeError(".gravity.v1.OutgoingTxBatch.transactions: object expected");
            message.transactions[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.transactions[i]);
          }
        }
        if (object.tokenContract != null)
          message.tokenContract = String(object.tokenContract);
        if (object.block != null)
          if ($util.Long)
            (message.block = $util.Long.fromValue(object.block)).unsigned = true;
          else if (typeof object.block === "string")
            message.block = parseInt(object.block, 10);
          else if (typeof object.block === "number")
            message.block = object.block;
          else if (typeof object.block === "object")
            message.block = new $util.LongBits(object.block.low >>> 0, object.block.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from an OutgoingTxBatch message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.OutgoingTxBatch
       * @static
       * @param {gravity.v1.OutgoingTxBatch} message OutgoingTxBatch
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OutgoingTxBatch.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.transactions = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.batchNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.batchNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.batchTimeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.batchTimeout = options.longs === String ? "0" : 0;
          object.tokenContract = "";
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.block = options.longs === String ? "0" : 0;
        }
        if (message.batchNonce != null && message.hasOwnProperty("batchNonce"))
          if (typeof message.batchNonce === "number")
            object.batchNonce = options.longs === String ? String(message.batchNonce) : message.batchNonce;
          else
            object.batchNonce = options.longs === String ? $util.Long.prototype.toString.call(message.batchNonce) : options.longs === Number ? new $util.LongBits(message.batchNonce.low >>> 0, message.batchNonce.high >>> 0).toNumber(true) : message.batchNonce;
        if (message.batchTimeout != null && message.hasOwnProperty("batchTimeout"))
          if (typeof message.batchTimeout === "number")
            object.batchTimeout = options.longs === String ? String(message.batchTimeout) : message.batchTimeout;
          else
            object.batchTimeout = options.longs === String ? $util.Long.prototype.toString.call(message.batchTimeout) : options.longs === Number ? new $util.LongBits(message.batchTimeout.low >>> 0, message.batchTimeout.high >>> 0).toNumber(true) : message.batchTimeout;
        if (message.transactions && message.transactions.length) {
          object.transactions = [];
          for (let j = 0; j < message.transactions.length; ++j)
            object.transactions[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.transactions[j], options);
        }
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          object.tokenContract = message.tokenContract;
        if (message.block != null && message.hasOwnProperty("block"))
          if (typeof message.block === "number")
            object.block = options.longs === String ? String(message.block) : message.block;
          else
            object.block = options.longs === String ? $util.Long.prototype.toString.call(message.block) : options.longs === Number ? new $util.LongBits(message.block.low >>> 0, message.block.high >>> 0).toNumber(true) : message.block;
        return object;
      };

      /**
       * Converts this OutgoingTxBatch to JSON.
       * @function toJSON
       * @memberof gravity.v1.OutgoingTxBatch
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OutgoingTxBatch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OutgoingTxBatch;
    })();

    v1.OutgoingTransferTx = (function() {

      /**
       * Properties of an OutgoingTransferTx.
       * @memberof gravity.v1
       * @interface IOutgoingTransferTx
       * @property {number|Long|null} [id] OutgoingTransferTx id
       * @property {string|null} [sender] OutgoingTransferTx sender
       * @property {string|null} [destAddress] OutgoingTransferTx destAddress
       * @property {gravity.v1.IERC20Token|null} [erc20Token] OutgoingTransferTx erc20Token
       * @property {gravity.v1.IERC20Token|null} [erc20Fee] OutgoingTransferTx erc20Fee
       */

      /**
       * Constructs a new OutgoingTransferTx.
       * @memberof gravity.v1
       * @classdesc Represents an OutgoingTransferTx.
       * @implements IOutgoingTransferTx
       * @constructor
       * @param {gravity.v1.IOutgoingTransferTx=} [properties] Properties to set
       */
      function OutgoingTransferTx(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * OutgoingTransferTx id.
       * @member {number|Long} id
       * @memberof gravity.v1.OutgoingTransferTx
       * @instance
       */
      OutgoingTransferTx.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * OutgoingTransferTx sender.
       * @member {string} sender
       * @memberof gravity.v1.OutgoingTransferTx
       * @instance
       */
      OutgoingTransferTx.prototype.sender = "";

      /**
       * OutgoingTransferTx destAddress.
       * @member {string} destAddress
       * @memberof gravity.v1.OutgoingTransferTx
       * @instance
       */
      OutgoingTransferTx.prototype.destAddress = "";

      /**
       * OutgoingTransferTx erc20Token.
       * @member {gravity.v1.IERC20Token|null|undefined} erc20Token
       * @memberof gravity.v1.OutgoingTransferTx
       * @instance
       */
      OutgoingTransferTx.prototype.erc20Token = null;

      /**
       * OutgoingTransferTx erc20Fee.
       * @member {gravity.v1.IERC20Token|null|undefined} erc20Fee
       * @memberof gravity.v1.OutgoingTransferTx
       * @instance
       */
      OutgoingTransferTx.prototype.erc20Fee = null;

      /**
       * Creates a new OutgoingTransferTx instance using the specified properties.
       * @function create
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {gravity.v1.IOutgoingTransferTx=} [properties] Properties to set
       * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx instance
       */
      OutgoingTransferTx.create = function create(properties) {
        return new OutgoingTransferTx(properties);
      };

      /**
       * Encodes the specified OutgoingTransferTx message. Does not implicitly {@link gravity.v1.OutgoingTransferTx.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {gravity.v1.IOutgoingTransferTx} message OutgoingTransferTx message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OutgoingTransferTx.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
        if (message.destAddress != null && Object.hasOwnProperty.call(message, "destAddress"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.destAddress);
        if (message.erc20Token != null && Object.hasOwnProperty.call(message, "erc20Token"))
          $root.gravity.v1.ERC20Token.encode(message.erc20Token, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.erc20Fee != null && Object.hasOwnProperty.call(message, "erc20Fee"))
          $root.gravity.v1.ERC20Token.encode(message.erc20Fee, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OutgoingTransferTx message, length delimited. Does not implicitly {@link gravity.v1.OutgoingTransferTx.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {gravity.v1.IOutgoingTransferTx} message OutgoingTransferTx message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OutgoingTransferTx.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OutgoingTransferTx message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OutgoingTransferTx.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.OutgoingTransferTx();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.sender = reader.string();
              break;
            case 3:
              message.destAddress = reader.string();
              break;
            case 4:
              message.erc20Token = $root.gravity.v1.ERC20Token.decode(reader, reader.uint32());
              break;
            case 5:
              message.erc20Fee = $root.gravity.v1.ERC20Token.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OutgoingTransferTx message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OutgoingTransferTx.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OutgoingTransferTx message.
       * @function verify
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OutgoingTransferTx.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return "id: integer|Long expected";
        if (message.sender != null && message.hasOwnProperty("sender"))
          if (!$util.isString(message.sender))
            return "sender: string expected";
        if (message.destAddress != null && message.hasOwnProperty("destAddress"))
          if (!$util.isString(message.destAddress))
            return "destAddress: string expected";
        if (message.erc20Token != null && message.hasOwnProperty("erc20Token")) {
          let error = $root.gravity.v1.ERC20Token.verify(message.erc20Token);
          if (error)
            return "erc20Token." + error;
        }
        if (message.erc20Fee != null && message.hasOwnProperty("erc20Fee")) {
          let error = $root.gravity.v1.ERC20Token.verify(message.erc20Fee);
          if (error)
            return "erc20Fee." + error;
        }
        return null;
      };

      /**
       * Creates an OutgoingTransferTx message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx
       */
      OutgoingTransferTx.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.OutgoingTransferTx)
          return object;
        let message = new $root.gravity.v1.OutgoingTransferTx();
        if (object.id != null)
          if ($util.Long)
            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === "string")
            message.id = parseInt(object.id, 10);
          else if (typeof object.id === "number")
            message.id = object.id;
          else if (typeof object.id === "object")
            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.sender != null)
          message.sender = String(object.sender);
        if (object.destAddress != null)
          message.destAddress = String(object.destAddress);
        if (object.erc20Token != null) {
          if (typeof object.erc20Token !== "object")
            throw TypeError(".gravity.v1.OutgoingTransferTx.erc20Token: object expected");
          message.erc20Token = $root.gravity.v1.ERC20Token.fromObject(object.erc20Token);
        }
        if (object.erc20Fee != null) {
          if (typeof object.erc20Fee !== "object")
            throw TypeError(".gravity.v1.OutgoingTransferTx.erc20Fee: object expected");
          message.erc20Fee = $root.gravity.v1.ERC20Token.fromObject(object.erc20Fee);
        }
        return message;
      };

      /**
       * Creates a plain object from an OutgoingTransferTx message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.OutgoingTransferTx
       * @static
       * @param {gravity.v1.OutgoingTransferTx} message OutgoingTransferTx
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OutgoingTransferTx.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.id = options.longs === String ? "0" : 0;
          object.sender = "";
          object.destAddress = "";
          object.erc20Token = null;
          object.erc20Fee = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
          if (typeof message.id === "number")
            object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.sender != null && message.hasOwnProperty("sender"))
          object.sender = message.sender;
        if (message.destAddress != null && message.hasOwnProperty("destAddress"))
          object.destAddress = message.destAddress;
        if (message.erc20Token != null && message.hasOwnProperty("erc20Token"))
          object.erc20Token = $root.gravity.v1.ERC20Token.toObject(message.erc20Token, options);
        if (message.erc20Fee != null && message.hasOwnProperty("erc20Fee"))
          object.erc20Fee = $root.gravity.v1.ERC20Token.toObject(message.erc20Fee, options);
        return object;
      };

      /**
       * Converts this OutgoingTransferTx to JSON.
       * @function toJSON
       * @memberof gravity.v1.OutgoingTransferTx
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OutgoingTransferTx.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OutgoingTransferTx;
    })();

    v1.OutgoingLogicCall = (function() {

      /**
       * Properties of an OutgoingLogicCall.
       * @memberof gravity.v1
       * @interface IOutgoingLogicCall
       * @property {Array.<gravity.v1.IERC20Token>|null} [transfers] OutgoingLogicCall transfers
       * @property {Array.<gravity.v1.IERC20Token>|null} [fees] OutgoingLogicCall fees
       * @property {string|null} [logicContractAddress] OutgoingLogicCall logicContractAddress
       * @property {Uint8Array|null} [payload] OutgoingLogicCall payload
       * @property {number|Long|null} [timeout] OutgoingLogicCall timeout
       * @property {Uint8Array|null} [invalidationId] OutgoingLogicCall invalidationId
       * @property {number|Long|null} [invalidationNonce] OutgoingLogicCall invalidationNonce
       * @property {number|Long|null} [block] OutgoingLogicCall block
       */

      /**
       * Constructs a new OutgoingLogicCall.
       * @memberof gravity.v1
       * @classdesc Represents an OutgoingLogicCall.
       * @implements IOutgoingLogicCall
       * @constructor
       * @param {gravity.v1.IOutgoingLogicCall=} [properties] Properties to set
       */
      function OutgoingLogicCall(properties) {
        this.transfers = [];
        this.fees = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * OutgoingLogicCall transfers.
       * @member {Array.<gravity.v1.IERC20Token>} transfers
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.transfers = $util.emptyArray;

      /**
       * OutgoingLogicCall fees.
       * @member {Array.<gravity.v1.IERC20Token>} fees
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.fees = $util.emptyArray;

      /**
       * OutgoingLogicCall logicContractAddress.
       * @member {string} logicContractAddress
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.logicContractAddress = "";

      /**
       * OutgoingLogicCall payload.
       * @member {Uint8Array} payload
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.payload = $util.newBuffer([]);

      /**
       * OutgoingLogicCall timeout.
       * @member {number|Long} timeout
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * OutgoingLogicCall invalidationId.
       * @member {Uint8Array} invalidationId
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.invalidationId = $util.newBuffer([]);

      /**
       * OutgoingLogicCall invalidationNonce.
       * @member {number|Long} invalidationNonce
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.invalidationNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * OutgoingLogicCall block.
       * @member {number|Long} block
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       */
      OutgoingLogicCall.prototype.block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new OutgoingLogicCall instance using the specified properties.
       * @function create
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {gravity.v1.IOutgoingLogicCall=} [properties] Properties to set
       * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall instance
       */
      OutgoingLogicCall.create = function create(properties) {
        return new OutgoingLogicCall(properties);
      };

      /**
       * Encodes the specified OutgoingLogicCall message. Does not implicitly {@link gravity.v1.OutgoingLogicCall.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {gravity.v1.IOutgoingLogicCall} message OutgoingLogicCall message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OutgoingLogicCall.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.transfers != null && message.transfers.length)
          for (let i = 0; i < message.transfers.length; ++i)
            $root.gravity.v1.ERC20Token.encode(message.transfers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.fees != null && message.fees.length)
          for (let i = 0; i < message.fees.length; ++i)
            $root.gravity.v1.ERC20Token.encode(message.fees[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.logicContractAddress != null && Object.hasOwnProperty.call(message, "logicContractAddress"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.logicContractAddress);
        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
          writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
        if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
          writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.timeout);
        if (message.invalidationId != null && Object.hasOwnProperty.call(message, "invalidationId"))
          writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.invalidationId);
        if (message.invalidationNonce != null && Object.hasOwnProperty.call(message, "invalidationNonce"))
          writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.invalidationNonce);
        if (message.block != null && Object.hasOwnProperty.call(message, "block"))
          writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.block);
        return writer;
      };

      /**
       * Encodes the specified OutgoingLogicCall message, length delimited. Does not implicitly {@link gravity.v1.OutgoingLogicCall.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {gravity.v1.IOutgoingLogicCall} message OutgoingLogicCall message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OutgoingLogicCall.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OutgoingLogicCall message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OutgoingLogicCall.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.OutgoingLogicCall();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.transfers && message.transfers.length))
                message.transfers = [];
              message.transfers.push($root.gravity.v1.ERC20Token.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.fees && message.fees.length))
                message.fees = [];
              message.fees.push($root.gravity.v1.ERC20Token.decode(reader, reader.uint32()));
              break;
            case 3:
              message.logicContractAddress = reader.string();
              break;
            case 4:
              message.payload = reader.bytes();
              break;
            case 5:
              message.timeout = reader.uint64();
              break;
            case 6:
              message.invalidationId = reader.bytes();
              break;
            case 7:
              message.invalidationNonce = reader.uint64();
              break;
            case 8:
              message.block = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OutgoingLogicCall message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OutgoingLogicCall.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OutgoingLogicCall message.
       * @function verify
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OutgoingLogicCall.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.transfers != null && message.hasOwnProperty("transfers")) {
          if (!Array.isArray(message.transfers))
            return "transfers: array expected";
          for (let i = 0; i < message.transfers.length; ++i) {
            let error = $root.gravity.v1.ERC20Token.verify(message.transfers[i]);
            if (error)
              return "transfers." + error;
          }
        }
        if (message.fees != null && message.hasOwnProperty("fees")) {
          if (!Array.isArray(message.fees))
            return "fees: array expected";
          for (let i = 0; i < message.fees.length; ++i) {
            let error = $root.gravity.v1.ERC20Token.verify(message.fees[i]);
            if (error)
              return "fees." + error;
          }
        }
        if (message.logicContractAddress != null && message.hasOwnProperty("logicContractAddress"))
          if (!$util.isString(message.logicContractAddress))
            return "logicContractAddress: string expected";
        if (message.payload != null && message.hasOwnProperty("payload"))
          if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
            return "payload: buffer expected";
        if (message.timeout != null && message.hasOwnProperty("timeout"))
          if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
            return "timeout: integer|Long expected";
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          if (!(message.invalidationId && typeof message.invalidationId.length === "number" || $util.isString(message.invalidationId)))
            return "invalidationId: buffer expected";
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (!$util.isInteger(message.invalidationNonce) && !(message.invalidationNonce && $util.isInteger(message.invalidationNonce.low) && $util.isInteger(message.invalidationNonce.high)))
            return "invalidationNonce: integer|Long expected";
        if (message.block != null && message.hasOwnProperty("block"))
          if (!$util.isInteger(message.block) && !(message.block && $util.isInteger(message.block.low) && $util.isInteger(message.block.high)))
            return "block: integer|Long expected";
        return null;
      };

      /**
       * Creates an OutgoingLogicCall message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall
       */
      OutgoingLogicCall.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.OutgoingLogicCall)
          return object;
        let message = new $root.gravity.v1.OutgoingLogicCall();
        if (object.transfers) {
          if (!Array.isArray(object.transfers))
            throw TypeError(".gravity.v1.OutgoingLogicCall.transfers: array expected");
          message.transfers = [];
          for (let i = 0; i < object.transfers.length; ++i) {
            if (typeof object.transfers[i] !== "object")
              throw TypeError(".gravity.v1.OutgoingLogicCall.transfers: object expected");
            message.transfers[i] = $root.gravity.v1.ERC20Token.fromObject(object.transfers[i]);
          }
        }
        if (object.fees) {
          if (!Array.isArray(object.fees))
            throw TypeError(".gravity.v1.OutgoingLogicCall.fees: array expected");
          message.fees = [];
          for (let i = 0; i < object.fees.length; ++i) {
            if (typeof object.fees[i] !== "object")
              throw TypeError(".gravity.v1.OutgoingLogicCall.fees: object expected");
            message.fees[i] = $root.gravity.v1.ERC20Token.fromObject(object.fees[i]);
          }
        }
        if (object.logicContractAddress != null)
          message.logicContractAddress = String(object.logicContractAddress);
        if (object.payload != null)
          if (typeof object.payload === "string")
            $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
          else if (object.payload.length)
            message.payload = object.payload;
        if (object.timeout != null)
          if ($util.Long)
            (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = true;
          else if (typeof object.timeout === "string")
            message.timeout = parseInt(object.timeout, 10);
          else if (typeof object.timeout === "number")
            message.timeout = object.timeout;
          else if (typeof object.timeout === "object")
            message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber(true);
        if (object.invalidationId != null)
          if (typeof object.invalidationId === "string")
            $util.base64.decode(object.invalidationId, message.invalidationId = $util.newBuffer($util.base64.length(object.invalidationId)), 0);
          else if (object.invalidationId.length)
            message.invalidationId = object.invalidationId;
        if (object.invalidationNonce != null)
          if ($util.Long)
            (message.invalidationNonce = $util.Long.fromValue(object.invalidationNonce)).unsigned = true;
          else if (typeof object.invalidationNonce === "string")
            message.invalidationNonce = parseInt(object.invalidationNonce, 10);
          else if (typeof object.invalidationNonce === "number")
            message.invalidationNonce = object.invalidationNonce;
          else if (typeof object.invalidationNonce === "object")
            message.invalidationNonce = new $util.LongBits(object.invalidationNonce.low >>> 0, object.invalidationNonce.high >>> 0).toNumber(true);
        if (object.block != null)
          if ($util.Long)
            (message.block = $util.Long.fromValue(object.block)).unsigned = true;
          else if (typeof object.block === "string")
            message.block = parseInt(object.block, 10);
          else if (typeof object.block === "number")
            message.block = object.block;
          else if (typeof object.block === "object")
            message.block = new $util.LongBits(object.block.low >>> 0, object.block.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from an OutgoingLogicCall message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.OutgoingLogicCall
       * @static
       * @param {gravity.v1.OutgoingLogicCall} message OutgoingLogicCall
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OutgoingLogicCall.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.transfers = [];
          object.fees = [];
        }
        if (options.defaults) {
          object.logicContractAddress = "";
          if (options.bytes === String)
            object.payload = "";
          else {
            object.payload = [];
            if (options.bytes !== Array)
              object.payload = $util.newBuffer(object.payload);
          }
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.timeout = options.longs === String ? "0" : 0;
          if (options.bytes === String)
            object.invalidationId = "";
          else {
            object.invalidationId = [];
            if (options.bytes !== Array)
              object.invalidationId = $util.newBuffer(object.invalidationId);
          }
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.invalidationNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.invalidationNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.block = options.longs === String ? "0" : 0;
        }
        if (message.transfers && message.transfers.length) {
          object.transfers = [];
          for (let j = 0; j < message.transfers.length; ++j)
            object.transfers[j] = $root.gravity.v1.ERC20Token.toObject(message.transfers[j], options);
        }
        if (message.fees && message.fees.length) {
          object.fees = [];
          for (let j = 0; j < message.fees.length; ++j)
            object.fees[j] = $root.gravity.v1.ERC20Token.toObject(message.fees[j], options);
        }
        if (message.logicContractAddress != null && message.hasOwnProperty("logicContractAddress"))
          object.logicContractAddress = message.logicContractAddress;
        if (message.payload != null && message.hasOwnProperty("payload"))
          object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
        if (message.timeout != null && message.hasOwnProperty("timeout"))
          if (typeof message.timeout === "number")
            object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
          else
            object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber(true) : message.timeout;
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          object.invalidationId = options.bytes === String ? $util.base64.encode(message.invalidationId, 0, message.invalidationId.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidationId) : message.invalidationId;
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (typeof message.invalidationNonce === "number")
            object.invalidationNonce = options.longs === String ? String(message.invalidationNonce) : message.invalidationNonce;
          else
            object.invalidationNonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidationNonce) : options.longs === Number ? new $util.LongBits(message.invalidationNonce.low >>> 0, message.invalidationNonce.high >>> 0).toNumber(true) : message.invalidationNonce;
        if (message.block != null && message.hasOwnProperty("block"))
          if (typeof message.block === "number")
            object.block = options.longs === String ? String(message.block) : message.block;
          else
            object.block = options.longs === String ? $util.Long.prototype.toString.call(message.block) : options.longs === Number ? new $util.LongBits(message.block.low >>> 0, message.block.high >>> 0).toNumber(true) : message.block;
        return object;
      };

      /**
       * Converts this OutgoingLogicCall to JSON.
       * @function toJSON
       * @memberof gravity.v1.OutgoingLogicCall
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OutgoingLogicCall.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OutgoingLogicCall;
    })();

    v1.BridgeValidator = (function() {

      /**
       * Properties of a BridgeValidator.
       * @memberof gravity.v1
       * @interface IBridgeValidator
       * @property {number|Long|null} [power] BridgeValidator power
       * @property {string|null} [ethereumAddress] BridgeValidator ethereumAddress
       */

      /**
       * Constructs a new BridgeValidator.
       * @memberof gravity.v1
       * @classdesc Represents a BridgeValidator.
       * @implements IBridgeValidator
       * @constructor
       * @param {gravity.v1.IBridgeValidator=} [properties] Properties to set
       */
      function BridgeValidator(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * BridgeValidator power.
       * @member {number|Long} power
       * @memberof gravity.v1.BridgeValidator
       * @instance
       */
      BridgeValidator.prototype.power = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * BridgeValidator ethereumAddress.
       * @member {string} ethereumAddress
       * @memberof gravity.v1.BridgeValidator
       * @instance
       */
      BridgeValidator.prototype.ethereumAddress = "";

      /**
       * Creates a new BridgeValidator instance using the specified properties.
       * @function create
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {gravity.v1.IBridgeValidator=} [properties] Properties to set
       * @returns {gravity.v1.BridgeValidator} BridgeValidator instance
       */
      BridgeValidator.create = function create(properties) {
        return new BridgeValidator(properties);
      };

      /**
       * Encodes the specified BridgeValidator message. Does not implicitly {@link gravity.v1.BridgeValidator.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {gravity.v1.IBridgeValidator} message BridgeValidator message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BridgeValidator.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.power != null && Object.hasOwnProperty.call(message, "power"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.power);
        if (message.ethereumAddress != null && Object.hasOwnProperty.call(message, "ethereumAddress"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.ethereumAddress);
        return writer;
      };

      /**
       * Encodes the specified BridgeValidator message, length delimited. Does not implicitly {@link gravity.v1.BridgeValidator.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {gravity.v1.IBridgeValidator} message BridgeValidator message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BridgeValidator.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BridgeValidator message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.BridgeValidator} BridgeValidator
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BridgeValidator.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.BridgeValidator();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.power = reader.uint64();
              break;
            case 2:
              message.ethereumAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BridgeValidator message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.BridgeValidator} BridgeValidator
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BridgeValidator.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BridgeValidator message.
       * @function verify
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BridgeValidator.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.power != null && message.hasOwnProperty("power"))
          if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
            return "power: integer|Long expected";
        if (message.ethereumAddress != null && message.hasOwnProperty("ethereumAddress"))
          if (!$util.isString(message.ethereumAddress))
            return "ethereumAddress: string expected";
        return null;
      };

      /**
       * Creates a BridgeValidator message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.BridgeValidator} BridgeValidator
       */
      BridgeValidator.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.BridgeValidator)
          return object;
        let message = new $root.gravity.v1.BridgeValidator();
        if (object.power != null)
          if ($util.Long)
            (message.power = $util.Long.fromValue(object.power)).unsigned = true;
          else if (typeof object.power === "string")
            message.power = parseInt(object.power, 10);
          else if (typeof object.power === "number")
            message.power = object.power;
          else if (typeof object.power === "object")
            message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber(true);
        if (object.ethereumAddress != null)
          message.ethereumAddress = String(object.ethereumAddress);
        return message;
      };

      /**
       * Creates a plain object from a BridgeValidator message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.BridgeValidator
       * @static
       * @param {gravity.v1.BridgeValidator} message BridgeValidator
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BridgeValidator.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.power = options.longs === String ? "0" : 0;
          object.ethereumAddress = "";
        }
        if (message.power != null && message.hasOwnProperty("power"))
          if (typeof message.power === "number")
            object.power = options.longs === String ? String(message.power) : message.power;
          else
            object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber(true) : message.power;
        if (message.ethereumAddress != null && message.hasOwnProperty("ethereumAddress"))
          object.ethereumAddress = message.ethereumAddress;
        return object;
      };

      /**
       * Converts this BridgeValidator to JSON.
       * @function toJSON
       * @memberof gravity.v1.BridgeValidator
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BridgeValidator.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BridgeValidator;
    })();

    v1.Valset = (function() {

      /**
       * Properties of a Valset.
       * @memberof gravity.v1
       * @interface IValset
       * @property {number|Long|null} [nonce] Valset nonce
       * @property {Array.<gravity.v1.IBridgeValidator>|null} [members] Valset members
       * @property {number|Long|null} [height] Valset height
       * @property {string|null} [rewardAmount] Valset rewardAmount
       * @property {string|null} [rewardToken] Valset rewardToken
       */

      /**
       * Constructs a new Valset.
       * @memberof gravity.v1
       * @classdesc Represents a Valset.
       * @implements IValset
       * @constructor
       * @param {gravity.v1.IValset=} [properties] Properties to set
       */
      function Valset(properties) {
        this.members = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Valset nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.Valset
       * @instance
       */
      Valset.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Valset members.
       * @member {Array.<gravity.v1.IBridgeValidator>} members
       * @memberof gravity.v1.Valset
       * @instance
       */
      Valset.prototype.members = $util.emptyArray;

      /**
       * Valset height.
       * @member {number|Long} height
       * @memberof gravity.v1.Valset
       * @instance
       */
      Valset.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Valset rewardAmount.
       * @member {string} rewardAmount
       * @memberof gravity.v1.Valset
       * @instance
       */
      Valset.prototype.rewardAmount = "";

      /**
       * Valset rewardToken.
       * @member {string} rewardToken
       * @memberof gravity.v1.Valset
       * @instance
       */
      Valset.prototype.rewardToken = "";

      /**
       * Creates a new Valset instance using the specified properties.
       * @function create
       * @memberof gravity.v1.Valset
       * @static
       * @param {gravity.v1.IValset=} [properties] Properties to set
       * @returns {gravity.v1.Valset} Valset instance
       */
      Valset.create = function create(properties) {
        return new Valset(properties);
      };

      /**
       * Encodes the specified Valset message. Does not implicitly {@link gravity.v1.Valset.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.Valset
       * @static
       * @param {gravity.v1.IValset} message Valset message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Valset.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        if (message.members != null && message.members.length)
          for (let i = 0; i < message.members.length; ++i)
            $root.gravity.v1.BridgeValidator.encode(message.members[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
          writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.height);
        if (message.rewardAmount != null && Object.hasOwnProperty.call(message, "rewardAmount"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.rewardAmount);
        if (message.rewardToken != null && Object.hasOwnProperty.call(message, "rewardToken"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.rewardToken);
        return writer;
      };

      /**
       * Encodes the specified Valset message, length delimited. Does not implicitly {@link gravity.v1.Valset.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.Valset
       * @static
       * @param {gravity.v1.IValset} message Valset message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Valset.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Valset message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.Valset
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.Valset} Valset
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Valset.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.Valset();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            case 2:
              if (!(message.members && message.members.length))
                message.members = [];
              message.members.push($root.gravity.v1.BridgeValidator.decode(reader, reader.uint32()));
              break;
            case 3:
              message.height = reader.uint64();
              break;
            case 4:
              message.rewardAmount = reader.string();
              break;
            case 5:
              message.rewardToken = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Valset message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.Valset
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.Valset} Valset
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Valset.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Valset message.
       * @function verify
       * @memberof gravity.v1.Valset
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Valset.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        if (message.members != null && message.hasOwnProperty("members")) {
          if (!Array.isArray(message.members))
            return "members: array expected";
          for (let i = 0; i < message.members.length; ++i) {
            let error = $root.gravity.v1.BridgeValidator.verify(message.members[i]);
            if (error)
              return "members." + error;
          }
        }
        if (message.height != null && message.hasOwnProperty("height"))
          if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
            return "height: integer|Long expected";
        if (message.rewardAmount != null && message.hasOwnProperty("rewardAmount"))
          if (!$util.isString(message.rewardAmount))
            return "rewardAmount: string expected";
        if (message.rewardToken != null && message.hasOwnProperty("rewardToken"))
          if (!$util.isString(message.rewardToken))
            return "rewardToken: string expected";
        return null;
      };

      /**
       * Creates a Valset message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.Valset
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.Valset} Valset
       */
      Valset.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.Valset)
          return object;
        let message = new $root.gravity.v1.Valset();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        if (object.members) {
          if (!Array.isArray(object.members))
            throw TypeError(".gravity.v1.Valset.members: array expected");
          message.members = [];
          for (let i = 0; i < object.members.length; ++i) {
            if (typeof object.members[i] !== "object")
              throw TypeError(".gravity.v1.Valset.members: object expected");
            message.members[i] = $root.gravity.v1.BridgeValidator.fromObject(object.members[i]);
          }
        }
        if (object.height != null)
          if ($util.Long)
            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
          else if (typeof object.height === "string")
            message.height = parseInt(object.height, 10);
          else if (typeof object.height === "number")
            message.height = object.height;
          else if (typeof object.height === "object")
            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
        if (object.rewardAmount != null)
          message.rewardAmount = String(object.rewardAmount);
        if (object.rewardToken != null)
          message.rewardToken = String(object.rewardToken);
        return message;
      };

      /**
       * Creates a plain object from a Valset message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.Valset
       * @static
       * @param {gravity.v1.Valset} message Valset
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Valset.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.members = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.height = options.longs === String ? "0" : 0;
          object.rewardAmount = "";
          object.rewardToken = "";
        }
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        if (message.members && message.members.length) {
          object.members = [];
          for (let j = 0; j < message.members.length; ++j)
            object.members[j] = $root.gravity.v1.BridgeValidator.toObject(message.members[j], options);
        }
        if (message.height != null && message.hasOwnProperty("height"))
          if (typeof message.height === "number")
            object.height = options.longs === String ? String(message.height) : message.height;
          else
            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
        if (message.rewardAmount != null && message.hasOwnProperty("rewardAmount"))
          object.rewardAmount = message.rewardAmount;
        if (message.rewardToken != null && message.hasOwnProperty("rewardToken"))
          object.rewardToken = message.rewardToken;
        return object;
      };

      /**
       * Converts this Valset to JSON.
       * @function toJSON
       * @memberof gravity.v1.Valset
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Valset.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Valset;
    })();

    v1.LastObservedEthereumBlockHeight = (function() {

      /**
       * Properties of a LastObservedEthereumBlockHeight.
       * @memberof gravity.v1
       * @interface ILastObservedEthereumBlockHeight
       * @property {number|Long|null} [cosmosBlockHeight] LastObservedEthereumBlockHeight cosmosBlockHeight
       * @property {number|Long|null} [ethereumBlockHeight] LastObservedEthereumBlockHeight ethereumBlockHeight
       */

      /**
       * Constructs a new LastObservedEthereumBlockHeight.
       * @memberof gravity.v1
       * @classdesc Represents a LastObservedEthereumBlockHeight.
       * @implements ILastObservedEthereumBlockHeight
       * @constructor
       * @param {gravity.v1.ILastObservedEthereumBlockHeight=} [properties] Properties to set
       */
      function LastObservedEthereumBlockHeight(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * LastObservedEthereumBlockHeight cosmosBlockHeight.
       * @member {number|Long} cosmosBlockHeight
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @instance
       */
      LastObservedEthereumBlockHeight.prototype.cosmosBlockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * LastObservedEthereumBlockHeight ethereumBlockHeight.
       * @member {number|Long} ethereumBlockHeight
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @instance
       */
      LastObservedEthereumBlockHeight.prototype.ethereumBlockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new LastObservedEthereumBlockHeight instance using the specified properties.
       * @function create
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {gravity.v1.ILastObservedEthereumBlockHeight=} [properties] Properties to set
       * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight instance
       */
      LastObservedEthereumBlockHeight.create = function create(properties) {
        return new LastObservedEthereumBlockHeight(properties);
      };

      /**
       * Encodes the specified LastObservedEthereumBlockHeight message. Does not implicitly {@link gravity.v1.LastObservedEthereumBlockHeight.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {gravity.v1.ILastObservedEthereumBlockHeight} message LastObservedEthereumBlockHeight message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LastObservedEthereumBlockHeight.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.cosmosBlockHeight != null && Object.hasOwnProperty.call(message, "cosmosBlockHeight"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.cosmosBlockHeight);
        if (message.ethereumBlockHeight != null && Object.hasOwnProperty.call(message, "ethereumBlockHeight"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ethereumBlockHeight);
        return writer;
      };

      /**
       * Encodes the specified LastObservedEthereumBlockHeight message, length delimited. Does not implicitly {@link gravity.v1.LastObservedEthereumBlockHeight.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {gravity.v1.ILastObservedEthereumBlockHeight} message LastObservedEthereumBlockHeight message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LastObservedEthereumBlockHeight.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a LastObservedEthereumBlockHeight message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LastObservedEthereumBlockHeight.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.LastObservedEthereumBlockHeight();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cosmosBlockHeight = reader.uint64();
              break;
            case 2:
              message.ethereumBlockHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a LastObservedEthereumBlockHeight message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LastObservedEthereumBlockHeight.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a LastObservedEthereumBlockHeight message.
       * @function verify
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      LastObservedEthereumBlockHeight.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.cosmosBlockHeight != null && message.hasOwnProperty("cosmosBlockHeight"))
          if (!$util.isInteger(message.cosmosBlockHeight) && !(message.cosmosBlockHeight && $util.isInteger(message.cosmosBlockHeight.low) && $util.isInteger(message.cosmosBlockHeight.high)))
            return "cosmosBlockHeight: integer|Long expected";
        if (message.ethereumBlockHeight != null && message.hasOwnProperty("ethereumBlockHeight"))
          if (!$util.isInteger(message.ethereumBlockHeight) && !(message.ethereumBlockHeight && $util.isInteger(message.ethereumBlockHeight.low) && $util.isInteger(message.ethereumBlockHeight.high)))
            return "ethereumBlockHeight: integer|Long expected";
        return null;
      };

      /**
       * Creates a LastObservedEthereumBlockHeight message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight
       */
      LastObservedEthereumBlockHeight.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.LastObservedEthereumBlockHeight)
          return object;
        let message = new $root.gravity.v1.LastObservedEthereumBlockHeight();
        if (object.cosmosBlockHeight != null)
          if ($util.Long)
            (message.cosmosBlockHeight = $util.Long.fromValue(object.cosmosBlockHeight)).unsigned = true;
          else if (typeof object.cosmosBlockHeight === "string")
            message.cosmosBlockHeight = parseInt(object.cosmosBlockHeight, 10);
          else if (typeof object.cosmosBlockHeight === "number")
            message.cosmosBlockHeight = object.cosmosBlockHeight;
          else if (typeof object.cosmosBlockHeight === "object")
            message.cosmosBlockHeight = new $util.LongBits(object.cosmosBlockHeight.low >>> 0, object.cosmosBlockHeight.high >>> 0).toNumber(true);
        if (object.ethereumBlockHeight != null)
          if ($util.Long)
            (message.ethereumBlockHeight = $util.Long.fromValue(object.ethereumBlockHeight)).unsigned = true;
          else if (typeof object.ethereumBlockHeight === "string")
            message.ethereumBlockHeight = parseInt(object.ethereumBlockHeight, 10);
          else if (typeof object.ethereumBlockHeight === "number")
            message.ethereumBlockHeight = object.ethereumBlockHeight;
          else if (typeof object.ethereumBlockHeight === "object")
            message.ethereumBlockHeight = new $util.LongBits(object.ethereumBlockHeight.low >>> 0, object.ethereumBlockHeight.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a LastObservedEthereumBlockHeight message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @static
       * @param {gravity.v1.LastObservedEthereumBlockHeight} message LastObservedEthereumBlockHeight
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      LastObservedEthereumBlockHeight.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.cosmosBlockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.cosmosBlockHeight = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.ethereumBlockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.ethereumBlockHeight = options.longs === String ? "0" : 0;
        }
        if (message.cosmosBlockHeight != null && message.hasOwnProperty("cosmosBlockHeight"))
          if (typeof message.cosmosBlockHeight === "number")
            object.cosmosBlockHeight = options.longs === String ? String(message.cosmosBlockHeight) : message.cosmosBlockHeight;
          else
            object.cosmosBlockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.cosmosBlockHeight) : options.longs === Number ? new $util.LongBits(message.cosmosBlockHeight.low >>> 0, message.cosmosBlockHeight.high >>> 0).toNumber(true) : message.cosmosBlockHeight;
        if (message.ethereumBlockHeight != null && message.hasOwnProperty("ethereumBlockHeight"))
          if (typeof message.ethereumBlockHeight === "number")
            object.ethereumBlockHeight = options.longs === String ? String(message.ethereumBlockHeight) : message.ethereumBlockHeight;
          else
            object.ethereumBlockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.ethereumBlockHeight) : options.longs === Number ? new $util.LongBits(message.ethereumBlockHeight.low >>> 0, message.ethereumBlockHeight.high >>> 0).toNumber(true) : message.ethereumBlockHeight;
        return object;
      };

      /**
       * Converts this LastObservedEthereumBlockHeight to JSON.
       * @function toJSON
       * @memberof gravity.v1.LastObservedEthereumBlockHeight
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      LastObservedEthereumBlockHeight.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return LastObservedEthereumBlockHeight;
    })();

    v1.ERC20ToDenom = (function() {

      /**
       * Properties of a ERC20ToDenom.
       * @memberof gravity.v1
       * @interface IERC20ToDenom
       * @property {string|null} [erc20] ERC20ToDenom erc20
       * @property {string|null} [denom] ERC20ToDenom denom
       */

      /**
       * Constructs a new ERC20ToDenom.
       * @memberof gravity.v1
       * @classdesc Represents a ERC20ToDenom.
       * @implements IERC20ToDenom
       * @constructor
       * @param {gravity.v1.IERC20ToDenom=} [properties] Properties to set
       */
      function ERC20ToDenom(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * ERC20ToDenom erc20.
       * @member {string} erc20
       * @memberof gravity.v1.ERC20ToDenom
       * @instance
       */
      ERC20ToDenom.prototype.erc20 = "";

      /**
       * ERC20ToDenom denom.
       * @member {string} denom
       * @memberof gravity.v1.ERC20ToDenom
       * @instance
       */
      ERC20ToDenom.prototype.denom = "";

      /**
       * Creates a new ERC20ToDenom instance using the specified properties.
       * @function create
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {gravity.v1.IERC20ToDenom=} [properties] Properties to set
       * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom instance
       */
      ERC20ToDenom.create = function create(properties) {
        return new ERC20ToDenom(properties);
      };

      /**
       * Encodes the specified ERC20ToDenom message. Does not implicitly {@link gravity.v1.ERC20ToDenom.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {gravity.v1.IERC20ToDenom} message ERC20ToDenom message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ERC20ToDenom.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.erc20 != null && Object.hasOwnProperty.call(message, "erc20"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.erc20);
        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified ERC20ToDenom message, length delimited. Does not implicitly {@link gravity.v1.ERC20ToDenom.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {gravity.v1.IERC20ToDenom} message ERC20ToDenom message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ERC20ToDenom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ERC20ToDenom message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ERC20ToDenom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.ERC20ToDenom();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.erc20 = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ERC20ToDenom message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ERC20ToDenom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ERC20ToDenom message.
       * @function verify
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ERC20ToDenom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.erc20 != null && message.hasOwnProperty("erc20"))
          if (!$util.isString(message.erc20))
            return "erc20: string expected";
        if (message.denom != null && message.hasOwnProperty("denom"))
          if (!$util.isString(message.denom))
            return "denom: string expected";
        return null;
      };

      /**
       * Creates a ERC20ToDenom message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom
       */
      ERC20ToDenom.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.ERC20ToDenom)
          return object;
        let message = new $root.gravity.v1.ERC20ToDenom();
        if (object.erc20 != null)
          message.erc20 = String(object.erc20);
        if (object.denom != null)
          message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a ERC20ToDenom message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.ERC20ToDenom
       * @static
       * @param {gravity.v1.ERC20ToDenom} message ERC20ToDenom
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ERC20ToDenom.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.erc20 = "";
          object.denom = "";
        }
        if (message.erc20 != null && message.hasOwnProperty("erc20"))
          object.erc20 = message.erc20;
        if (message.denom != null && message.hasOwnProperty("denom"))
          object.denom = message.denom;
        return object;
      };

      /**
       * Converts this ERC20ToDenom to JSON.
       * @function toJSON
       * @memberof gravity.v1.ERC20ToDenom
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ERC20ToDenom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ERC20ToDenom;
    })();

    v1.UnhaltBridgeProposal = (function() {

      /**
       * Properties of an UnhaltBridgeProposal.
       * @memberof gravity.v1
       * @interface IUnhaltBridgeProposal
       * @property {string|null} [title] UnhaltBridgeProposal title
       * @property {string|null} [description] UnhaltBridgeProposal description
       * @property {number|Long|null} [targetNonce] UnhaltBridgeProposal targetNonce
       */

      /**
       * Constructs a new UnhaltBridgeProposal.
       * @memberof gravity.v1
       * @classdesc Represents an UnhaltBridgeProposal.
       * @implements IUnhaltBridgeProposal
       * @constructor
       * @param {gravity.v1.IUnhaltBridgeProposal=} [properties] Properties to set
       */
      function UnhaltBridgeProposal(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * UnhaltBridgeProposal title.
       * @member {string} title
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @instance
       */
      UnhaltBridgeProposal.prototype.title = "";

      /**
       * UnhaltBridgeProposal description.
       * @member {string} description
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @instance
       */
      UnhaltBridgeProposal.prototype.description = "";

      /**
       * UnhaltBridgeProposal targetNonce.
       * @member {number|Long} targetNonce
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @instance
       */
      UnhaltBridgeProposal.prototype.targetNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new UnhaltBridgeProposal instance using the specified properties.
       * @function create
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {gravity.v1.IUnhaltBridgeProposal=} [properties] Properties to set
       * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal instance
       */
      UnhaltBridgeProposal.create = function create(properties) {
        return new UnhaltBridgeProposal(properties);
      };

      /**
       * Encodes the specified UnhaltBridgeProposal message. Does not implicitly {@link gravity.v1.UnhaltBridgeProposal.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {gravity.v1.IUnhaltBridgeProposal} message UnhaltBridgeProposal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UnhaltBridgeProposal.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        if (message.targetNonce != null && Object.hasOwnProperty.call(message, "targetNonce"))
          writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.targetNonce);
        return writer;
      };

      /**
       * Encodes the specified UnhaltBridgeProposal message, length delimited. Does not implicitly {@link gravity.v1.UnhaltBridgeProposal.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {gravity.v1.IUnhaltBridgeProposal} message UnhaltBridgeProposal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UnhaltBridgeProposal.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an UnhaltBridgeProposal message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UnhaltBridgeProposal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.UnhaltBridgeProposal();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 4:
              message.targetNonce = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an UnhaltBridgeProposal message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UnhaltBridgeProposal.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an UnhaltBridgeProposal message.
       * @function verify
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      UnhaltBridgeProposal.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
          if (!$util.isString(message.title))
            return "title: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
          if (!$util.isString(message.description))
            return "description: string expected";
        if (message.targetNonce != null && message.hasOwnProperty("targetNonce"))
          if (!$util.isInteger(message.targetNonce) && !(message.targetNonce && $util.isInteger(message.targetNonce.low) && $util.isInteger(message.targetNonce.high)))
            return "targetNonce: integer|Long expected";
        return null;
      };

      /**
       * Creates an UnhaltBridgeProposal message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal
       */
      UnhaltBridgeProposal.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.UnhaltBridgeProposal)
          return object;
        let message = new $root.gravity.v1.UnhaltBridgeProposal();
        if (object.title != null)
          message.title = String(object.title);
        if (object.description != null)
          message.description = String(object.description);
        if (object.targetNonce != null)
          if ($util.Long)
            (message.targetNonce = $util.Long.fromValue(object.targetNonce)).unsigned = true;
          else if (typeof object.targetNonce === "string")
            message.targetNonce = parseInt(object.targetNonce, 10);
          else if (typeof object.targetNonce === "number")
            message.targetNonce = object.targetNonce;
          else if (typeof object.targetNonce === "object")
            message.targetNonce = new $util.LongBits(object.targetNonce.low >>> 0, object.targetNonce.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from an UnhaltBridgeProposal message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @static
       * @param {gravity.v1.UnhaltBridgeProposal} message UnhaltBridgeProposal
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      UnhaltBridgeProposal.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.title = "";
          object.description = "";
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.targetNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.targetNonce = options.longs === String ? "0" : 0;
        }
        if (message.title != null && message.hasOwnProperty("title"))
          object.title = message.title;
        if (message.description != null && message.hasOwnProperty("description"))
          object.description = message.description;
        if (message.targetNonce != null && message.hasOwnProperty("targetNonce"))
          if (typeof message.targetNonce === "number")
            object.targetNonce = options.longs === String ? String(message.targetNonce) : message.targetNonce;
          else
            object.targetNonce = options.longs === String ? $util.Long.prototype.toString.call(message.targetNonce) : options.longs === Number ? new $util.LongBits(message.targetNonce.low >>> 0, message.targetNonce.high >>> 0).toNumber(true) : message.targetNonce;
        return object;
      };

      /**
       * Converts this UnhaltBridgeProposal to JSON.
       * @function toJSON
       * @memberof gravity.v1.UnhaltBridgeProposal
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      UnhaltBridgeProposal.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return UnhaltBridgeProposal;
    })();

    v1.AirdropProposal = (function() {

      /**
       * Properties of an AirdropProposal.
       * @memberof gravity.v1
       * @interface IAirdropProposal
       * @property {string|null} [title] AirdropProposal title
       * @property {string|null} [description] AirdropProposal description
       * @property {Array.<string>|null} [recipients] AirdropProposal recipients
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] AirdropProposal amount
       */

      /**
       * Constructs a new AirdropProposal.
       * @memberof gravity.v1
       * @classdesc Represents an AirdropProposal.
       * @implements IAirdropProposal
       * @constructor
       * @param {gravity.v1.IAirdropProposal=} [properties] Properties to set
       */
      function AirdropProposal(properties) {
        this.recipients = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * AirdropProposal title.
       * @member {string} title
       * @memberof gravity.v1.AirdropProposal
       * @instance
       */
      AirdropProposal.prototype.title = "";

      /**
       * AirdropProposal description.
       * @member {string} description
       * @memberof gravity.v1.AirdropProposal
       * @instance
       */
      AirdropProposal.prototype.description = "";

      /**
       * AirdropProposal recipients.
       * @member {Array.<string>} recipients
       * @memberof gravity.v1.AirdropProposal
       * @instance
       */
      AirdropProposal.prototype.recipients = $util.emptyArray;

      /**
       * AirdropProposal amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof gravity.v1.AirdropProposal
       * @instance
       */
      AirdropProposal.prototype.amount = null;

      /**
       * Creates a new AirdropProposal instance using the specified properties.
       * @function create
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {gravity.v1.IAirdropProposal=} [properties] Properties to set
       * @returns {gravity.v1.AirdropProposal} AirdropProposal instance
       */
      AirdropProposal.create = function create(properties) {
        return new AirdropProposal(properties);
      };

      /**
       * Encodes the specified AirdropProposal message. Does not implicitly {@link gravity.v1.AirdropProposal.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {gravity.v1.IAirdropProposal} message AirdropProposal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      AirdropProposal.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        if (message.recipients != null && message.recipients.length)
          for (let i = 0; i < message.recipients.length; ++i)
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipients[i]);
        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified AirdropProposal message, length delimited. Does not implicitly {@link gravity.v1.AirdropProposal.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {gravity.v1.IAirdropProposal} message AirdropProposal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      AirdropProposal.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an AirdropProposal message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.AirdropProposal} AirdropProposal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      AirdropProposal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.AirdropProposal();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              if (!(message.recipients && message.recipients.length))
                message.recipients = [];
              message.recipients.push(reader.string());
              break;
            case 4:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an AirdropProposal message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.AirdropProposal} AirdropProposal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      AirdropProposal.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an AirdropProposal message.
       * @function verify
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      AirdropProposal.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
          if (!$util.isString(message.title))
            return "title: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
          if (!$util.isString(message.description))
            return "description: string expected";
        if (message.recipients != null && message.hasOwnProperty("recipients")) {
          if (!Array.isArray(message.recipients))
            return "recipients: array expected";
          for (let i = 0; i < message.recipients.length; ++i)
            if (!$util.isString(message.recipients[i]))
              return "recipients: string[] expected";
        }
        if (message.amount != null && message.hasOwnProperty("amount")) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error)
            return "amount." + error;
        }
        return null;
      };

      /**
       * Creates an AirdropProposal message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.AirdropProposal} AirdropProposal
       */
      AirdropProposal.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.AirdropProposal)
          return object;
        let message = new $root.gravity.v1.AirdropProposal();
        if (object.title != null)
          message.title = String(object.title);
        if (object.description != null)
          message.description = String(object.description);
        if (object.recipients) {
          if (!Array.isArray(object.recipients))
            throw TypeError(".gravity.v1.AirdropProposal.recipients: array expected");
          message.recipients = [];
          for (let i = 0; i < object.recipients.length; ++i)
            message.recipients[i] = String(object.recipients[i]);
        }
        if (object.amount != null) {
          if (typeof object.amount !== "object")
            throw TypeError(".gravity.v1.AirdropProposal.amount: object expected");
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from an AirdropProposal message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.AirdropProposal
       * @static
       * @param {gravity.v1.AirdropProposal} message AirdropProposal
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      AirdropProposal.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.recipients = [];
        if (options.defaults) {
          object.title = "";
          object.description = "";
          object.amount = null;
        }
        if (message.title != null && message.hasOwnProperty("title"))
          object.title = message.title;
        if (message.description != null && message.hasOwnProperty("description"))
          object.description = message.description;
        if (message.recipients && message.recipients.length) {
          object.recipients = [];
          for (let j = 0; j < message.recipients.length; ++j)
            object.recipients[j] = message.recipients[j];
        }
        if (message.amount != null && message.hasOwnProperty("amount"))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this AirdropProposal to JSON.
       * @function toJSON
       * @memberof gravity.v1.AirdropProposal
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      AirdropProposal.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return AirdropProposal;
    })();

    v1.IBCMetadataProposal = (function() {

      /**
       * Properties of a IBCMetadataProposal.
       * @memberof gravity.v1
       * @interface IIBCMetadataProposal
       * @property {string|null} [title] IBCMetadataProposal title
       * @property {string|null} [description] IBCMetadataProposal description
       * @property {cosmos.bank.v1beta1.IMetadata|null} [metadata] IBCMetadataProposal metadata
       * @property {string|null} [ibcDenom] IBCMetadataProposal ibcDenom
       */

      /**
       * Constructs a new IBCMetadataProposal.
       * @memberof gravity.v1
       * @classdesc Represents a IBCMetadataProposal.
       * @implements IIBCMetadataProposal
       * @constructor
       * @param {gravity.v1.IIBCMetadataProposal=} [properties] Properties to set
       */
      function IBCMetadataProposal(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * IBCMetadataProposal title.
       * @member {string} title
       * @memberof gravity.v1.IBCMetadataProposal
       * @instance
       */
      IBCMetadataProposal.prototype.title = "";

      /**
       * IBCMetadataProposal description.
       * @member {string} description
       * @memberof gravity.v1.IBCMetadataProposal
       * @instance
       */
      IBCMetadataProposal.prototype.description = "";

      /**
       * IBCMetadataProposal metadata.
       * @member {cosmos.bank.v1beta1.IMetadata|null|undefined} metadata
       * @memberof gravity.v1.IBCMetadataProposal
       * @instance
       */
      IBCMetadataProposal.prototype.metadata = null;

      /**
       * IBCMetadataProposal ibcDenom.
       * @member {string} ibcDenom
       * @memberof gravity.v1.IBCMetadataProposal
       * @instance
       */
      IBCMetadataProposal.prototype.ibcDenom = "";

      /**
       * Creates a new IBCMetadataProposal instance using the specified properties.
       * @function create
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {gravity.v1.IIBCMetadataProposal=} [properties] Properties to set
       * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal instance
       */
      IBCMetadataProposal.create = function create(properties) {
        return new IBCMetadataProposal(properties);
      };

      /**
       * Encodes the specified IBCMetadataProposal message. Does not implicitly {@link gravity.v1.IBCMetadataProposal.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {gravity.v1.IIBCMetadataProposal} message IBCMetadataProposal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IBCMetadataProposal.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
          $root.cosmos.bank.v1beta1.Metadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.ibcDenom != null && Object.hasOwnProperty.call(message, "ibcDenom"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.ibcDenom);
        return writer;
      };

      /**
       * Encodes the specified IBCMetadataProposal message, length delimited. Does not implicitly {@link gravity.v1.IBCMetadataProposal.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {gravity.v1.IIBCMetadataProposal} message IBCMetadataProposal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IBCMetadataProposal.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a IBCMetadataProposal message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IBCMetadataProposal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.IBCMetadataProposal();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.metadata = $root.cosmos.bank.v1beta1.Metadata.decode(reader, reader.uint32());
              break;
            case 4:
              message.ibcDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a IBCMetadataProposal message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IBCMetadataProposal.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a IBCMetadataProposal message.
       * @function verify
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      IBCMetadataProposal.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
          if (!$util.isString(message.title))
            return "title: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
          if (!$util.isString(message.description))
            return "description: string expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
          let error = $root.cosmos.bank.v1beta1.Metadata.verify(message.metadata);
          if (error)
            return "metadata." + error;
        }
        if (message.ibcDenom != null && message.hasOwnProperty("ibcDenom"))
          if (!$util.isString(message.ibcDenom))
            return "ibcDenom: string expected";
        return null;
      };

      /**
       * Creates a IBCMetadataProposal message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal
       */
      IBCMetadataProposal.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.IBCMetadataProposal)
          return object;
        let message = new $root.gravity.v1.IBCMetadataProposal();
        if (object.title != null)
          message.title = String(object.title);
        if (object.description != null)
          message.description = String(object.description);
        if (object.metadata != null) {
          if (typeof object.metadata !== "object")
            throw TypeError(".gravity.v1.IBCMetadataProposal.metadata: object expected");
          message.metadata = $root.cosmos.bank.v1beta1.Metadata.fromObject(object.metadata);
        }
        if (object.ibcDenom != null)
          message.ibcDenom = String(object.ibcDenom);
        return message;
      };

      /**
       * Creates a plain object from a IBCMetadataProposal message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.IBCMetadataProposal
       * @static
       * @param {gravity.v1.IBCMetadataProposal} message IBCMetadataProposal
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      IBCMetadataProposal.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.title = "";
          object.description = "";
          object.metadata = null;
          object.ibcDenom = "";
        }
        if (message.title != null && message.hasOwnProperty("title"))
          object.title = message.title;
        if (message.description != null && message.hasOwnProperty("description"))
          object.description = message.description;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
          object.metadata = $root.cosmos.bank.v1beta1.Metadata.toObject(message.metadata, options);
        if (message.ibcDenom != null && message.hasOwnProperty("ibcDenom"))
          object.ibcDenom = message.ibcDenom;
        return object;
      };

      /**
       * Converts this IBCMetadataProposal to JSON.
       * @function toJSON
       * @memberof gravity.v1.IBCMetadataProposal
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      IBCMetadataProposal.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return IBCMetadataProposal;
    })();

    v1.Query = (function() {

      /**
       * Constructs a new Query service.
       * @memberof gravity.v1
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Creates new Query service using the specified rpc implementation.
       * @function create
       * @memberof gravity.v1.Query
       * @static
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       * @returns {Query} RPC service. Useful where requests and/or responses are streamed.
       */
      Query.create = function create(rpcImpl, requestDelimited, responseDelimited) {
        return new this(rpcImpl, requestDelimited, responseDelimited);
      };

      /**
       * Callback as used by {@link gravity.v1.Query#params}.
       * @memberof gravity.v1.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {gravity.v1.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.params = function params(request, callback) {
        return this.rpcCall(params, $root.gravity.v1.QueryParamsRequest, $root.gravity.v1.QueryParamsResponse, request, callback);
      }, "name", { value: "Params" });

      /**
       * Calls Params.
       * @function params
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<gravity.v1.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#currentValset}.
       * @memberof gravity.v1.Query
       * @typedef CurrentValsetCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryCurrentValsetResponse} [response] QueryCurrentValsetResponse
       */

      /**
       * Calls CurrentValset.
       * @function currentValset
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryCurrentValsetRequest} request QueryCurrentValsetRequest message or plain object
       * @param {gravity.v1.Query.CurrentValsetCallback} callback Node-style callback called with the error, if any, and QueryCurrentValsetResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.currentValset = function currentValset(request, callback) {
        return this.rpcCall(currentValset, $root.gravity.v1.QueryCurrentValsetRequest, $root.gravity.v1.QueryCurrentValsetResponse, request, callback);
      }, "name", { value: "CurrentValset" });

      /**
       * Calls CurrentValset.
       * @function currentValset
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryCurrentValsetRequest} request QueryCurrentValsetRequest message or plain object
       * @returns {Promise<gravity.v1.QueryCurrentValsetResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#valsetRequest}.
       * @memberof gravity.v1.Query
       * @typedef ValsetRequestCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryValsetRequestResponse} [response] QueryValsetRequestResponse
       */

      /**
       * Calls ValsetRequest.
       * @function valsetRequest
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryValsetRequestRequest} request QueryValsetRequestRequest message or plain object
       * @param {gravity.v1.Query.ValsetRequestCallback} callback Node-style callback called with the error, if any, and QueryValsetRequestResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.valsetRequest = function valsetRequest(request, callback) {
        return this.rpcCall(valsetRequest, $root.gravity.v1.QueryValsetRequestRequest, $root.gravity.v1.QueryValsetRequestResponse, request, callback);
      }, "name", { value: "ValsetRequest" });

      /**
       * Calls ValsetRequest.
       * @function valsetRequest
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryValsetRequestRequest} request QueryValsetRequestRequest message or plain object
       * @returns {Promise<gravity.v1.QueryValsetRequestResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#valsetConfirm}.
       * @memberof gravity.v1.Query
       * @typedef ValsetConfirmCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryValsetConfirmResponse} [response] QueryValsetConfirmResponse
       */

      /**
       * Calls ValsetConfirm.
       * @function valsetConfirm
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryValsetConfirmRequest} request QueryValsetConfirmRequest message or plain object
       * @param {gravity.v1.Query.ValsetConfirmCallback} callback Node-style callback called with the error, if any, and QueryValsetConfirmResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.valsetConfirm = function valsetConfirm(request, callback) {
        return this.rpcCall(valsetConfirm, $root.gravity.v1.QueryValsetConfirmRequest, $root.gravity.v1.QueryValsetConfirmResponse, request, callback);
      }, "name", { value: "ValsetConfirm" });

      /**
       * Calls ValsetConfirm.
       * @function valsetConfirm
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryValsetConfirmRequest} request QueryValsetConfirmRequest message or plain object
       * @returns {Promise<gravity.v1.QueryValsetConfirmResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#valsetConfirmsByNonce}.
       * @memberof gravity.v1.Query
       * @typedef ValsetConfirmsByNonceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryValsetConfirmsByNonceResponse} [response] QueryValsetConfirmsByNonceResponse
       */

      /**
       * Calls ValsetConfirmsByNonce.
       * @function valsetConfirmsByNonce
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} request QueryValsetConfirmsByNonceRequest message or plain object
       * @param {gravity.v1.Query.ValsetConfirmsByNonceCallback} callback Node-style callback called with the error, if any, and QueryValsetConfirmsByNonceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.valsetConfirmsByNonce = function valsetConfirmsByNonce(request, callback) {
        return this.rpcCall(valsetConfirmsByNonce, $root.gravity.v1.QueryValsetConfirmsByNonceRequest, $root.gravity.v1.QueryValsetConfirmsByNonceResponse, request, callback);
      }, "name", { value: "ValsetConfirmsByNonce" });

      /**
       * Calls ValsetConfirmsByNonce.
       * @function valsetConfirmsByNonce
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} request QueryValsetConfirmsByNonceRequest message or plain object
       * @returns {Promise<gravity.v1.QueryValsetConfirmsByNonceResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#lastValsetRequests}.
       * @memberof gravity.v1.Query
       * @typedef LastValsetRequestsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryLastValsetRequestsResponse} [response] QueryLastValsetRequestsResponse
       */

      /**
       * Calls LastValsetRequests.
       * @function lastValsetRequests
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastValsetRequestsRequest} request QueryLastValsetRequestsRequest message or plain object
       * @param {gravity.v1.Query.LastValsetRequestsCallback} callback Node-style callback called with the error, if any, and QueryLastValsetRequestsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.lastValsetRequests = function lastValsetRequests(request, callback) {
        return this.rpcCall(lastValsetRequests, $root.gravity.v1.QueryLastValsetRequestsRequest, $root.gravity.v1.QueryLastValsetRequestsResponse, request, callback);
      }, "name", { value: "LastValsetRequests" });

      /**
       * Calls LastValsetRequests.
       * @function lastValsetRequests
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastValsetRequestsRequest} request QueryLastValsetRequestsRequest message or plain object
       * @returns {Promise<gravity.v1.QueryLastValsetRequestsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#lastPendingValsetRequestByAddr}.
       * @memberof gravity.v1.Query
       * @typedef LastPendingValsetRequestByAddrCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} [response] QueryLastPendingValsetRequestByAddrResponse
       */

      /**
       * Calls LastPendingValsetRequestByAddr.
       * @function lastPendingValsetRequestByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} request QueryLastPendingValsetRequestByAddrRequest message or plain object
       * @param {gravity.v1.Query.LastPendingValsetRequestByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastPendingValsetRequestByAddrResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.lastPendingValsetRequestByAddr = function lastPendingValsetRequestByAddr(request, callback) {
        return this.rpcCall(lastPendingValsetRequestByAddr, $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest, $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse, request, callback);
      }, "name", { value: "LastPendingValsetRequestByAddr" });

      /**
       * Calls LastPendingValsetRequestByAddr.
       * @function lastPendingValsetRequestByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} request QueryLastPendingValsetRequestByAddrRequest message or plain object
       * @returns {Promise<gravity.v1.QueryLastPendingValsetRequestByAddrResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#lastPendingBatchRequestByAddr}.
       * @memberof gravity.v1.Query
       * @typedef LastPendingBatchRequestByAddrCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} [response] QueryLastPendingBatchRequestByAddrResponse
       */

      /**
       * Calls LastPendingBatchRequestByAddr.
       * @function lastPendingBatchRequestByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} request QueryLastPendingBatchRequestByAddrRequest message or plain object
       * @param {gravity.v1.Query.LastPendingBatchRequestByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastPendingBatchRequestByAddrResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.lastPendingBatchRequestByAddr = function lastPendingBatchRequestByAddr(request, callback) {
        return this.rpcCall(lastPendingBatchRequestByAddr, $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest, $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse, request, callback);
      }, "name", { value: "LastPendingBatchRequestByAddr" });

      /**
       * Calls LastPendingBatchRequestByAddr.
       * @function lastPendingBatchRequestByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} request QueryLastPendingBatchRequestByAddrRequest message or plain object
       * @returns {Promise<gravity.v1.QueryLastPendingBatchRequestByAddrResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#lastPendingLogicCallByAddr}.
       * @memberof gravity.v1.Query
       * @typedef LastPendingLogicCallByAddrCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryLastPendingLogicCallByAddrResponse} [response] QueryLastPendingLogicCallByAddrResponse
       */

      /**
       * Calls LastPendingLogicCallByAddr.
       * @function lastPendingLogicCallByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} request QueryLastPendingLogicCallByAddrRequest message or plain object
       * @param {gravity.v1.Query.LastPendingLogicCallByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastPendingLogicCallByAddrResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.lastPendingLogicCallByAddr = function lastPendingLogicCallByAddr(request, callback) {
        return this.rpcCall(lastPendingLogicCallByAddr, $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest, $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse, request, callback);
      }, "name", { value: "LastPendingLogicCallByAddr" });

      /**
       * Calls LastPendingLogicCallByAddr.
       * @function lastPendingLogicCallByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} request QueryLastPendingLogicCallByAddrRequest message or plain object
       * @returns {Promise<gravity.v1.QueryLastPendingLogicCallByAddrResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#lastEventNonceByAddr}.
       * @memberof gravity.v1.Query
       * @typedef LastEventNonceByAddrCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryLastEventNonceByAddrResponse} [response] QueryLastEventNonceByAddrResponse
       */

      /**
       * Calls LastEventNonceByAddr.
       * @function lastEventNonceByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} request QueryLastEventNonceByAddrRequest message or plain object
       * @param {gravity.v1.Query.LastEventNonceByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastEventNonceByAddrResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.lastEventNonceByAddr = function lastEventNonceByAddr(request, callback) {
        return this.rpcCall(lastEventNonceByAddr, $root.gravity.v1.QueryLastEventNonceByAddrRequest, $root.gravity.v1.QueryLastEventNonceByAddrResponse, request, callback);
      }, "name", { value: "LastEventNonceByAddr" });

      /**
       * Calls LastEventNonceByAddr.
       * @function lastEventNonceByAddr
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} request QueryLastEventNonceByAddrRequest message or plain object
       * @returns {Promise<gravity.v1.QueryLastEventNonceByAddrResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#batchFees}.
       * @memberof gravity.v1.Query
       * @typedef BatchFeesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryBatchFeeResponse} [response] QueryBatchFeeResponse
       */

      /**
       * Calls BatchFees.
       * @function batchFees
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryBatchFeeRequest} request QueryBatchFeeRequest message or plain object
       * @param {gravity.v1.Query.BatchFeesCallback} callback Node-style callback called with the error, if any, and QueryBatchFeeResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.batchFees = function batchFees(request, callback) {
        return this.rpcCall(batchFees, $root.gravity.v1.QueryBatchFeeRequest, $root.gravity.v1.QueryBatchFeeResponse, request, callback);
      }, "name", { value: "BatchFees" });

      /**
       * Calls BatchFees.
       * @function batchFees
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryBatchFeeRequest} request QueryBatchFeeRequest message or plain object
       * @returns {Promise<gravity.v1.QueryBatchFeeResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#outgoingTxBatches}.
       * @memberof gravity.v1.Query
       * @typedef OutgoingTxBatchesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryOutgoingTxBatchesResponse} [response] QueryOutgoingTxBatchesResponse
       */

      /**
       * Calls OutgoingTxBatches.
       * @function outgoingTxBatches
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} request QueryOutgoingTxBatchesRequest message or plain object
       * @param {gravity.v1.Query.OutgoingTxBatchesCallback} callback Node-style callback called with the error, if any, and QueryOutgoingTxBatchesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.outgoingTxBatches = function outgoingTxBatches(request, callback) {
        return this.rpcCall(outgoingTxBatches, $root.gravity.v1.QueryOutgoingTxBatchesRequest, $root.gravity.v1.QueryOutgoingTxBatchesResponse, request, callback);
      }, "name", { value: "OutgoingTxBatches" });

      /**
       * Calls OutgoingTxBatches.
       * @function outgoingTxBatches
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} request QueryOutgoingTxBatchesRequest message or plain object
       * @returns {Promise<gravity.v1.QueryOutgoingTxBatchesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#outgoingLogicCalls}.
       * @memberof gravity.v1.Query
       * @typedef OutgoingLogicCallsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryOutgoingLogicCallsResponse} [response] QueryOutgoingLogicCallsResponse
       */

      /**
       * Calls OutgoingLogicCalls.
       * @function outgoingLogicCalls
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} request QueryOutgoingLogicCallsRequest message or plain object
       * @param {gravity.v1.Query.OutgoingLogicCallsCallback} callback Node-style callback called with the error, if any, and QueryOutgoingLogicCallsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.outgoingLogicCalls = function outgoingLogicCalls(request, callback) {
        return this.rpcCall(outgoingLogicCalls, $root.gravity.v1.QueryOutgoingLogicCallsRequest, $root.gravity.v1.QueryOutgoingLogicCallsResponse, request, callback);
      }, "name", { value: "OutgoingLogicCalls" });

      /**
       * Calls OutgoingLogicCalls.
       * @function outgoingLogicCalls
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} request QueryOutgoingLogicCallsRequest message or plain object
       * @returns {Promise<gravity.v1.QueryOutgoingLogicCallsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#batchRequestByNonce}.
       * @memberof gravity.v1.Query
       * @typedef BatchRequestByNonceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryBatchRequestByNonceResponse} [response] QueryBatchRequestByNonceResponse
       */

      /**
       * Calls BatchRequestByNonce.
       * @function batchRequestByNonce
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryBatchRequestByNonceRequest} request QueryBatchRequestByNonceRequest message or plain object
       * @param {gravity.v1.Query.BatchRequestByNonceCallback} callback Node-style callback called with the error, if any, and QueryBatchRequestByNonceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.batchRequestByNonce = function batchRequestByNonce(request, callback) {
        return this.rpcCall(batchRequestByNonce, $root.gravity.v1.QueryBatchRequestByNonceRequest, $root.gravity.v1.QueryBatchRequestByNonceResponse, request, callback);
      }, "name", { value: "BatchRequestByNonce" });

      /**
       * Calls BatchRequestByNonce.
       * @function batchRequestByNonce
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryBatchRequestByNonceRequest} request QueryBatchRequestByNonceRequest message or plain object
       * @returns {Promise<gravity.v1.QueryBatchRequestByNonceResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#batchConfirms}.
       * @memberof gravity.v1.Query
       * @typedef BatchConfirmsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryBatchConfirmsResponse} [response] QueryBatchConfirmsResponse
       */

      /**
       * Calls BatchConfirms.
       * @function batchConfirms
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryBatchConfirmsRequest} request QueryBatchConfirmsRequest message or plain object
       * @param {gravity.v1.Query.BatchConfirmsCallback} callback Node-style callback called with the error, if any, and QueryBatchConfirmsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.batchConfirms = function batchConfirms(request, callback) {
        return this.rpcCall(batchConfirms, $root.gravity.v1.QueryBatchConfirmsRequest, $root.gravity.v1.QueryBatchConfirmsResponse, request, callback);
      }, "name", { value: "BatchConfirms" });

      /**
       * Calls BatchConfirms.
       * @function batchConfirms
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryBatchConfirmsRequest} request QueryBatchConfirmsRequest message or plain object
       * @returns {Promise<gravity.v1.QueryBatchConfirmsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#logicConfirms}.
       * @memberof gravity.v1.Query
       * @typedef LogicConfirmsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryLogicConfirmsResponse} [response] QueryLogicConfirmsResponse
       */

      /**
       * Calls LogicConfirms.
       * @function logicConfirms
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLogicConfirmsRequest} request QueryLogicConfirmsRequest message or plain object
       * @param {gravity.v1.Query.LogicConfirmsCallback} callback Node-style callback called with the error, if any, and QueryLogicConfirmsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.logicConfirms = function logicConfirms(request, callback) {
        return this.rpcCall(logicConfirms, $root.gravity.v1.QueryLogicConfirmsRequest, $root.gravity.v1.QueryLogicConfirmsResponse, request, callback);
      }, "name", { value: "LogicConfirms" });

      /**
       * Calls LogicConfirms.
       * @function logicConfirms
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryLogicConfirmsRequest} request QueryLogicConfirmsRequest message or plain object
       * @returns {Promise<gravity.v1.QueryLogicConfirmsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#eRC20ToDenom}.
       * @memberof gravity.v1.Query
       * @typedef ERC20ToDenomCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryERC20ToDenomResponse} [response] QueryERC20ToDenomResponse
       */

      /**
       * Calls ERC20ToDenom.
       * @function eRC20ToDenom
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryERC20ToDenomRequest} request QueryERC20ToDenomRequest message or plain object
       * @param {gravity.v1.Query.ERC20ToDenomCallback} callback Node-style callback called with the error, if any, and QueryERC20ToDenomResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.eRC20ToDenom = function eRC20ToDenom(request, callback) {
        return this.rpcCall(eRC20ToDenom, $root.gravity.v1.QueryERC20ToDenomRequest, $root.gravity.v1.QueryERC20ToDenomResponse, request, callback);
      }, "name", { value: "ERC20ToDenom" });

      /**
       * Calls ERC20ToDenom.
       * @function eRC20ToDenom
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryERC20ToDenomRequest} request QueryERC20ToDenomRequest message or plain object
       * @returns {Promise<gravity.v1.QueryERC20ToDenomResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#denomToERC20}.
       * @memberof gravity.v1.Query
       * @typedef DenomToERC20Callback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryDenomToERC20Response} [response] QueryDenomToERC20Response
       */

      /**
       * Calls DenomToERC20.
       * @function denomToERC20
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDenomToERC20Request} request QueryDenomToERC20Request message or plain object
       * @param {gravity.v1.Query.DenomToERC20Callback} callback Node-style callback called with the error, if any, and QueryDenomToERC20Response
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.denomToERC20 = function denomToERC20(request, callback) {
        return this.rpcCall(denomToERC20, $root.gravity.v1.QueryDenomToERC20Request, $root.gravity.v1.QueryDenomToERC20Response, request, callback);
      }, "name", { value: "DenomToERC20" });

      /**
       * Calls DenomToERC20.
       * @function denomToERC20
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDenomToERC20Request} request QueryDenomToERC20Request message or plain object
       * @returns {Promise<gravity.v1.QueryDenomToERC20Response>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#getAttestations}.
       * @memberof gravity.v1.Query
       * @typedef GetAttestationsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryAttestationsResponse} [response] QueryAttestationsResponse
       */

      /**
       * Calls GetAttestations.
       * @function getAttestations
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryAttestationsRequest} request QueryAttestationsRequest message or plain object
       * @param {gravity.v1.Query.GetAttestationsCallback} callback Node-style callback called with the error, if any, and QueryAttestationsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.getAttestations = function getAttestations(request, callback) {
        return this.rpcCall(getAttestations, $root.gravity.v1.QueryAttestationsRequest, $root.gravity.v1.QueryAttestationsResponse, request, callback);
      }, "name", { value: "GetAttestations" });

      /**
       * Calls GetAttestations.
       * @function getAttestations
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryAttestationsRequest} request QueryAttestationsRequest message or plain object
       * @returns {Promise<gravity.v1.QueryAttestationsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#getDelegateKeyByValidator}.
       * @memberof gravity.v1.Query
       * @typedef GetDelegateKeyByValidatorCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} [response] QueryDelegateKeysByValidatorAddressResponse
       */

      /**
       * Calls GetDelegateKeyByValidator.
       * @function getDelegateKeyByValidator
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} request QueryDelegateKeysByValidatorAddress message or plain object
       * @param {gravity.v1.Query.GetDelegateKeyByValidatorCallback} callback Node-style callback called with the error, if any, and QueryDelegateKeysByValidatorAddressResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.getDelegateKeyByValidator = function getDelegateKeyByValidator(request, callback) {
        return this.rpcCall(getDelegateKeyByValidator, $root.gravity.v1.QueryDelegateKeysByValidatorAddress, $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse, request, callback);
      }, "name", { value: "GetDelegateKeyByValidator" });

      /**
       * Calls GetDelegateKeyByValidator.
       * @function getDelegateKeyByValidator
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} request QueryDelegateKeysByValidatorAddress message or plain object
       * @returns {Promise<gravity.v1.QueryDelegateKeysByValidatorAddressResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#getDelegateKeyByEth}.
       * @memberof gravity.v1.Query
       * @typedef GetDelegateKeyByEthCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryDelegateKeysByEthAddressResponse} [response] QueryDelegateKeysByEthAddressResponse
       */

      /**
       * Calls GetDelegateKeyByEth.
       * @function getDelegateKeyByEth
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDelegateKeysByEthAddress} request QueryDelegateKeysByEthAddress message or plain object
       * @param {gravity.v1.Query.GetDelegateKeyByEthCallback} callback Node-style callback called with the error, if any, and QueryDelegateKeysByEthAddressResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.getDelegateKeyByEth = function getDelegateKeyByEth(request, callback) {
        return this.rpcCall(getDelegateKeyByEth, $root.gravity.v1.QueryDelegateKeysByEthAddress, $root.gravity.v1.QueryDelegateKeysByEthAddressResponse, request, callback);
      }, "name", { value: "GetDelegateKeyByEth" });

      /**
       * Calls GetDelegateKeyByEth.
       * @function getDelegateKeyByEth
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDelegateKeysByEthAddress} request QueryDelegateKeysByEthAddress message or plain object
       * @returns {Promise<gravity.v1.QueryDelegateKeysByEthAddressResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#getDelegateKeyByOrchestrator}.
       * @memberof gravity.v1.Query
       * @typedef GetDelegateKeyByOrchestratorCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} [response] QueryDelegateKeysByOrchestratorAddressResponse
       */

      /**
       * Calls GetDelegateKeyByOrchestrator.
       * @function getDelegateKeyByOrchestrator
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} request QueryDelegateKeysByOrchestratorAddress message or plain object
       * @param {gravity.v1.Query.GetDelegateKeyByOrchestratorCallback} callback Node-style callback called with the error, if any, and QueryDelegateKeysByOrchestratorAddressResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.getDelegateKeyByOrchestrator = function getDelegateKeyByOrchestrator(request, callback) {
        return this.rpcCall(getDelegateKeyByOrchestrator, $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress, $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse, request, callback);
      }, "name", { value: "GetDelegateKeyByOrchestrator" });

      /**
       * Calls GetDelegateKeyByOrchestrator.
       * @function getDelegateKeyByOrchestrator
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} request QueryDelegateKeysByOrchestratorAddress message or plain object
       * @returns {Promise<gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Query#getPendingSendToEth}.
       * @memberof gravity.v1.Query
       * @typedef GetPendingSendToEthCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.QueryPendingSendToEthResponse} [response] QueryPendingSendToEthResponse
       */

      /**
       * Calls GetPendingSendToEth.
       * @function getPendingSendToEth
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryPendingSendToEth} request QueryPendingSendToEth message or plain object
       * @param {gravity.v1.Query.GetPendingSendToEthCallback} callback Node-style callback called with the error, if any, and QueryPendingSendToEthResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Query.prototype.getPendingSendToEth = function getPendingSendToEth(request, callback) {
        return this.rpcCall(getPendingSendToEth, $root.gravity.v1.QueryPendingSendToEth, $root.gravity.v1.QueryPendingSendToEthResponse, request, callback);
      }, "name", { value: "GetPendingSendToEth" });

      /**
       * Calls GetPendingSendToEth.
       * @function getPendingSendToEth
       * @memberof gravity.v1.Query
       * @instance
       * @param {gravity.v1.IQueryPendingSendToEth} request QueryPendingSendToEth message or plain object
       * @returns {Promise<gravity.v1.QueryPendingSendToEthResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    v1.QueryParamsRequest = (function() {

      /**
       * Properties of a QueryParamsRequest.
       * @memberof gravity.v1
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {gravity.v1.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new QueryParamsRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {gravity.v1.IQueryParamsRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest instance
       */
      QueryParamsRequest.create = function create(properties) {
        return new QueryParamsRequest(properties);
      };

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link gravity.v1.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {gravity.v1.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {gravity.v1.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryParamsRequest)
          return object;
        return new $root.gravity.v1.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryParamsRequest
       * @static
       * @param {gravity.v1.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    v1.QueryParamsResponse = (function() {

      /**
       * Properties of a QueryParamsResponse.
       * @memberof gravity.v1
       * @interface IQueryParamsResponse
       * @property {gravity.v1.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {gravity.v1.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {gravity.v1.IParams|null|undefined} params
       * @memberof gravity.v1.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Creates a new QueryParamsResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {gravity.v1.IQueryParamsResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse instance
       */
      QueryParamsResponse.create = function create(properties) {
        return new QueryParamsResponse(properties);
      };

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link gravity.v1.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {gravity.v1.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, "params"))
          $root.gravity.v1.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {gravity.v1.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.gravity.v1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.params != null && message.hasOwnProperty("params")) {
          let error = $root.gravity.v1.Params.verify(message.params);
          if (error)
            return "params." + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryParamsResponse)
          return object;
        let message = new $root.gravity.v1.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== "object")
            throw TypeError(".gravity.v1.QueryParamsResponse.params: object expected");
          message.params = $root.gravity.v1.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryParamsResponse
       * @static
       * @param {gravity.v1.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.params = null;
        if (message.params != null && message.hasOwnProperty("params"))
          object.params = $root.gravity.v1.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    v1.QueryCurrentValsetRequest = (function() {

      /**
       * Properties of a QueryCurrentValsetRequest.
       * @memberof gravity.v1
       * @interface IQueryCurrentValsetRequest
       */

      /**
       * Constructs a new QueryCurrentValsetRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryCurrentValsetRequest.
       * @implements IQueryCurrentValsetRequest
       * @constructor
       * @param {gravity.v1.IQueryCurrentValsetRequest=} [properties] Properties to set
       */
      function QueryCurrentValsetRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new QueryCurrentValsetRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {gravity.v1.IQueryCurrentValsetRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest instance
       */
      QueryCurrentValsetRequest.create = function create(properties) {
        return new QueryCurrentValsetRequest(properties);
      };

      /**
       * Encodes the specified QueryCurrentValsetRequest message. Does not implicitly {@link gravity.v1.QueryCurrentValsetRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {gravity.v1.IQueryCurrentValsetRequest} message QueryCurrentValsetRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentValsetRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryCurrentValsetRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryCurrentValsetRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {gravity.v1.IQueryCurrentValsetRequest} message QueryCurrentValsetRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentValsetRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryCurrentValsetRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentValsetRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryCurrentValsetRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryCurrentValsetRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentValsetRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryCurrentValsetRequest message.
       * @function verify
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryCurrentValsetRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a QueryCurrentValsetRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest
       */
      QueryCurrentValsetRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryCurrentValsetRequest)
          return object;
        return new $root.gravity.v1.QueryCurrentValsetRequest();
      };

      /**
       * Creates a plain object from a QueryCurrentValsetRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @static
       * @param {gravity.v1.QueryCurrentValsetRequest} message QueryCurrentValsetRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryCurrentValsetRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryCurrentValsetRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryCurrentValsetRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryCurrentValsetRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryCurrentValsetRequest;
    })();

    v1.QueryCurrentValsetResponse = (function() {

      /**
       * Properties of a QueryCurrentValsetResponse.
       * @memberof gravity.v1
       * @interface IQueryCurrentValsetResponse
       * @property {gravity.v1.IValset|null} [valset] QueryCurrentValsetResponse valset
       */

      /**
       * Constructs a new QueryCurrentValsetResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryCurrentValsetResponse.
       * @implements IQueryCurrentValsetResponse
       * @constructor
       * @param {gravity.v1.IQueryCurrentValsetResponse=} [properties] Properties to set
       */
      function QueryCurrentValsetResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryCurrentValsetResponse valset.
       * @member {gravity.v1.IValset|null|undefined} valset
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @instance
       */
      QueryCurrentValsetResponse.prototype.valset = null;

      /**
       * Creates a new QueryCurrentValsetResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {gravity.v1.IQueryCurrentValsetResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse instance
       */
      QueryCurrentValsetResponse.create = function create(properties) {
        return new QueryCurrentValsetResponse(properties);
      };

      /**
       * Encodes the specified QueryCurrentValsetResponse message. Does not implicitly {@link gravity.v1.QueryCurrentValsetResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {gravity.v1.IQueryCurrentValsetResponse} message QueryCurrentValsetResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentValsetResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.valset != null && Object.hasOwnProperty.call(message, "valset"))
          $root.gravity.v1.Valset.encode(message.valset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryCurrentValsetResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryCurrentValsetResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {gravity.v1.IQueryCurrentValsetResponse} message QueryCurrentValsetResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentValsetResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryCurrentValsetResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentValsetResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryCurrentValsetResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valset = $root.gravity.v1.Valset.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryCurrentValsetResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentValsetResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryCurrentValsetResponse message.
       * @function verify
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryCurrentValsetResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.valset != null && message.hasOwnProperty("valset")) {
          let error = $root.gravity.v1.Valset.verify(message.valset);
          if (error)
            return "valset." + error;
        }
        return null;
      };

      /**
       * Creates a QueryCurrentValsetResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse
       */
      QueryCurrentValsetResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryCurrentValsetResponse)
          return object;
        let message = new $root.gravity.v1.QueryCurrentValsetResponse();
        if (object.valset != null) {
          if (typeof object.valset !== "object")
            throw TypeError(".gravity.v1.QueryCurrentValsetResponse.valset: object expected");
          message.valset = $root.gravity.v1.Valset.fromObject(object.valset);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryCurrentValsetResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @static
       * @param {gravity.v1.QueryCurrentValsetResponse} message QueryCurrentValsetResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryCurrentValsetResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.valset = null;
        if (message.valset != null && message.hasOwnProperty("valset"))
          object.valset = $root.gravity.v1.Valset.toObject(message.valset, options);
        return object;
      };

      /**
       * Converts this QueryCurrentValsetResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryCurrentValsetResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryCurrentValsetResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryCurrentValsetResponse;
    })();

    v1.QueryValsetRequestRequest = (function() {

      /**
       * Properties of a QueryValsetRequestRequest.
       * @memberof gravity.v1
       * @interface IQueryValsetRequestRequest
       * @property {number|Long|null} [nonce] QueryValsetRequestRequest nonce
       */

      /**
       * Constructs a new QueryValsetRequestRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryValsetRequestRequest.
       * @implements IQueryValsetRequestRequest
       * @constructor
       * @param {gravity.v1.IQueryValsetRequestRequest=} [properties] Properties to set
       */
      function QueryValsetRequestRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryValsetRequestRequest nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @instance
       */
      QueryValsetRequestRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new QueryValsetRequestRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {gravity.v1.IQueryValsetRequestRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest instance
       */
      QueryValsetRequestRequest.create = function create(properties) {
        return new QueryValsetRequestRequest(properties);
      };

      /**
       * Encodes the specified QueryValsetRequestRequest message. Does not implicitly {@link gravity.v1.QueryValsetRequestRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {gravity.v1.IQueryValsetRequestRequest} message QueryValsetRequestRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetRequestRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        return writer;
      };

      /**
       * Encodes the specified QueryValsetRequestRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetRequestRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {gravity.v1.IQueryValsetRequestRequest} message QueryValsetRequestRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetRequestRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryValsetRequestRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetRequestRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetRequestRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryValsetRequestRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetRequestRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryValsetRequestRequest message.
       * @function verify
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryValsetRequestRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        return null;
      };

      /**
       * Creates a QueryValsetRequestRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest
       */
      QueryValsetRequestRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryValsetRequestRequest)
          return object;
        let message = new $root.gravity.v1.QueryValsetRequestRequest();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryValsetRequestRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @static
       * @param {gravity.v1.QueryValsetRequestRequest} message QueryValsetRequestRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryValsetRequestRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        return object;
      };

      /**
       * Converts this QueryValsetRequestRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryValsetRequestRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryValsetRequestRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryValsetRequestRequest;
    })();

    v1.QueryValsetRequestResponse = (function() {

      /**
       * Properties of a QueryValsetRequestResponse.
       * @memberof gravity.v1
       * @interface IQueryValsetRequestResponse
       * @property {gravity.v1.IValset|null} [valset] QueryValsetRequestResponse valset
       */

      /**
       * Constructs a new QueryValsetRequestResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryValsetRequestResponse.
       * @implements IQueryValsetRequestResponse
       * @constructor
       * @param {gravity.v1.IQueryValsetRequestResponse=} [properties] Properties to set
       */
      function QueryValsetRequestResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryValsetRequestResponse valset.
       * @member {gravity.v1.IValset|null|undefined} valset
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @instance
       */
      QueryValsetRequestResponse.prototype.valset = null;

      /**
       * Creates a new QueryValsetRequestResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {gravity.v1.IQueryValsetRequestResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse instance
       */
      QueryValsetRequestResponse.create = function create(properties) {
        return new QueryValsetRequestResponse(properties);
      };

      /**
       * Encodes the specified QueryValsetRequestResponse message. Does not implicitly {@link gravity.v1.QueryValsetRequestResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {gravity.v1.IQueryValsetRequestResponse} message QueryValsetRequestResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetRequestResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.valset != null && Object.hasOwnProperty.call(message, "valset"))
          $root.gravity.v1.Valset.encode(message.valset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryValsetRequestResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetRequestResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {gravity.v1.IQueryValsetRequestResponse} message QueryValsetRequestResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetRequestResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryValsetRequestResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetRequestResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetRequestResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valset = $root.gravity.v1.Valset.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryValsetRequestResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetRequestResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryValsetRequestResponse message.
       * @function verify
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryValsetRequestResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.valset != null && message.hasOwnProperty("valset")) {
          let error = $root.gravity.v1.Valset.verify(message.valset);
          if (error)
            return "valset." + error;
        }
        return null;
      };

      /**
       * Creates a QueryValsetRequestResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse
       */
      QueryValsetRequestResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryValsetRequestResponse)
          return object;
        let message = new $root.gravity.v1.QueryValsetRequestResponse();
        if (object.valset != null) {
          if (typeof object.valset !== "object")
            throw TypeError(".gravity.v1.QueryValsetRequestResponse.valset: object expected");
          message.valset = $root.gravity.v1.Valset.fromObject(object.valset);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryValsetRequestResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @static
       * @param {gravity.v1.QueryValsetRequestResponse} message QueryValsetRequestResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryValsetRequestResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.valset = null;
        if (message.valset != null && message.hasOwnProperty("valset"))
          object.valset = $root.gravity.v1.Valset.toObject(message.valset, options);
        return object;
      };

      /**
       * Converts this QueryValsetRequestResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryValsetRequestResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryValsetRequestResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryValsetRequestResponse;
    })();

    v1.QueryValsetConfirmRequest = (function() {

      /**
       * Properties of a QueryValsetConfirmRequest.
       * @memberof gravity.v1
       * @interface IQueryValsetConfirmRequest
       * @property {number|Long|null} [nonce] QueryValsetConfirmRequest nonce
       * @property {string|null} [address] QueryValsetConfirmRequest address
       */

      /**
       * Constructs a new QueryValsetConfirmRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryValsetConfirmRequest.
       * @implements IQueryValsetConfirmRequest
       * @constructor
       * @param {gravity.v1.IQueryValsetConfirmRequest=} [properties] Properties to set
       */
      function QueryValsetConfirmRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryValsetConfirmRequest nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @instance
       */
      QueryValsetConfirmRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * QueryValsetConfirmRequest address.
       * @member {string} address
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @instance
       */
      QueryValsetConfirmRequest.prototype.address = "";

      /**
       * Creates a new QueryValsetConfirmRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {gravity.v1.IQueryValsetConfirmRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest instance
       */
      QueryValsetConfirmRequest.create = function create(properties) {
        return new QueryValsetConfirmRequest(properties);
      };

      /**
       * Encodes the specified QueryValsetConfirmRequest message. Does not implicitly {@link gravity.v1.QueryValsetConfirmRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {gravity.v1.IQueryValsetConfirmRequest} message QueryValsetConfirmRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryValsetConfirmRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {gravity.v1.IQueryValsetConfirmRequest} message QueryValsetConfirmRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryValsetConfirmRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryValsetConfirmRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryValsetConfirmRequest message.
       * @function verify
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryValsetConfirmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        if (message.address != null && message.hasOwnProperty("address"))
          if (!$util.isString(message.address))
            return "address: string expected";
        return null;
      };

      /**
       * Creates a QueryValsetConfirmRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest
       */
      QueryValsetConfirmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryValsetConfirmRequest)
          return object;
        let message = new $root.gravity.v1.QueryValsetConfirmRequest();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        if (object.address != null)
          message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryValsetConfirmRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @static
       * @param {gravity.v1.QueryValsetConfirmRequest} message QueryValsetConfirmRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryValsetConfirmRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
          object.address = "";
        }
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        if (message.address != null && message.hasOwnProperty("address"))
          object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryValsetConfirmRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryValsetConfirmRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryValsetConfirmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryValsetConfirmRequest;
    })();

    v1.QueryValsetConfirmResponse = (function() {

      /**
       * Properties of a QueryValsetConfirmResponse.
       * @memberof gravity.v1
       * @interface IQueryValsetConfirmResponse
       * @property {gravity.v1.IMsgValsetConfirm|null} [confirm] QueryValsetConfirmResponse confirm
       */

      /**
       * Constructs a new QueryValsetConfirmResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryValsetConfirmResponse.
       * @implements IQueryValsetConfirmResponse
       * @constructor
       * @param {gravity.v1.IQueryValsetConfirmResponse=} [properties] Properties to set
       */
      function QueryValsetConfirmResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryValsetConfirmResponse confirm.
       * @member {gravity.v1.IMsgValsetConfirm|null|undefined} confirm
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @instance
       */
      QueryValsetConfirmResponse.prototype.confirm = null;

      /**
       * Creates a new QueryValsetConfirmResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {gravity.v1.IQueryValsetConfirmResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse instance
       */
      QueryValsetConfirmResponse.create = function create(properties) {
        return new QueryValsetConfirmResponse(properties);
      };

      /**
       * Encodes the specified QueryValsetConfirmResponse message. Does not implicitly {@link gravity.v1.QueryValsetConfirmResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {gravity.v1.IQueryValsetConfirmResponse} message QueryValsetConfirmResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.confirm != null && Object.hasOwnProperty.call(message, "confirm"))
          $root.gravity.v1.MsgValsetConfirm.encode(message.confirm, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryValsetConfirmResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {gravity.v1.IQueryValsetConfirmResponse} message QueryValsetConfirmResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryValsetConfirmResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.confirm = $root.gravity.v1.MsgValsetConfirm.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryValsetConfirmResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryValsetConfirmResponse message.
       * @function verify
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryValsetConfirmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.confirm != null && message.hasOwnProperty("confirm")) {
          let error = $root.gravity.v1.MsgValsetConfirm.verify(message.confirm);
          if (error)
            return "confirm." + error;
        }
        return null;
      };

      /**
       * Creates a QueryValsetConfirmResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse
       */
      QueryValsetConfirmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryValsetConfirmResponse)
          return object;
        let message = new $root.gravity.v1.QueryValsetConfirmResponse();
        if (object.confirm != null) {
          if (typeof object.confirm !== "object")
            throw TypeError(".gravity.v1.QueryValsetConfirmResponse.confirm: object expected");
          message.confirm = $root.gravity.v1.MsgValsetConfirm.fromObject(object.confirm);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryValsetConfirmResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @static
       * @param {gravity.v1.QueryValsetConfirmResponse} message QueryValsetConfirmResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryValsetConfirmResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.confirm = null;
        if (message.confirm != null && message.hasOwnProperty("confirm"))
          object.confirm = $root.gravity.v1.MsgValsetConfirm.toObject(message.confirm, options);
        return object;
      };

      /**
       * Converts this QueryValsetConfirmResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryValsetConfirmResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryValsetConfirmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryValsetConfirmResponse;
    })();

    v1.QueryValsetConfirmsByNonceRequest = (function() {

      /**
       * Properties of a QueryValsetConfirmsByNonceRequest.
       * @memberof gravity.v1
       * @interface IQueryValsetConfirmsByNonceRequest
       * @property {number|Long|null} [nonce] QueryValsetConfirmsByNonceRequest nonce
       */

      /**
       * Constructs a new QueryValsetConfirmsByNonceRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryValsetConfirmsByNonceRequest.
       * @implements IQueryValsetConfirmsByNonceRequest
       * @constructor
       * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest=} [properties] Properties to set
       */
      function QueryValsetConfirmsByNonceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryValsetConfirmsByNonceRequest nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @instance
       */
      QueryValsetConfirmsByNonceRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new QueryValsetConfirmsByNonceRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest instance
       */
      QueryValsetConfirmsByNonceRequest.create = function create(properties) {
        return new QueryValsetConfirmsByNonceRequest(properties);
      };

      /**
       * Encodes the specified QueryValsetConfirmsByNonceRequest message. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} message QueryValsetConfirmsByNonceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmsByNonceRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        return writer;
      };

      /**
       * Encodes the specified QueryValsetConfirmsByNonceRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} message QueryValsetConfirmsByNonceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmsByNonceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryValsetConfirmsByNonceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmsByNonceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmsByNonceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryValsetConfirmsByNonceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmsByNonceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryValsetConfirmsByNonceRequest message.
       * @function verify
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryValsetConfirmsByNonceRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        return null;
      };

      /**
       * Creates a QueryValsetConfirmsByNonceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest
       */
      QueryValsetConfirmsByNonceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryValsetConfirmsByNonceRequest)
          return object;
        let message = new $root.gravity.v1.QueryValsetConfirmsByNonceRequest();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryValsetConfirmsByNonceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @static
       * @param {gravity.v1.QueryValsetConfirmsByNonceRequest} message QueryValsetConfirmsByNonceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryValsetConfirmsByNonceRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        return object;
      };

      /**
       * Converts this QueryValsetConfirmsByNonceRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryValsetConfirmsByNonceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryValsetConfirmsByNonceRequest;
    })();

    v1.QueryValsetConfirmsByNonceResponse = (function() {

      /**
       * Properties of a QueryValsetConfirmsByNonceResponse.
       * @memberof gravity.v1
       * @interface IQueryValsetConfirmsByNonceResponse
       * @property {Array.<gravity.v1.IMsgValsetConfirm>|null} [confirms] QueryValsetConfirmsByNonceResponse confirms
       */

      /**
       * Constructs a new QueryValsetConfirmsByNonceResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryValsetConfirmsByNonceResponse.
       * @implements IQueryValsetConfirmsByNonceResponse
       * @constructor
       * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse=} [properties] Properties to set
       */
      function QueryValsetConfirmsByNonceResponse(properties) {
        this.confirms = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryValsetConfirmsByNonceResponse confirms.
       * @member {Array.<gravity.v1.IMsgValsetConfirm>} confirms
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @instance
       */
      QueryValsetConfirmsByNonceResponse.prototype.confirms = $util.emptyArray;

      /**
       * Creates a new QueryValsetConfirmsByNonceResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse instance
       */
      QueryValsetConfirmsByNonceResponse.create = function create(properties) {
        return new QueryValsetConfirmsByNonceResponse(properties);
      };

      /**
       * Encodes the specified QueryValsetConfirmsByNonceResponse message. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse} message QueryValsetConfirmsByNonceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmsByNonceResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.confirms != null && message.confirms.length)
          for (let i = 0; i < message.confirms.length; ++i)
            $root.gravity.v1.MsgValsetConfirm.encode(message.confirms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryValsetConfirmsByNonceResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse} message QueryValsetConfirmsByNonceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryValsetConfirmsByNonceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryValsetConfirmsByNonceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmsByNonceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmsByNonceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.confirms && message.confirms.length))
                message.confirms = [];
              message.confirms.push($root.gravity.v1.MsgValsetConfirm.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryValsetConfirmsByNonceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryValsetConfirmsByNonceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryValsetConfirmsByNonceResponse message.
       * @function verify
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryValsetConfirmsByNonceResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.confirms != null && message.hasOwnProperty("confirms")) {
          if (!Array.isArray(message.confirms))
            return "confirms: array expected";
          for (let i = 0; i < message.confirms.length; ++i) {
            let error = $root.gravity.v1.MsgValsetConfirm.verify(message.confirms[i]);
            if (error)
              return "confirms." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryValsetConfirmsByNonceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse
       */
      QueryValsetConfirmsByNonceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryValsetConfirmsByNonceResponse)
          return object;
        let message = new $root.gravity.v1.QueryValsetConfirmsByNonceResponse();
        if (object.confirms) {
          if (!Array.isArray(object.confirms))
            throw TypeError(".gravity.v1.QueryValsetConfirmsByNonceResponse.confirms: array expected");
          message.confirms = [];
          for (let i = 0; i < object.confirms.length; ++i) {
            if (typeof object.confirms[i] !== "object")
              throw TypeError(".gravity.v1.QueryValsetConfirmsByNonceResponse.confirms: object expected");
            message.confirms[i] = $root.gravity.v1.MsgValsetConfirm.fromObject(object.confirms[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryValsetConfirmsByNonceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @static
       * @param {gravity.v1.QueryValsetConfirmsByNonceResponse} message QueryValsetConfirmsByNonceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryValsetConfirmsByNonceResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.confirms = [];
        if (message.confirms && message.confirms.length) {
          object.confirms = [];
          for (let j = 0; j < message.confirms.length; ++j)
            object.confirms[j] = $root.gravity.v1.MsgValsetConfirm.toObject(message.confirms[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryValsetConfirmsByNonceResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryValsetConfirmsByNonceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryValsetConfirmsByNonceResponse;
    })();

    v1.QueryLastValsetRequestsRequest = (function() {

      /**
       * Properties of a QueryLastValsetRequestsRequest.
       * @memberof gravity.v1
       * @interface IQueryLastValsetRequestsRequest
       */

      /**
       * Constructs a new QueryLastValsetRequestsRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastValsetRequestsRequest.
       * @implements IQueryLastValsetRequestsRequest
       * @constructor
       * @param {gravity.v1.IQueryLastValsetRequestsRequest=} [properties] Properties to set
       */
      function QueryLastValsetRequestsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new QueryLastValsetRequestsRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {gravity.v1.IQueryLastValsetRequestsRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest instance
       */
      QueryLastValsetRequestsRequest.create = function create(properties) {
        return new QueryLastValsetRequestsRequest(properties);
      };

      /**
       * Encodes the specified QueryLastValsetRequestsRequest message. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {gravity.v1.IQueryLastValsetRequestsRequest} message QueryLastValsetRequestsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastValsetRequestsRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryLastValsetRequestsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {gravity.v1.IQueryLastValsetRequestsRequest} message QueryLastValsetRequestsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastValsetRequestsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastValsetRequestsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastValsetRequestsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastValsetRequestsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastValsetRequestsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastValsetRequestsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastValsetRequestsRequest message.
       * @function verify
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastValsetRequestsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a QueryLastValsetRequestsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest
       */
      QueryLastValsetRequestsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastValsetRequestsRequest)
          return object;
        return new $root.gravity.v1.QueryLastValsetRequestsRequest();
      };

      /**
       * Creates a plain object from a QueryLastValsetRequestsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @static
       * @param {gravity.v1.QueryLastValsetRequestsRequest} message QueryLastValsetRequestsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastValsetRequestsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryLastValsetRequestsRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastValsetRequestsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastValsetRequestsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastValsetRequestsRequest;
    })();

    v1.QueryLastValsetRequestsResponse = (function() {

      /**
       * Properties of a QueryLastValsetRequestsResponse.
       * @memberof gravity.v1
       * @interface IQueryLastValsetRequestsResponse
       * @property {Array.<gravity.v1.IValset>|null} [valsets] QueryLastValsetRequestsResponse valsets
       */

      /**
       * Constructs a new QueryLastValsetRequestsResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastValsetRequestsResponse.
       * @implements IQueryLastValsetRequestsResponse
       * @constructor
       * @param {gravity.v1.IQueryLastValsetRequestsResponse=} [properties] Properties to set
       */
      function QueryLastValsetRequestsResponse(properties) {
        this.valsets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastValsetRequestsResponse valsets.
       * @member {Array.<gravity.v1.IValset>} valsets
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @instance
       */
      QueryLastValsetRequestsResponse.prototype.valsets = $util.emptyArray;

      /**
       * Creates a new QueryLastValsetRequestsResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {gravity.v1.IQueryLastValsetRequestsResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse instance
       */
      QueryLastValsetRequestsResponse.create = function create(properties) {
        return new QueryLastValsetRequestsResponse(properties);
      };

      /**
       * Encodes the specified QueryLastValsetRequestsResponse message. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {gravity.v1.IQueryLastValsetRequestsResponse} message QueryLastValsetRequestsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastValsetRequestsResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.valsets != null && message.valsets.length)
          for (let i = 0; i < message.valsets.length; ++i)
            $root.gravity.v1.Valset.encode(message.valsets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLastValsetRequestsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {gravity.v1.IQueryLastValsetRequestsResponse} message QueryLastValsetRequestsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastValsetRequestsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastValsetRequestsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastValsetRequestsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastValsetRequestsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.valsets && message.valsets.length))
                message.valsets = [];
              message.valsets.push($root.gravity.v1.Valset.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastValsetRequestsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastValsetRequestsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastValsetRequestsResponse message.
       * @function verify
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastValsetRequestsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.valsets != null && message.hasOwnProperty("valsets")) {
          if (!Array.isArray(message.valsets))
            return "valsets: array expected";
          for (let i = 0; i < message.valsets.length; ++i) {
            let error = $root.gravity.v1.Valset.verify(message.valsets[i]);
            if (error)
              return "valsets." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryLastValsetRequestsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse
       */
      QueryLastValsetRequestsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastValsetRequestsResponse)
          return object;
        let message = new $root.gravity.v1.QueryLastValsetRequestsResponse();
        if (object.valsets) {
          if (!Array.isArray(object.valsets))
            throw TypeError(".gravity.v1.QueryLastValsetRequestsResponse.valsets: array expected");
          message.valsets = [];
          for (let i = 0; i < object.valsets.length; ++i) {
            if (typeof object.valsets[i] !== "object")
              throw TypeError(".gravity.v1.QueryLastValsetRequestsResponse.valsets: object expected");
            message.valsets[i] = $root.gravity.v1.Valset.fromObject(object.valsets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLastValsetRequestsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @static
       * @param {gravity.v1.QueryLastValsetRequestsResponse} message QueryLastValsetRequestsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastValsetRequestsResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.valsets = [];
        if (message.valsets && message.valsets.length) {
          object.valsets = [];
          for (let j = 0; j < message.valsets.length; ++j)
            object.valsets[j] = $root.gravity.v1.Valset.toObject(message.valsets[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryLastValsetRequestsResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastValsetRequestsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastValsetRequestsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastValsetRequestsResponse;
    })();

    v1.QueryLastPendingValsetRequestByAddrRequest = (function() {

      /**
       * Properties of a QueryLastPendingValsetRequestByAddrRequest.
       * @memberof gravity.v1
       * @interface IQueryLastPendingValsetRequestByAddrRequest
       * @property {string|null} [address] QueryLastPendingValsetRequestByAddrRequest address
       */

      /**
       * Constructs a new QueryLastPendingValsetRequestByAddrRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastPendingValsetRequestByAddrRequest.
       * @implements IQueryLastPendingValsetRequestByAddrRequest
       * @constructor
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest=} [properties] Properties to set
       */
      function QueryLastPendingValsetRequestByAddrRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastPendingValsetRequestByAddrRequest address.
       * @member {string} address
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @instance
       */
      QueryLastPendingValsetRequestByAddrRequest.prototype.address = "";

      /**
       * Creates a new QueryLastPendingValsetRequestByAddrRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest instance
       */
      QueryLastPendingValsetRequestByAddrRequest.create = function create(properties) {
        return new QueryLastPendingValsetRequestByAddrRequest(properties);
      };

      /**
       * Encodes the specified QueryLastPendingValsetRequestByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} message QueryLastPendingValsetRequestByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingValsetRequestByAddrRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryLastPendingValsetRequestByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} message QueryLastPendingValsetRequestByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingValsetRequestByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastPendingValsetRequestByAddrRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingValsetRequestByAddrRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastPendingValsetRequestByAddrRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingValsetRequestByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastPendingValsetRequestByAddrRequest message.
       * @function verify
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastPendingValsetRequestByAddrRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.address != null && message.hasOwnProperty("address"))
          if (!$util.isString(message.address))
            return "address: string expected";
        return null;
      };

      /**
       * Creates a QueryLastPendingValsetRequestByAddrRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest
       */
      QueryLastPendingValsetRequestByAddrRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest)
          return object;
        let message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest();
        if (object.address != null)
          message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryLastPendingValsetRequestByAddrRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @static
       * @param {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} message QueryLastPendingValsetRequestByAddrRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastPendingValsetRequestByAddrRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.address = "";
        if (message.address != null && message.hasOwnProperty("address"))
          object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryLastPendingValsetRequestByAddrRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastPendingValsetRequestByAddrRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastPendingValsetRequestByAddrRequest;
    })();

    v1.QueryLastPendingValsetRequestByAddrResponse = (function() {

      /**
       * Properties of a QueryLastPendingValsetRequestByAddrResponse.
       * @memberof gravity.v1
       * @interface IQueryLastPendingValsetRequestByAddrResponse
       * @property {Array.<gravity.v1.IValset>|null} [valsets] QueryLastPendingValsetRequestByAddrResponse valsets
       */

      /**
       * Constructs a new QueryLastPendingValsetRequestByAddrResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastPendingValsetRequestByAddrResponse.
       * @implements IQueryLastPendingValsetRequestByAddrResponse
       * @constructor
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse=} [properties] Properties to set
       */
      function QueryLastPendingValsetRequestByAddrResponse(properties) {
        this.valsets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastPendingValsetRequestByAddrResponse valsets.
       * @member {Array.<gravity.v1.IValset>} valsets
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @instance
       */
      QueryLastPendingValsetRequestByAddrResponse.prototype.valsets = $util.emptyArray;

      /**
       * Creates a new QueryLastPendingValsetRequestByAddrResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse instance
       */
      QueryLastPendingValsetRequestByAddrResponse.create = function create(properties) {
        return new QueryLastPendingValsetRequestByAddrResponse(properties);
      };

      /**
       * Encodes the specified QueryLastPendingValsetRequestByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse} message QueryLastPendingValsetRequestByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingValsetRequestByAddrResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.valsets != null && message.valsets.length)
          for (let i = 0; i < message.valsets.length; ++i)
            $root.gravity.v1.Valset.encode(message.valsets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLastPendingValsetRequestByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse} message QueryLastPendingValsetRequestByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingValsetRequestByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastPendingValsetRequestByAddrResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingValsetRequestByAddrResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.valsets && message.valsets.length))
                message.valsets = [];
              message.valsets.push($root.gravity.v1.Valset.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastPendingValsetRequestByAddrResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingValsetRequestByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastPendingValsetRequestByAddrResponse message.
       * @function verify
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastPendingValsetRequestByAddrResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.valsets != null && message.hasOwnProperty("valsets")) {
          if (!Array.isArray(message.valsets))
            return "valsets: array expected";
          for (let i = 0; i < message.valsets.length; ++i) {
            let error = $root.gravity.v1.Valset.verify(message.valsets[i]);
            if (error)
              return "valsets." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryLastPendingValsetRequestByAddrResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse
       */
      QueryLastPendingValsetRequestByAddrResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse)
          return object;
        let message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse();
        if (object.valsets) {
          if (!Array.isArray(object.valsets))
            throw TypeError(".gravity.v1.QueryLastPendingValsetRequestByAddrResponse.valsets: array expected");
          message.valsets = [];
          for (let i = 0; i < object.valsets.length; ++i) {
            if (typeof object.valsets[i] !== "object")
              throw TypeError(".gravity.v1.QueryLastPendingValsetRequestByAddrResponse.valsets: object expected");
            message.valsets[i] = $root.gravity.v1.Valset.fromObject(object.valsets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLastPendingValsetRequestByAddrResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @static
       * @param {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} message QueryLastPendingValsetRequestByAddrResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastPendingValsetRequestByAddrResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.valsets = [];
        if (message.valsets && message.valsets.length) {
          object.valsets = [];
          for (let j = 0; j < message.valsets.length; ++j)
            object.valsets[j] = $root.gravity.v1.Valset.toObject(message.valsets[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryLastPendingValsetRequestByAddrResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastPendingValsetRequestByAddrResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastPendingValsetRequestByAddrResponse;
    })();

    v1.QueryBatchFeeRequest = (function() {

      /**
       * Properties of a QueryBatchFeeRequest.
       * @memberof gravity.v1
       * @interface IQueryBatchFeeRequest
       */

      /**
       * Constructs a new QueryBatchFeeRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryBatchFeeRequest.
       * @implements IQueryBatchFeeRequest
       * @constructor
       * @param {gravity.v1.IQueryBatchFeeRequest=} [properties] Properties to set
       */
      function QueryBatchFeeRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new QueryBatchFeeRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {gravity.v1.IQueryBatchFeeRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest instance
       */
      QueryBatchFeeRequest.create = function create(properties) {
        return new QueryBatchFeeRequest(properties);
      };

      /**
       * Encodes the specified QueryBatchFeeRequest message. Does not implicitly {@link gravity.v1.QueryBatchFeeRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {gravity.v1.IQueryBatchFeeRequest} message QueryBatchFeeRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchFeeRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryBatchFeeRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchFeeRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {gravity.v1.IQueryBatchFeeRequest} message QueryBatchFeeRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchFeeRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBatchFeeRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchFeeRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchFeeRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBatchFeeRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchFeeRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBatchFeeRequest message.
       * @function verify
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBatchFeeRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a QueryBatchFeeRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest
       */
      QueryBatchFeeRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryBatchFeeRequest)
          return object;
        return new $root.gravity.v1.QueryBatchFeeRequest();
      };

      /**
       * Creates a plain object from a QueryBatchFeeRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @static
       * @param {gravity.v1.QueryBatchFeeRequest} message QueryBatchFeeRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBatchFeeRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryBatchFeeRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryBatchFeeRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBatchFeeRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBatchFeeRequest;
    })();

    v1.QueryBatchFeeResponse = (function() {

      /**
       * Properties of a QueryBatchFeeResponse.
       * @memberof gravity.v1
       * @interface IQueryBatchFeeResponse
       * @property {Array.<gravity.v1.IBatchFees>|null} [batchFees] QueryBatchFeeResponse batchFees
       */

      /**
       * Constructs a new QueryBatchFeeResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryBatchFeeResponse.
       * @implements IQueryBatchFeeResponse
       * @constructor
       * @param {gravity.v1.IQueryBatchFeeResponse=} [properties] Properties to set
       */
      function QueryBatchFeeResponse(properties) {
        this.batchFees = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBatchFeeResponse batchFees.
       * @member {Array.<gravity.v1.IBatchFees>} batchFees
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @instance
       */
      QueryBatchFeeResponse.prototype.batchFees = $util.emptyArray;

      /**
       * Creates a new QueryBatchFeeResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {gravity.v1.IQueryBatchFeeResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse instance
       */
      QueryBatchFeeResponse.create = function create(properties) {
        return new QueryBatchFeeResponse(properties);
      };

      /**
       * Encodes the specified QueryBatchFeeResponse message. Does not implicitly {@link gravity.v1.QueryBatchFeeResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {gravity.v1.IQueryBatchFeeResponse} message QueryBatchFeeResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchFeeResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.batchFees != null && message.batchFees.length)
          for (let i = 0; i < message.batchFees.length; ++i)
            $root.gravity.v1.BatchFees.encode(message.batchFees[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryBatchFeeResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchFeeResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {gravity.v1.IQueryBatchFeeResponse} message QueryBatchFeeResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchFeeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBatchFeeResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchFeeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchFeeResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.batchFees && message.batchFees.length))
                message.batchFees = [];
              message.batchFees.push($root.gravity.v1.BatchFees.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBatchFeeResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchFeeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBatchFeeResponse message.
       * @function verify
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBatchFeeResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.batchFees != null && message.hasOwnProperty("batchFees")) {
          if (!Array.isArray(message.batchFees))
            return "batchFees: array expected";
          for (let i = 0; i < message.batchFees.length; ++i) {
            let error = $root.gravity.v1.BatchFees.verify(message.batchFees[i]);
            if (error)
              return "batchFees." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryBatchFeeResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse
       */
      QueryBatchFeeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryBatchFeeResponse)
          return object;
        let message = new $root.gravity.v1.QueryBatchFeeResponse();
        if (object.batchFees) {
          if (!Array.isArray(object.batchFees))
            throw TypeError(".gravity.v1.QueryBatchFeeResponse.batchFees: array expected");
          message.batchFees = [];
          for (let i = 0; i < object.batchFees.length; ++i) {
            if (typeof object.batchFees[i] !== "object")
              throw TypeError(".gravity.v1.QueryBatchFeeResponse.batchFees: object expected");
            message.batchFees[i] = $root.gravity.v1.BatchFees.fromObject(object.batchFees[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryBatchFeeResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @static
       * @param {gravity.v1.QueryBatchFeeResponse} message QueryBatchFeeResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBatchFeeResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.batchFees = [];
        if (message.batchFees && message.batchFees.length) {
          object.batchFees = [];
          for (let j = 0; j < message.batchFees.length; ++j)
            object.batchFees[j] = $root.gravity.v1.BatchFees.toObject(message.batchFees[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryBatchFeeResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryBatchFeeResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBatchFeeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBatchFeeResponse;
    })();

    v1.QueryLastPendingBatchRequestByAddrRequest = (function() {

      /**
       * Properties of a QueryLastPendingBatchRequestByAddrRequest.
       * @memberof gravity.v1
       * @interface IQueryLastPendingBatchRequestByAddrRequest
       * @property {string|null} [address] QueryLastPendingBatchRequestByAddrRequest address
       */

      /**
       * Constructs a new QueryLastPendingBatchRequestByAddrRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastPendingBatchRequestByAddrRequest.
       * @implements IQueryLastPendingBatchRequestByAddrRequest
       * @constructor
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest=} [properties] Properties to set
       */
      function QueryLastPendingBatchRequestByAddrRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastPendingBatchRequestByAddrRequest address.
       * @member {string} address
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @instance
       */
      QueryLastPendingBatchRequestByAddrRequest.prototype.address = "";

      /**
       * Creates a new QueryLastPendingBatchRequestByAddrRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest instance
       */
      QueryLastPendingBatchRequestByAddrRequest.create = function create(properties) {
        return new QueryLastPendingBatchRequestByAddrRequest(properties);
      };

      /**
       * Encodes the specified QueryLastPendingBatchRequestByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} message QueryLastPendingBatchRequestByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingBatchRequestByAddrRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryLastPendingBatchRequestByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} message QueryLastPendingBatchRequestByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingBatchRequestByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastPendingBatchRequestByAddrRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingBatchRequestByAddrRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastPendingBatchRequestByAddrRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingBatchRequestByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastPendingBatchRequestByAddrRequest message.
       * @function verify
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastPendingBatchRequestByAddrRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.address != null && message.hasOwnProperty("address"))
          if (!$util.isString(message.address))
            return "address: string expected";
        return null;
      };

      /**
       * Creates a QueryLastPendingBatchRequestByAddrRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest
       */
      QueryLastPendingBatchRequestByAddrRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest)
          return object;
        let message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest();
        if (object.address != null)
          message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryLastPendingBatchRequestByAddrRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @static
       * @param {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} message QueryLastPendingBatchRequestByAddrRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastPendingBatchRequestByAddrRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.address = "";
        if (message.address != null && message.hasOwnProperty("address"))
          object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryLastPendingBatchRequestByAddrRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastPendingBatchRequestByAddrRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastPendingBatchRequestByAddrRequest;
    })();

    v1.QueryLastPendingBatchRequestByAddrResponse = (function() {

      /**
       * Properties of a QueryLastPendingBatchRequestByAddrResponse.
       * @memberof gravity.v1
       * @interface IQueryLastPendingBatchRequestByAddrResponse
       * @property {Array.<gravity.v1.IOutgoingTxBatch>|null} [batch] QueryLastPendingBatchRequestByAddrResponse batch
       */

      /**
       * Constructs a new QueryLastPendingBatchRequestByAddrResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastPendingBatchRequestByAddrResponse.
       * @implements IQueryLastPendingBatchRequestByAddrResponse
       * @constructor
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse=} [properties] Properties to set
       */
      function QueryLastPendingBatchRequestByAddrResponse(properties) {
        this.batch = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastPendingBatchRequestByAddrResponse batch.
       * @member {Array.<gravity.v1.IOutgoingTxBatch>} batch
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @instance
       */
      QueryLastPendingBatchRequestByAddrResponse.prototype.batch = $util.emptyArray;

      /**
       * Creates a new QueryLastPendingBatchRequestByAddrResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse instance
       */
      QueryLastPendingBatchRequestByAddrResponse.create = function create(properties) {
        return new QueryLastPendingBatchRequestByAddrResponse(properties);
      };

      /**
       * Encodes the specified QueryLastPendingBatchRequestByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse} message QueryLastPendingBatchRequestByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingBatchRequestByAddrResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.batch != null && message.batch.length)
          for (let i = 0; i < message.batch.length; ++i)
            $root.gravity.v1.OutgoingTxBatch.encode(message.batch[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLastPendingBatchRequestByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse} message QueryLastPendingBatchRequestByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingBatchRequestByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastPendingBatchRequestByAddrResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingBatchRequestByAddrResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.batch && message.batch.length))
                message.batch = [];
              message.batch.push($root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastPendingBatchRequestByAddrResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingBatchRequestByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastPendingBatchRequestByAddrResponse message.
       * @function verify
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastPendingBatchRequestByAddrResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.batch != null && message.hasOwnProperty("batch")) {
          if (!Array.isArray(message.batch))
            return "batch: array expected";
          for (let i = 0; i < message.batch.length; ++i) {
            let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batch[i]);
            if (error)
              return "batch." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryLastPendingBatchRequestByAddrResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse
       */
      QueryLastPendingBatchRequestByAddrResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse)
          return object;
        let message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse();
        if (object.batch) {
          if (!Array.isArray(object.batch))
            throw TypeError(".gravity.v1.QueryLastPendingBatchRequestByAddrResponse.batch: array expected");
          message.batch = [];
          for (let i = 0; i < object.batch.length; ++i) {
            if (typeof object.batch[i] !== "object")
              throw TypeError(".gravity.v1.QueryLastPendingBatchRequestByAddrResponse.batch: object expected");
            message.batch[i] = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batch[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLastPendingBatchRequestByAddrResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @static
       * @param {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} message QueryLastPendingBatchRequestByAddrResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastPendingBatchRequestByAddrResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.batch = [];
        if (message.batch && message.batch.length) {
          object.batch = [];
          for (let j = 0; j < message.batch.length; ++j)
            object.batch[j] = $root.gravity.v1.OutgoingTxBatch.toObject(message.batch[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryLastPendingBatchRequestByAddrResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastPendingBatchRequestByAddrResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastPendingBatchRequestByAddrResponse;
    })();

    v1.QueryLastPendingLogicCallByAddrRequest = (function() {

      /**
       * Properties of a QueryLastPendingLogicCallByAddrRequest.
       * @memberof gravity.v1
       * @interface IQueryLastPendingLogicCallByAddrRequest
       * @property {string|null} [address] QueryLastPendingLogicCallByAddrRequest address
       */

      /**
       * Constructs a new QueryLastPendingLogicCallByAddrRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastPendingLogicCallByAddrRequest.
       * @implements IQueryLastPendingLogicCallByAddrRequest
       * @constructor
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest=} [properties] Properties to set
       */
      function QueryLastPendingLogicCallByAddrRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastPendingLogicCallByAddrRequest address.
       * @member {string} address
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @instance
       */
      QueryLastPendingLogicCallByAddrRequest.prototype.address = "";

      /**
       * Creates a new QueryLastPendingLogicCallByAddrRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest instance
       */
      QueryLastPendingLogicCallByAddrRequest.create = function create(properties) {
        return new QueryLastPendingLogicCallByAddrRequest(properties);
      };

      /**
       * Encodes the specified QueryLastPendingLogicCallByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} message QueryLastPendingLogicCallByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingLogicCallByAddrRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryLastPendingLogicCallByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} message QueryLastPendingLogicCallByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingLogicCallByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastPendingLogicCallByAddrRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingLogicCallByAddrRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastPendingLogicCallByAddrRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingLogicCallByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastPendingLogicCallByAddrRequest message.
       * @function verify
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastPendingLogicCallByAddrRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.address != null && message.hasOwnProperty("address"))
          if (!$util.isString(message.address))
            return "address: string expected";
        return null;
      };

      /**
       * Creates a QueryLastPendingLogicCallByAddrRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest
       */
      QueryLastPendingLogicCallByAddrRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest)
          return object;
        let message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest();
        if (object.address != null)
          message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryLastPendingLogicCallByAddrRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @static
       * @param {gravity.v1.QueryLastPendingLogicCallByAddrRequest} message QueryLastPendingLogicCallByAddrRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastPendingLogicCallByAddrRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.address = "";
        if (message.address != null && message.hasOwnProperty("address"))
          object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryLastPendingLogicCallByAddrRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastPendingLogicCallByAddrRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastPendingLogicCallByAddrRequest;
    })();

    v1.QueryLastPendingLogicCallByAddrResponse = (function() {

      /**
       * Properties of a QueryLastPendingLogicCallByAddrResponse.
       * @memberof gravity.v1
       * @interface IQueryLastPendingLogicCallByAddrResponse
       * @property {Array.<gravity.v1.IOutgoingLogicCall>|null} [call] QueryLastPendingLogicCallByAddrResponse call
       */

      /**
       * Constructs a new QueryLastPendingLogicCallByAddrResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastPendingLogicCallByAddrResponse.
       * @implements IQueryLastPendingLogicCallByAddrResponse
       * @constructor
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse=} [properties] Properties to set
       */
      function QueryLastPendingLogicCallByAddrResponse(properties) {
        this.call = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastPendingLogicCallByAddrResponse call.
       * @member {Array.<gravity.v1.IOutgoingLogicCall>} call
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @instance
       */
      QueryLastPendingLogicCallByAddrResponse.prototype.call = $util.emptyArray;

      /**
       * Creates a new QueryLastPendingLogicCallByAddrResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse instance
       */
      QueryLastPendingLogicCallByAddrResponse.create = function create(properties) {
        return new QueryLastPendingLogicCallByAddrResponse(properties);
      };

      /**
       * Encodes the specified QueryLastPendingLogicCallByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse} message QueryLastPendingLogicCallByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingLogicCallByAddrResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.call != null && message.call.length)
          for (let i = 0; i < message.call.length; ++i)
            $root.gravity.v1.OutgoingLogicCall.encode(message.call[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLastPendingLogicCallByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse} message QueryLastPendingLogicCallByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastPendingLogicCallByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastPendingLogicCallByAddrResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingLogicCallByAddrResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.call && message.call.length))
                message.call = [];
              message.call.push($root.gravity.v1.OutgoingLogicCall.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastPendingLogicCallByAddrResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastPendingLogicCallByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastPendingLogicCallByAddrResponse message.
       * @function verify
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastPendingLogicCallByAddrResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.call != null && message.hasOwnProperty("call")) {
          if (!Array.isArray(message.call))
            return "call: array expected";
          for (let i = 0; i < message.call.length; ++i) {
            let error = $root.gravity.v1.OutgoingLogicCall.verify(message.call[i]);
            if (error)
              return "call." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryLastPendingLogicCallByAddrResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse
       */
      QueryLastPendingLogicCallByAddrResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse)
          return object;
        let message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse();
        if (object.call) {
          if (!Array.isArray(object.call))
            throw TypeError(".gravity.v1.QueryLastPendingLogicCallByAddrResponse.call: array expected");
          message.call = [];
          for (let i = 0; i < object.call.length; ++i) {
            if (typeof object.call[i] !== "object")
              throw TypeError(".gravity.v1.QueryLastPendingLogicCallByAddrResponse.call: object expected");
            message.call[i] = $root.gravity.v1.OutgoingLogicCall.fromObject(object.call[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLastPendingLogicCallByAddrResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @static
       * @param {gravity.v1.QueryLastPendingLogicCallByAddrResponse} message QueryLastPendingLogicCallByAddrResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastPendingLogicCallByAddrResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.call = [];
        if (message.call && message.call.length) {
          object.call = [];
          for (let j = 0; j < message.call.length; ++j)
            object.call[j] = $root.gravity.v1.OutgoingLogicCall.toObject(message.call[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryLastPendingLogicCallByAddrResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastPendingLogicCallByAddrResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastPendingLogicCallByAddrResponse;
    })();

    v1.QueryOutgoingTxBatchesRequest = (function() {

      /**
       * Properties of a QueryOutgoingTxBatchesRequest.
       * @memberof gravity.v1
       * @interface IQueryOutgoingTxBatchesRequest
       */

      /**
       * Constructs a new QueryOutgoingTxBatchesRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryOutgoingTxBatchesRequest.
       * @implements IQueryOutgoingTxBatchesRequest
       * @constructor
       * @param {gravity.v1.IQueryOutgoingTxBatchesRequest=} [properties] Properties to set
       */
      function QueryOutgoingTxBatchesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new QueryOutgoingTxBatchesRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {gravity.v1.IQueryOutgoingTxBatchesRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest instance
       */
      QueryOutgoingTxBatchesRequest.create = function create(properties) {
        return new QueryOutgoingTxBatchesRequest(properties);
      };

      /**
       * Encodes the specified QueryOutgoingTxBatchesRequest message. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} message QueryOutgoingTxBatchesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingTxBatchesRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryOutgoingTxBatchesRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} message QueryOutgoingTxBatchesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingTxBatchesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryOutgoingTxBatchesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingTxBatchesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingTxBatchesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryOutgoingTxBatchesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingTxBatchesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryOutgoingTxBatchesRequest message.
       * @function verify
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryOutgoingTxBatchesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a QueryOutgoingTxBatchesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest
       */
      QueryOutgoingTxBatchesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryOutgoingTxBatchesRequest)
          return object;
        return new $root.gravity.v1.QueryOutgoingTxBatchesRequest();
      };

      /**
       * Creates a plain object from a QueryOutgoingTxBatchesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @static
       * @param {gravity.v1.QueryOutgoingTxBatchesRequest} message QueryOutgoingTxBatchesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryOutgoingTxBatchesRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryOutgoingTxBatchesRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryOutgoingTxBatchesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryOutgoingTxBatchesRequest;
    })();

    v1.QueryOutgoingTxBatchesResponse = (function() {

      /**
       * Properties of a QueryOutgoingTxBatchesResponse.
       * @memberof gravity.v1
       * @interface IQueryOutgoingTxBatchesResponse
       * @property {Array.<gravity.v1.IOutgoingTxBatch>|null} [batches] QueryOutgoingTxBatchesResponse batches
       */

      /**
       * Constructs a new QueryOutgoingTxBatchesResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryOutgoingTxBatchesResponse.
       * @implements IQueryOutgoingTxBatchesResponse
       * @constructor
       * @param {gravity.v1.IQueryOutgoingTxBatchesResponse=} [properties] Properties to set
       */
      function QueryOutgoingTxBatchesResponse(properties) {
        this.batches = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryOutgoingTxBatchesResponse batches.
       * @member {Array.<gravity.v1.IOutgoingTxBatch>} batches
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @instance
       */
      QueryOutgoingTxBatchesResponse.prototype.batches = $util.emptyArray;

      /**
       * Creates a new QueryOutgoingTxBatchesResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {gravity.v1.IQueryOutgoingTxBatchesResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse instance
       */
      QueryOutgoingTxBatchesResponse.create = function create(properties) {
        return new QueryOutgoingTxBatchesResponse(properties);
      };

      /**
       * Encodes the specified QueryOutgoingTxBatchesResponse message. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {gravity.v1.IQueryOutgoingTxBatchesResponse} message QueryOutgoingTxBatchesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingTxBatchesResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.batches != null && message.batches.length)
          for (let i = 0; i < message.batches.length; ++i)
            $root.gravity.v1.OutgoingTxBatch.encode(message.batches[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryOutgoingTxBatchesResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {gravity.v1.IQueryOutgoingTxBatchesResponse} message QueryOutgoingTxBatchesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingTxBatchesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryOutgoingTxBatchesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingTxBatchesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingTxBatchesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.batches && message.batches.length))
                message.batches = [];
              message.batches.push($root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryOutgoingTxBatchesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingTxBatchesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryOutgoingTxBatchesResponse message.
       * @function verify
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryOutgoingTxBatchesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.batches != null && message.hasOwnProperty("batches")) {
          if (!Array.isArray(message.batches))
            return "batches: array expected";
          for (let i = 0; i < message.batches.length; ++i) {
            let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batches[i]);
            if (error)
              return "batches." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryOutgoingTxBatchesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse
       */
      QueryOutgoingTxBatchesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryOutgoingTxBatchesResponse)
          return object;
        let message = new $root.gravity.v1.QueryOutgoingTxBatchesResponse();
        if (object.batches) {
          if (!Array.isArray(object.batches))
            throw TypeError(".gravity.v1.QueryOutgoingTxBatchesResponse.batches: array expected");
          message.batches = [];
          for (let i = 0; i < object.batches.length; ++i) {
            if (typeof object.batches[i] !== "object")
              throw TypeError(".gravity.v1.QueryOutgoingTxBatchesResponse.batches: object expected");
            message.batches[i] = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batches[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryOutgoingTxBatchesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @static
       * @param {gravity.v1.QueryOutgoingTxBatchesResponse} message QueryOutgoingTxBatchesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryOutgoingTxBatchesResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.batches = [];
        if (message.batches && message.batches.length) {
          object.batches = [];
          for (let j = 0; j < message.batches.length; ++j)
            object.batches[j] = $root.gravity.v1.OutgoingTxBatch.toObject(message.batches[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryOutgoingTxBatchesResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryOutgoingTxBatchesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryOutgoingTxBatchesResponse;
    })();

    v1.QueryOutgoingLogicCallsRequest = (function() {

      /**
       * Properties of a QueryOutgoingLogicCallsRequest.
       * @memberof gravity.v1
       * @interface IQueryOutgoingLogicCallsRequest
       */

      /**
       * Constructs a new QueryOutgoingLogicCallsRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryOutgoingLogicCallsRequest.
       * @implements IQueryOutgoingLogicCallsRequest
       * @constructor
       * @param {gravity.v1.IQueryOutgoingLogicCallsRequest=} [properties] Properties to set
       */
      function QueryOutgoingLogicCallsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new QueryOutgoingLogicCallsRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {gravity.v1.IQueryOutgoingLogicCallsRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest instance
       */
      QueryOutgoingLogicCallsRequest.create = function create(properties) {
        return new QueryOutgoingLogicCallsRequest(properties);
      };

      /**
       * Encodes the specified QueryOutgoingLogicCallsRequest message. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} message QueryOutgoingLogicCallsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingLogicCallsRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryOutgoingLogicCallsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} message QueryOutgoingLogicCallsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingLogicCallsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryOutgoingLogicCallsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingLogicCallsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingLogicCallsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryOutgoingLogicCallsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingLogicCallsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryOutgoingLogicCallsRequest message.
       * @function verify
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryOutgoingLogicCallsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a QueryOutgoingLogicCallsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest
       */
      QueryOutgoingLogicCallsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryOutgoingLogicCallsRequest)
          return object;
        return new $root.gravity.v1.QueryOutgoingLogicCallsRequest();
      };

      /**
       * Creates a plain object from a QueryOutgoingLogicCallsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @static
       * @param {gravity.v1.QueryOutgoingLogicCallsRequest} message QueryOutgoingLogicCallsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryOutgoingLogicCallsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryOutgoingLogicCallsRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryOutgoingLogicCallsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryOutgoingLogicCallsRequest;
    })();

    v1.QueryOutgoingLogicCallsResponse = (function() {

      /**
       * Properties of a QueryOutgoingLogicCallsResponse.
       * @memberof gravity.v1
       * @interface IQueryOutgoingLogicCallsResponse
       * @property {Array.<gravity.v1.IOutgoingLogicCall>|null} [calls] QueryOutgoingLogicCallsResponse calls
       */

      /**
       * Constructs a new QueryOutgoingLogicCallsResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryOutgoingLogicCallsResponse.
       * @implements IQueryOutgoingLogicCallsResponse
       * @constructor
       * @param {gravity.v1.IQueryOutgoingLogicCallsResponse=} [properties] Properties to set
       */
      function QueryOutgoingLogicCallsResponse(properties) {
        this.calls = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryOutgoingLogicCallsResponse calls.
       * @member {Array.<gravity.v1.IOutgoingLogicCall>} calls
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @instance
       */
      QueryOutgoingLogicCallsResponse.prototype.calls = $util.emptyArray;

      /**
       * Creates a new QueryOutgoingLogicCallsResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {gravity.v1.IQueryOutgoingLogicCallsResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse instance
       */
      QueryOutgoingLogicCallsResponse.create = function create(properties) {
        return new QueryOutgoingLogicCallsResponse(properties);
      };

      /**
       * Encodes the specified QueryOutgoingLogicCallsResponse message. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {gravity.v1.IQueryOutgoingLogicCallsResponse} message QueryOutgoingLogicCallsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingLogicCallsResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.calls != null && message.calls.length)
          for (let i = 0; i < message.calls.length; ++i)
            $root.gravity.v1.OutgoingLogicCall.encode(message.calls[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryOutgoingLogicCallsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {gravity.v1.IQueryOutgoingLogicCallsResponse} message QueryOutgoingLogicCallsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryOutgoingLogicCallsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryOutgoingLogicCallsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingLogicCallsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingLogicCallsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.calls && message.calls.length))
                message.calls = [];
              message.calls.push($root.gravity.v1.OutgoingLogicCall.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryOutgoingLogicCallsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryOutgoingLogicCallsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryOutgoingLogicCallsResponse message.
       * @function verify
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryOutgoingLogicCallsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.calls != null && message.hasOwnProperty("calls")) {
          if (!Array.isArray(message.calls))
            return "calls: array expected";
          for (let i = 0; i < message.calls.length; ++i) {
            let error = $root.gravity.v1.OutgoingLogicCall.verify(message.calls[i]);
            if (error)
              return "calls." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryOutgoingLogicCallsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse
       */
      QueryOutgoingLogicCallsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryOutgoingLogicCallsResponse)
          return object;
        let message = new $root.gravity.v1.QueryOutgoingLogicCallsResponse();
        if (object.calls) {
          if (!Array.isArray(object.calls))
            throw TypeError(".gravity.v1.QueryOutgoingLogicCallsResponse.calls: array expected");
          message.calls = [];
          for (let i = 0; i < object.calls.length; ++i) {
            if (typeof object.calls[i] !== "object")
              throw TypeError(".gravity.v1.QueryOutgoingLogicCallsResponse.calls: object expected");
            message.calls[i] = $root.gravity.v1.OutgoingLogicCall.fromObject(object.calls[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryOutgoingLogicCallsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @static
       * @param {gravity.v1.QueryOutgoingLogicCallsResponse} message QueryOutgoingLogicCallsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryOutgoingLogicCallsResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.calls = [];
        if (message.calls && message.calls.length) {
          object.calls = [];
          for (let j = 0; j < message.calls.length; ++j)
            object.calls[j] = $root.gravity.v1.OutgoingLogicCall.toObject(message.calls[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryOutgoingLogicCallsResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryOutgoingLogicCallsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryOutgoingLogicCallsResponse;
    })();

    v1.QueryBatchRequestByNonceRequest = (function() {

      /**
       * Properties of a QueryBatchRequestByNonceRequest.
       * @memberof gravity.v1
       * @interface IQueryBatchRequestByNonceRequest
       * @property {number|Long|null} [nonce] QueryBatchRequestByNonceRequest nonce
       * @property {string|null} [contractAddress] QueryBatchRequestByNonceRequest contractAddress
       */

      /**
       * Constructs a new QueryBatchRequestByNonceRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryBatchRequestByNonceRequest.
       * @implements IQueryBatchRequestByNonceRequest
       * @constructor
       * @param {gravity.v1.IQueryBatchRequestByNonceRequest=} [properties] Properties to set
       */
      function QueryBatchRequestByNonceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBatchRequestByNonceRequest nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @instance
       */
      QueryBatchRequestByNonceRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * QueryBatchRequestByNonceRequest contractAddress.
       * @member {string} contractAddress
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @instance
       */
      QueryBatchRequestByNonceRequest.prototype.contractAddress = "";

      /**
       * Creates a new QueryBatchRequestByNonceRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {gravity.v1.IQueryBatchRequestByNonceRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest instance
       */
      QueryBatchRequestByNonceRequest.create = function create(properties) {
        return new QueryBatchRequestByNonceRequest(properties);
      };

      /**
       * Encodes the specified QueryBatchRequestByNonceRequest message. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {gravity.v1.IQueryBatchRequestByNonceRequest} message QueryBatchRequestByNonceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchRequestByNonceRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryBatchRequestByNonceRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {gravity.v1.IQueryBatchRequestByNonceRequest} message QueryBatchRequestByNonceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchRequestByNonceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBatchRequestByNonceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchRequestByNonceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchRequestByNonceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            case 2:
              message.contractAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBatchRequestByNonceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchRequestByNonceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBatchRequestByNonceRequest message.
       * @function verify
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBatchRequestByNonceRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
          if (!$util.isString(message.contractAddress))
            return "contractAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryBatchRequestByNonceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest
       */
      QueryBatchRequestByNonceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryBatchRequestByNonceRequest)
          return object;
        let message = new $root.gravity.v1.QueryBatchRequestByNonceRequest();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        if (object.contractAddress != null)
          message.contractAddress = String(object.contractAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryBatchRequestByNonceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @static
       * @param {gravity.v1.QueryBatchRequestByNonceRequest} message QueryBatchRequestByNonceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBatchRequestByNonceRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
          object.contractAddress = "";
        }
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
          object.contractAddress = message.contractAddress;
        return object;
      };

      /**
       * Converts this QueryBatchRequestByNonceRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryBatchRequestByNonceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBatchRequestByNonceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBatchRequestByNonceRequest;
    })();

    v1.QueryBatchRequestByNonceResponse = (function() {

      /**
       * Properties of a QueryBatchRequestByNonceResponse.
       * @memberof gravity.v1
       * @interface IQueryBatchRequestByNonceResponse
       * @property {gravity.v1.IOutgoingTxBatch|null} [batch] QueryBatchRequestByNonceResponse batch
       */

      /**
       * Constructs a new QueryBatchRequestByNonceResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryBatchRequestByNonceResponse.
       * @implements IQueryBatchRequestByNonceResponse
       * @constructor
       * @param {gravity.v1.IQueryBatchRequestByNonceResponse=} [properties] Properties to set
       */
      function QueryBatchRequestByNonceResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBatchRequestByNonceResponse batch.
       * @member {gravity.v1.IOutgoingTxBatch|null|undefined} batch
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @instance
       */
      QueryBatchRequestByNonceResponse.prototype.batch = null;

      /**
       * Creates a new QueryBatchRequestByNonceResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {gravity.v1.IQueryBatchRequestByNonceResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse instance
       */
      QueryBatchRequestByNonceResponse.create = function create(properties) {
        return new QueryBatchRequestByNonceResponse(properties);
      };

      /**
       * Encodes the specified QueryBatchRequestByNonceResponse message. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {gravity.v1.IQueryBatchRequestByNonceResponse} message QueryBatchRequestByNonceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchRequestByNonceResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.batch != null && Object.hasOwnProperty.call(message, "batch"))
          $root.gravity.v1.OutgoingTxBatch.encode(message.batch, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryBatchRequestByNonceResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {gravity.v1.IQueryBatchRequestByNonceResponse} message QueryBatchRequestByNonceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchRequestByNonceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBatchRequestByNonceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchRequestByNonceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchRequestByNonceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.batch = $root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBatchRequestByNonceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchRequestByNonceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBatchRequestByNonceResponse message.
       * @function verify
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBatchRequestByNonceResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.batch != null && message.hasOwnProperty("batch")) {
          let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batch);
          if (error)
            return "batch." + error;
        }
        return null;
      };

      /**
       * Creates a QueryBatchRequestByNonceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse
       */
      QueryBatchRequestByNonceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryBatchRequestByNonceResponse)
          return object;
        let message = new $root.gravity.v1.QueryBatchRequestByNonceResponse();
        if (object.batch != null) {
          if (typeof object.batch !== "object")
            throw TypeError(".gravity.v1.QueryBatchRequestByNonceResponse.batch: object expected");
          message.batch = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batch);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryBatchRequestByNonceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @static
       * @param {gravity.v1.QueryBatchRequestByNonceResponse} message QueryBatchRequestByNonceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBatchRequestByNonceResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.batch = null;
        if (message.batch != null && message.hasOwnProperty("batch"))
          object.batch = $root.gravity.v1.OutgoingTxBatch.toObject(message.batch, options);
        return object;
      };

      /**
       * Converts this QueryBatchRequestByNonceResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryBatchRequestByNonceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBatchRequestByNonceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBatchRequestByNonceResponse;
    })();

    v1.QueryBatchConfirmsRequest = (function() {

      /**
       * Properties of a QueryBatchConfirmsRequest.
       * @memberof gravity.v1
       * @interface IQueryBatchConfirmsRequest
       * @property {number|Long|null} [nonce] QueryBatchConfirmsRequest nonce
       * @property {string|null} [contractAddress] QueryBatchConfirmsRequest contractAddress
       */

      /**
       * Constructs a new QueryBatchConfirmsRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryBatchConfirmsRequest.
       * @implements IQueryBatchConfirmsRequest
       * @constructor
       * @param {gravity.v1.IQueryBatchConfirmsRequest=} [properties] Properties to set
       */
      function QueryBatchConfirmsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBatchConfirmsRequest nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @instance
       */
      QueryBatchConfirmsRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * QueryBatchConfirmsRequest contractAddress.
       * @member {string} contractAddress
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @instance
       */
      QueryBatchConfirmsRequest.prototype.contractAddress = "";

      /**
       * Creates a new QueryBatchConfirmsRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {gravity.v1.IQueryBatchConfirmsRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest instance
       */
      QueryBatchConfirmsRequest.create = function create(properties) {
        return new QueryBatchConfirmsRequest(properties);
      };

      /**
       * Encodes the specified QueryBatchConfirmsRequest message. Does not implicitly {@link gravity.v1.QueryBatchConfirmsRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {gravity.v1.IQueryBatchConfirmsRequest} message QueryBatchConfirmsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchConfirmsRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryBatchConfirmsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchConfirmsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {gravity.v1.IQueryBatchConfirmsRequest} message QueryBatchConfirmsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchConfirmsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBatchConfirmsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchConfirmsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchConfirmsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            case 2:
              message.contractAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBatchConfirmsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchConfirmsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBatchConfirmsRequest message.
       * @function verify
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBatchConfirmsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
          if (!$util.isString(message.contractAddress))
            return "contractAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryBatchConfirmsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest
       */
      QueryBatchConfirmsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryBatchConfirmsRequest)
          return object;
        let message = new $root.gravity.v1.QueryBatchConfirmsRequest();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        if (object.contractAddress != null)
          message.contractAddress = String(object.contractAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryBatchConfirmsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @static
       * @param {gravity.v1.QueryBatchConfirmsRequest} message QueryBatchConfirmsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBatchConfirmsRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
          object.contractAddress = "";
        }
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
          object.contractAddress = message.contractAddress;
        return object;
      };

      /**
       * Converts this QueryBatchConfirmsRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryBatchConfirmsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBatchConfirmsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBatchConfirmsRequest;
    })();

    v1.QueryBatchConfirmsResponse = (function() {

      /**
       * Properties of a QueryBatchConfirmsResponse.
       * @memberof gravity.v1
       * @interface IQueryBatchConfirmsResponse
       * @property {Array.<gravity.v1.IMsgConfirmBatch>|null} [confirms] QueryBatchConfirmsResponse confirms
       */

      /**
       * Constructs a new QueryBatchConfirmsResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryBatchConfirmsResponse.
       * @implements IQueryBatchConfirmsResponse
       * @constructor
       * @param {gravity.v1.IQueryBatchConfirmsResponse=} [properties] Properties to set
       */
      function QueryBatchConfirmsResponse(properties) {
        this.confirms = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBatchConfirmsResponse confirms.
       * @member {Array.<gravity.v1.IMsgConfirmBatch>} confirms
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @instance
       */
      QueryBatchConfirmsResponse.prototype.confirms = $util.emptyArray;

      /**
       * Creates a new QueryBatchConfirmsResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {gravity.v1.IQueryBatchConfirmsResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse instance
       */
      QueryBatchConfirmsResponse.create = function create(properties) {
        return new QueryBatchConfirmsResponse(properties);
      };

      /**
       * Encodes the specified QueryBatchConfirmsResponse message. Does not implicitly {@link gravity.v1.QueryBatchConfirmsResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {gravity.v1.IQueryBatchConfirmsResponse} message QueryBatchConfirmsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchConfirmsResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.confirms != null && message.confirms.length)
          for (let i = 0; i < message.confirms.length; ++i)
            $root.gravity.v1.MsgConfirmBatch.encode(message.confirms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryBatchConfirmsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchConfirmsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {gravity.v1.IQueryBatchConfirmsResponse} message QueryBatchConfirmsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBatchConfirmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBatchConfirmsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchConfirmsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchConfirmsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.confirms && message.confirms.length))
                message.confirms = [];
              message.confirms.push($root.gravity.v1.MsgConfirmBatch.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBatchConfirmsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBatchConfirmsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBatchConfirmsResponse message.
       * @function verify
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBatchConfirmsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.confirms != null && message.hasOwnProperty("confirms")) {
          if (!Array.isArray(message.confirms))
            return "confirms: array expected";
          for (let i = 0; i < message.confirms.length; ++i) {
            let error = $root.gravity.v1.MsgConfirmBatch.verify(message.confirms[i]);
            if (error)
              return "confirms." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryBatchConfirmsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse
       */
      QueryBatchConfirmsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryBatchConfirmsResponse)
          return object;
        let message = new $root.gravity.v1.QueryBatchConfirmsResponse();
        if (object.confirms) {
          if (!Array.isArray(object.confirms))
            throw TypeError(".gravity.v1.QueryBatchConfirmsResponse.confirms: array expected");
          message.confirms = [];
          for (let i = 0; i < object.confirms.length; ++i) {
            if (typeof object.confirms[i] !== "object")
              throw TypeError(".gravity.v1.QueryBatchConfirmsResponse.confirms: object expected");
            message.confirms[i] = $root.gravity.v1.MsgConfirmBatch.fromObject(object.confirms[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryBatchConfirmsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @static
       * @param {gravity.v1.QueryBatchConfirmsResponse} message QueryBatchConfirmsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBatchConfirmsResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.confirms = [];
        if (message.confirms && message.confirms.length) {
          object.confirms = [];
          for (let j = 0; j < message.confirms.length; ++j)
            object.confirms[j] = $root.gravity.v1.MsgConfirmBatch.toObject(message.confirms[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryBatchConfirmsResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryBatchConfirmsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBatchConfirmsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBatchConfirmsResponse;
    })();

    v1.QueryLogicConfirmsRequest = (function() {

      /**
       * Properties of a QueryLogicConfirmsRequest.
       * @memberof gravity.v1
       * @interface IQueryLogicConfirmsRequest
       * @property {Uint8Array|null} [invalidationId] QueryLogicConfirmsRequest invalidationId
       * @property {number|Long|null} [invalidationNonce] QueryLogicConfirmsRequest invalidationNonce
       */

      /**
       * Constructs a new QueryLogicConfirmsRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLogicConfirmsRequest.
       * @implements IQueryLogicConfirmsRequest
       * @constructor
       * @param {gravity.v1.IQueryLogicConfirmsRequest=} [properties] Properties to set
       */
      function QueryLogicConfirmsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLogicConfirmsRequest invalidationId.
       * @member {Uint8Array} invalidationId
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @instance
       */
      QueryLogicConfirmsRequest.prototype.invalidationId = $util.newBuffer([]);

      /**
       * QueryLogicConfirmsRequest invalidationNonce.
       * @member {number|Long} invalidationNonce
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @instance
       */
      QueryLogicConfirmsRequest.prototype.invalidationNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new QueryLogicConfirmsRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {gravity.v1.IQueryLogicConfirmsRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest instance
       */
      QueryLogicConfirmsRequest.create = function create(properties) {
        return new QueryLogicConfirmsRequest(properties);
      };

      /**
       * Encodes the specified QueryLogicConfirmsRequest message. Does not implicitly {@link gravity.v1.QueryLogicConfirmsRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {gravity.v1.IQueryLogicConfirmsRequest} message QueryLogicConfirmsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLogicConfirmsRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.invalidationId != null && Object.hasOwnProperty.call(message, "invalidationId"))
          writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.invalidationId);
        if (message.invalidationNonce != null && Object.hasOwnProperty.call(message, "invalidationNonce"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.invalidationNonce);
        return writer;
      };

      /**
       * Encodes the specified QueryLogicConfirmsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLogicConfirmsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {gravity.v1.IQueryLogicConfirmsRequest} message QueryLogicConfirmsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLogicConfirmsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLogicConfirmsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLogicConfirmsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLogicConfirmsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.invalidationId = reader.bytes();
              break;
            case 2:
              message.invalidationNonce = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLogicConfirmsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLogicConfirmsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLogicConfirmsRequest message.
       * @function verify
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLogicConfirmsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          if (!(message.invalidationId && typeof message.invalidationId.length === "number" || $util.isString(message.invalidationId)))
            return "invalidationId: buffer expected";
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (!$util.isInteger(message.invalidationNonce) && !(message.invalidationNonce && $util.isInteger(message.invalidationNonce.low) && $util.isInteger(message.invalidationNonce.high)))
            return "invalidationNonce: integer|Long expected";
        return null;
      };

      /**
       * Creates a QueryLogicConfirmsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest
       */
      QueryLogicConfirmsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLogicConfirmsRequest)
          return object;
        let message = new $root.gravity.v1.QueryLogicConfirmsRequest();
        if (object.invalidationId != null)
          if (typeof object.invalidationId === "string")
            $util.base64.decode(object.invalidationId, message.invalidationId = $util.newBuffer($util.base64.length(object.invalidationId)), 0);
          else if (object.invalidationId.length)
            message.invalidationId = object.invalidationId;
        if (object.invalidationNonce != null)
          if ($util.Long)
            (message.invalidationNonce = $util.Long.fromValue(object.invalidationNonce)).unsigned = true;
          else if (typeof object.invalidationNonce === "string")
            message.invalidationNonce = parseInt(object.invalidationNonce, 10);
          else if (typeof object.invalidationNonce === "number")
            message.invalidationNonce = object.invalidationNonce;
          else if (typeof object.invalidationNonce === "object")
            message.invalidationNonce = new $util.LongBits(object.invalidationNonce.low >>> 0, object.invalidationNonce.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryLogicConfirmsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @static
       * @param {gravity.v1.QueryLogicConfirmsRequest} message QueryLogicConfirmsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLogicConfirmsRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if (options.bytes === String)
            object.invalidationId = "";
          else {
            object.invalidationId = [];
            if (options.bytes !== Array)
              object.invalidationId = $util.newBuffer(object.invalidationId);
          }
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.invalidationNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.invalidationNonce = options.longs === String ? "0" : 0;
        }
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          object.invalidationId = options.bytes === String ? $util.base64.encode(message.invalidationId, 0, message.invalidationId.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidationId) : message.invalidationId;
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (typeof message.invalidationNonce === "number")
            object.invalidationNonce = options.longs === String ? String(message.invalidationNonce) : message.invalidationNonce;
          else
            object.invalidationNonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidationNonce) : options.longs === Number ? new $util.LongBits(message.invalidationNonce.low >>> 0, message.invalidationNonce.high >>> 0).toNumber(true) : message.invalidationNonce;
        return object;
      };

      /**
       * Converts this QueryLogicConfirmsRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLogicConfirmsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLogicConfirmsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLogicConfirmsRequest;
    })();

    v1.QueryLogicConfirmsResponse = (function() {

      /**
       * Properties of a QueryLogicConfirmsResponse.
       * @memberof gravity.v1
       * @interface IQueryLogicConfirmsResponse
       * @property {Array.<gravity.v1.IMsgConfirmLogicCall>|null} [confirms] QueryLogicConfirmsResponse confirms
       */

      /**
       * Constructs a new QueryLogicConfirmsResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLogicConfirmsResponse.
       * @implements IQueryLogicConfirmsResponse
       * @constructor
       * @param {gravity.v1.IQueryLogicConfirmsResponse=} [properties] Properties to set
       */
      function QueryLogicConfirmsResponse(properties) {
        this.confirms = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLogicConfirmsResponse confirms.
       * @member {Array.<gravity.v1.IMsgConfirmLogicCall>} confirms
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @instance
       */
      QueryLogicConfirmsResponse.prototype.confirms = $util.emptyArray;

      /**
       * Creates a new QueryLogicConfirmsResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {gravity.v1.IQueryLogicConfirmsResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse instance
       */
      QueryLogicConfirmsResponse.create = function create(properties) {
        return new QueryLogicConfirmsResponse(properties);
      };

      /**
       * Encodes the specified QueryLogicConfirmsResponse message. Does not implicitly {@link gravity.v1.QueryLogicConfirmsResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {gravity.v1.IQueryLogicConfirmsResponse} message QueryLogicConfirmsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLogicConfirmsResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.confirms != null && message.confirms.length)
          for (let i = 0; i < message.confirms.length; ++i)
            $root.gravity.v1.MsgConfirmLogicCall.encode(message.confirms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLogicConfirmsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLogicConfirmsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {gravity.v1.IQueryLogicConfirmsResponse} message QueryLogicConfirmsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLogicConfirmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLogicConfirmsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLogicConfirmsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLogicConfirmsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.confirms && message.confirms.length))
                message.confirms = [];
              message.confirms.push($root.gravity.v1.MsgConfirmLogicCall.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLogicConfirmsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLogicConfirmsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLogicConfirmsResponse message.
       * @function verify
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLogicConfirmsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.confirms != null && message.hasOwnProperty("confirms")) {
          if (!Array.isArray(message.confirms))
            return "confirms: array expected";
          for (let i = 0; i < message.confirms.length; ++i) {
            let error = $root.gravity.v1.MsgConfirmLogicCall.verify(message.confirms[i]);
            if (error)
              return "confirms." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryLogicConfirmsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse
       */
      QueryLogicConfirmsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLogicConfirmsResponse)
          return object;
        let message = new $root.gravity.v1.QueryLogicConfirmsResponse();
        if (object.confirms) {
          if (!Array.isArray(object.confirms))
            throw TypeError(".gravity.v1.QueryLogicConfirmsResponse.confirms: array expected");
          message.confirms = [];
          for (let i = 0; i < object.confirms.length; ++i) {
            if (typeof object.confirms[i] !== "object")
              throw TypeError(".gravity.v1.QueryLogicConfirmsResponse.confirms: object expected");
            message.confirms[i] = $root.gravity.v1.MsgConfirmLogicCall.fromObject(object.confirms[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLogicConfirmsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @static
       * @param {gravity.v1.QueryLogicConfirmsResponse} message QueryLogicConfirmsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLogicConfirmsResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.confirms = [];
        if (message.confirms && message.confirms.length) {
          object.confirms = [];
          for (let j = 0; j < message.confirms.length; ++j)
            object.confirms[j] = $root.gravity.v1.MsgConfirmLogicCall.toObject(message.confirms[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryLogicConfirmsResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLogicConfirmsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLogicConfirmsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLogicConfirmsResponse;
    })();

    v1.QueryLastEventNonceByAddrRequest = (function() {

      /**
       * Properties of a QueryLastEventNonceByAddrRequest.
       * @memberof gravity.v1
       * @interface IQueryLastEventNonceByAddrRequest
       * @property {string|null} [address] QueryLastEventNonceByAddrRequest address
       */

      /**
       * Constructs a new QueryLastEventNonceByAddrRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastEventNonceByAddrRequest.
       * @implements IQueryLastEventNonceByAddrRequest
       * @constructor
       * @param {gravity.v1.IQueryLastEventNonceByAddrRequest=} [properties] Properties to set
       */
      function QueryLastEventNonceByAddrRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastEventNonceByAddrRequest address.
       * @member {string} address
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @instance
       */
      QueryLastEventNonceByAddrRequest.prototype.address = "";

      /**
       * Creates a new QueryLastEventNonceByAddrRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastEventNonceByAddrRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest instance
       */
      QueryLastEventNonceByAddrRequest.create = function create(properties) {
        return new QueryLastEventNonceByAddrRequest(properties);
      };

      /**
       * Encodes the specified QueryLastEventNonceByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} message QueryLastEventNonceByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastEventNonceByAddrRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryLastEventNonceByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} message QueryLastEventNonceByAddrRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastEventNonceByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastEventNonceByAddrRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastEventNonceByAddrRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastEventNonceByAddrRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastEventNonceByAddrRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastEventNonceByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastEventNonceByAddrRequest message.
       * @function verify
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastEventNonceByAddrRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.address != null && message.hasOwnProperty("address"))
          if (!$util.isString(message.address))
            return "address: string expected";
        return null;
      };

      /**
       * Creates a QueryLastEventNonceByAddrRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest
       */
      QueryLastEventNonceByAddrRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastEventNonceByAddrRequest)
          return object;
        let message = new $root.gravity.v1.QueryLastEventNonceByAddrRequest();
        if (object.address != null)
          message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryLastEventNonceByAddrRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @static
       * @param {gravity.v1.QueryLastEventNonceByAddrRequest} message QueryLastEventNonceByAddrRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastEventNonceByAddrRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.address = "";
        if (message.address != null && message.hasOwnProperty("address"))
          object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryLastEventNonceByAddrRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastEventNonceByAddrRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastEventNonceByAddrRequest;
    })();

    v1.QueryLastEventNonceByAddrResponse = (function() {

      /**
       * Properties of a QueryLastEventNonceByAddrResponse.
       * @memberof gravity.v1
       * @interface IQueryLastEventNonceByAddrResponse
       * @property {number|Long|null} [eventNonce] QueryLastEventNonceByAddrResponse eventNonce
       */

      /**
       * Constructs a new QueryLastEventNonceByAddrResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryLastEventNonceByAddrResponse.
       * @implements IQueryLastEventNonceByAddrResponse
       * @constructor
       * @param {gravity.v1.IQueryLastEventNonceByAddrResponse=} [properties] Properties to set
       */
      function QueryLastEventNonceByAddrResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLastEventNonceByAddrResponse eventNonce.
       * @member {number|Long} eventNonce
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @instance
       */
      QueryLastEventNonceByAddrResponse.prototype.eventNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new QueryLastEventNonceByAddrResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastEventNonceByAddrResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse instance
       */
      QueryLastEventNonceByAddrResponse.create = function create(properties) {
        return new QueryLastEventNonceByAddrResponse(properties);
      };

      /**
       * Encodes the specified QueryLastEventNonceByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastEventNonceByAddrResponse} message QueryLastEventNonceByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastEventNonceByAddrResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.eventNonce != null && Object.hasOwnProperty.call(message, "eventNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eventNonce);
        return writer;
      };

      /**
       * Encodes the specified QueryLastEventNonceByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {gravity.v1.IQueryLastEventNonceByAddrResponse} message QueryLastEventNonceByAddrResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLastEventNonceByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLastEventNonceByAddrResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastEventNonceByAddrResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastEventNonceByAddrResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.eventNonce = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLastEventNonceByAddrResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLastEventNonceByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLastEventNonceByAddrResponse message.
       * @function verify
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLastEventNonceByAddrResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (!$util.isInteger(message.eventNonce) && !(message.eventNonce && $util.isInteger(message.eventNonce.low) && $util.isInteger(message.eventNonce.high)))
            return "eventNonce: integer|Long expected";
        return null;
      };

      /**
       * Creates a QueryLastEventNonceByAddrResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse
       */
      QueryLastEventNonceByAddrResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryLastEventNonceByAddrResponse)
          return object;
        let message = new $root.gravity.v1.QueryLastEventNonceByAddrResponse();
        if (object.eventNonce != null)
          if ($util.Long)
            (message.eventNonce = $util.Long.fromValue(object.eventNonce)).unsigned = true;
          else if (typeof object.eventNonce === "string")
            message.eventNonce = parseInt(object.eventNonce, 10);
          else if (typeof object.eventNonce === "number")
            message.eventNonce = object.eventNonce;
          else if (typeof object.eventNonce === "object")
            message.eventNonce = new $util.LongBits(object.eventNonce.low >>> 0, object.eventNonce.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryLastEventNonceByAddrResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @static
       * @param {gravity.v1.QueryLastEventNonceByAddrResponse} message QueryLastEventNonceByAddrResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLastEventNonceByAddrResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.eventNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.eventNonce = options.longs === String ? "0" : 0;
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (typeof message.eventNonce === "number")
            object.eventNonce = options.longs === String ? String(message.eventNonce) : message.eventNonce;
          else
            object.eventNonce = options.longs === String ? $util.Long.prototype.toString.call(message.eventNonce) : options.longs === Number ? new $util.LongBits(message.eventNonce.low >>> 0, message.eventNonce.high >>> 0).toNumber(true) : message.eventNonce;
        return object;
      };

      /**
       * Converts this QueryLastEventNonceByAddrResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLastEventNonceByAddrResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLastEventNonceByAddrResponse;
    })();

    v1.QueryERC20ToDenomRequest = (function() {

      /**
       * Properties of a QueryERC20ToDenomRequest.
       * @memberof gravity.v1
       * @interface IQueryERC20ToDenomRequest
       * @property {string|null} [erc20] QueryERC20ToDenomRequest erc20
       */

      /**
       * Constructs a new QueryERC20ToDenomRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryERC20ToDenomRequest.
       * @implements IQueryERC20ToDenomRequest
       * @constructor
       * @param {gravity.v1.IQueryERC20ToDenomRequest=} [properties] Properties to set
       */
      function QueryERC20ToDenomRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryERC20ToDenomRequest erc20.
       * @member {string} erc20
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @instance
       */
      QueryERC20ToDenomRequest.prototype.erc20 = "";

      /**
       * Creates a new QueryERC20ToDenomRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {gravity.v1.IQueryERC20ToDenomRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest instance
       */
      QueryERC20ToDenomRequest.create = function create(properties) {
        return new QueryERC20ToDenomRequest(properties);
      };

      /**
       * Encodes the specified QueryERC20ToDenomRequest message. Does not implicitly {@link gravity.v1.QueryERC20ToDenomRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {gravity.v1.IQueryERC20ToDenomRequest} message QueryERC20ToDenomRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryERC20ToDenomRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.erc20 != null && Object.hasOwnProperty.call(message, "erc20"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.erc20);
        return writer;
      };

      /**
       * Encodes the specified QueryERC20ToDenomRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryERC20ToDenomRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {gravity.v1.IQueryERC20ToDenomRequest} message QueryERC20ToDenomRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryERC20ToDenomRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryERC20ToDenomRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryERC20ToDenomRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryERC20ToDenomRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.erc20 = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryERC20ToDenomRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryERC20ToDenomRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryERC20ToDenomRequest message.
       * @function verify
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryERC20ToDenomRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.erc20 != null && message.hasOwnProperty("erc20"))
          if (!$util.isString(message.erc20))
            return "erc20: string expected";
        return null;
      };

      /**
       * Creates a QueryERC20ToDenomRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest
       */
      QueryERC20ToDenomRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryERC20ToDenomRequest)
          return object;
        let message = new $root.gravity.v1.QueryERC20ToDenomRequest();
        if (object.erc20 != null)
          message.erc20 = String(object.erc20);
        return message;
      };

      /**
       * Creates a plain object from a QueryERC20ToDenomRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @static
       * @param {gravity.v1.QueryERC20ToDenomRequest} message QueryERC20ToDenomRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryERC20ToDenomRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.erc20 = "";
        if (message.erc20 != null && message.hasOwnProperty("erc20"))
          object.erc20 = message.erc20;
        return object;
      };

      /**
       * Converts this QueryERC20ToDenomRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryERC20ToDenomRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryERC20ToDenomRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryERC20ToDenomRequest;
    })();

    v1.QueryERC20ToDenomResponse = (function() {

      /**
       * Properties of a QueryERC20ToDenomResponse.
       * @memberof gravity.v1
       * @interface IQueryERC20ToDenomResponse
       * @property {string|null} [denom] QueryERC20ToDenomResponse denom
       * @property {boolean|null} [cosmosOriginated] QueryERC20ToDenomResponse cosmosOriginated
       */

      /**
       * Constructs a new QueryERC20ToDenomResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryERC20ToDenomResponse.
       * @implements IQueryERC20ToDenomResponse
       * @constructor
       * @param {gravity.v1.IQueryERC20ToDenomResponse=} [properties] Properties to set
       */
      function QueryERC20ToDenomResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryERC20ToDenomResponse denom.
       * @member {string} denom
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @instance
       */
      QueryERC20ToDenomResponse.prototype.denom = "";

      /**
       * QueryERC20ToDenomResponse cosmosOriginated.
       * @member {boolean} cosmosOriginated
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @instance
       */
      QueryERC20ToDenomResponse.prototype.cosmosOriginated = false;

      /**
       * Creates a new QueryERC20ToDenomResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {gravity.v1.IQueryERC20ToDenomResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse instance
       */
      QueryERC20ToDenomResponse.create = function create(properties) {
        return new QueryERC20ToDenomResponse(properties);
      };

      /**
       * Encodes the specified QueryERC20ToDenomResponse message. Does not implicitly {@link gravity.v1.QueryERC20ToDenomResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {gravity.v1.IQueryERC20ToDenomResponse} message QueryERC20ToDenomResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryERC20ToDenomResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
        if (message.cosmosOriginated != null && Object.hasOwnProperty.call(message, "cosmosOriginated"))
          writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cosmosOriginated);
        return writer;
      };

      /**
       * Encodes the specified QueryERC20ToDenomResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryERC20ToDenomResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {gravity.v1.IQueryERC20ToDenomResponse} message QueryERC20ToDenomResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryERC20ToDenomResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryERC20ToDenomResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryERC20ToDenomResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryERC20ToDenomResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.cosmosOriginated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryERC20ToDenomResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryERC20ToDenomResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryERC20ToDenomResponse message.
       * @function verify
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryERC20ToDenomResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.denom != null && message.hasOwnProperty("denom"))
          if (!$util.isString(message.denom))
            return "denom: string expected";
        if (message.cosmosOriginated != null && message.hasOwnProperty("cosmosOriginated"))
          if (typeof message.cosmosOriginated !== "boolean")
            return "cosmosOriginated: boolean expected";
        return null;
      };

      /**
       * Creates a QueryERC20ToDenomResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse
       */
      QueryERC20ToDenomResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryERC20ToDenomResponse)
          return object;
        let message = new $root.gravity.v1.QueryERC20ToDenomResponse();
        if (object.denom != null)
          message.denom = String(object.denom);
        if (object.cosmosOriginated != null)
          message.cosmosOriginated = Boolean(object.cosmosOriginated);
        return message;
      };

      /**
       * Creates a plain object from a QueryERC20ToDenomResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @static
       * @param {gravity.v1.QueryERC20ToDenomResponse} message QueryERC20ToDenomResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryERC20ToDenomResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.denom = "";
          object.cosmosOriginated = false;
        }
        if (message.denom != null && message.hasOwnProperty("denom"))
          object.denom = message.denom;
        if (message.cosmosOriginated != null && message.hasOwnProperty("cosmosOriginated"))
          object.cosmosOriginated = message.cosmosOriginated;
        return object;
      };

      /**
       * Converts this QueryERC20ToDenomResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryERC20ToDenomResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryERC20ToDenomResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryERC20ToDenomResponse;
    })();

    v1.QueryDenomToERC20Request = (function() {

      /**
       * Properties of a QueryDenomToERC20Request.
       * @memberof gravity.v1
       * @interface IQueryDenomToERC20Request
       * @property {string|null} [denom] QueryDenomToERC20Request denom
       */

      /**
       * Constructs a new QueryDenomToERC20Request.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDenomToERC20Request.
       * @implements IQueryDenomToERC20Request
       * @constructor
       * @param {gravity.v1.IQueryDenomToERC20Request=} [properties] Properties to set
       */
      function QueryDenomToERC20Request(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDenomToERC20Request denom.
       * @member {string} denom
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @instance
       */
      QueryDenomToERC20Request.prototype.denom = "";

      /**
       * Creates a new QueryDenomToERC20Request instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {gravity.v1.IQueryDenomToERC20Request=} [properties] Properties to set
       * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request instance
       */
      QueryDenomToERC20Request.create = function create(properties) {
        return new QueryDenomToERC20Request(properties);
      };

      /**
       * Encodes the specified QueryDenomToERC20Request message. Does not implicitly {@link gravity.v1.QueryDenomToERC20Request.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {gravity.v1.IQueryDenomToERC20Request} message QueryDenomToERC20Request message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomToERC20Request.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified QueryDenomToERC20Request message, length delimited. Does not implicitly {@link gravity.v1.QueryDenomToERC20Request.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {gravity.v1.IQueryDenomToERC20Request} message QueryDenomToERC20Request message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomToERC20Request.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDenomToERC20Request message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomToERC20Request.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDenomToERC20Request();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDenomToERC20Request message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomToERC20Request.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDenomToERC20Request message.
       * @function verify
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDenomToERC20Request.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.denom != null && message.hasOwnProperty("denom"))
          if (!$util.isString(message.denom))
            return "denom: string expected";
        return null;
      };

      /**
       * Creates a QueryDenomToERC20Request message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request
       */
      QueryDenomToERC20Request.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDenomToERC20Request)
          return object;
        let message = new $root.gravity.v1.QueryDenomToERC20Request();
        if (object.denom != null)
          message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a QueryDenomToERC20Request message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @static
       * @param {gravity.v1.QueryDenomToERC20Request} message QueryDenomToERC20Request
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDenomToERC20Request.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.denom = "";
        if (message.denom != null && message.hasOwnProperty("denom"))
          object.denom = message.denom;
        return object;
      };

      /**
       * Converts this QueryDenomToERC20Request to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDenomToERC20Request
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDenomToERC20Request.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDenomToERC20Request;
    })();

    v1.QueryDenomToERC20Response = (function() {

      /**
       * Properties of a QueryDenomToERC20Response.
       * @memberof gravity.v1
       * @interface IQueryDenomToERC20Response
       * @property {string|null} [erc20] QueryDenomToERC20Response erc20
       * @property {boolean|null} [cosmosOriginated] QueryDenomToERC20Response cosmosOriginated
       */

      /**
       * Constructs a new QueryDenomToERC20Response.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDenomToERC20Response.
       * @implements IQueryDenomToERC20Response
       * @constructor
       * @param {gravity.v1.IQueryDenomToERC20Response=} [properties] Properties to set
       */
      function QueryDenomToERC20Response(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDenomToERC20Response erc20.
       * @member {string} erc20
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @instance
       */
      QueryDenomToERC20Response.prototype.erc20 = "";

      /**
       * QueryDenomToERC20Response cosmosOriginated.
       * @member {boolean} cosmosOriginated
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @instance
       */
      QueryDenomToERC20Response.prototype.cosmosOriginated = false;

      /**
       * Creates a new QueryDenomToERC20Response instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {gravity.v1.IQueryDenomToERC20Response=} [properties] Properties to set
       * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response instance
       */
      QueryDenomToERC20Response.create = function create(properties) {
        return new QueryDenomToERC20Response(properties);
      };

      /**
       * Encodes the specified QueryDenomToERC20Response message. Does not implicitly {@link gravity.v1.QueryDenomToERC20Response.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {gravity.v1.IQueryDenomToERC20Response} message QueryDenomToERC20Response message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomToERC20Response.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.erc20 != null && Object.hasOwnProperty.call(message, "erc20"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.erc20);
        if (message.cosmosOriginated != null && Object.hasOwnProperty.call(message, "cosmosOriginated"))
          writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cosmosOriginated);
        return writer;
      };

      /**
       * Encodes the specified QueryDenomToERC20Response message, length delimited. Does not implicitly {@link gravity.v1.QueryDenomToERC20Response.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {gravity.v1.IQueryDenomToERC20Response} message QueryDenomToERC20Response message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomToERC20Response.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDenomToERC20Response message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomToERC20Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDenomToERC20Response();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.erc20 = reader.string();
              break;
            case 2:
              message.cosmosOriginated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDenomToERC20Response message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomToERC20Response.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDenomToERC20Response message.
       * @function verify
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDenomToERC20Response.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.erc20 != null && message.hasOwnProperty("erc20"))
          if (!$util.isString(message.erc20))
            return "erc20: string expected";
        if (message.cosmosOriginated != null && message.hasOwnProperty("cosmosOriginated"))
          if (typeof message.cosmosOriginated !== "boolean")
            return "cosmosOriginated: boolean expected";
        return null;
      };

      /**
       * Creates a QueryDenomToERC20Response message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response
       */
      QueryDenomToERC20Response.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDenomToERC20Response)
          return object;
        let message = new $root.gravity.v1.QueryDenomToERC20Response();
        if (object.erc20 != null)
          message.erc20 = String(object.erc20);
        if (object.cosmosOriginated != null)
          message.cosmosOriginated = Boolean(object.cosmosOriginated);
        return message;
      };

      /**
       * Creates a plain object from a QueryDenomToERC20Response message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @static
       * @param {gravity.v1.QueryDenomToERC20Response} message QueryDenomToERC20Response
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDenomToERC20Response.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.erc20 = "";
          object.cosmosOriginated = false;
        }
        if (message.erc20 != null && message.hasOwnProperty("erc20"))
          object.erc20 = message.erc20;
        if (message.cosmosOriginated != null && message.hasOwnProperty("cosmosOriginated"))
          object.cosmosOriginated = message.cosmosOriginated;
        return object;
      };

      /**
       * Converts this QueryDenomToERC20Response to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDenomToERC20Response
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDenomToERC20Response.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDenomToERC20Response;
    })();

    v1.QueryAttestationsRequest = (function() {

      /**
       * Properties of a QueryAttestationsRequest.
       * @memberof gravity.v1
       * @interface IQueryAttestationsRequest
       * @property {number|Long|null} [limit] QueryAttestationsRequest limit
       */

      /**
       * Constructs a new QueryAttestationsRequest.
       * @memberof gravity.v1
       * @classdesc Represents a QueryAttestationsRequest.
       * @implements IQueryAttestationsRequest
       * @constructor
       * @param {gravity.v1.IQueryAttestationsRequest=} [properties] Properties to set
       */
      function QueryAttestationsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAttestationsRequest limit.
       * @member {number|Long} limit
       * @memberof gravity.v1.QueryAttestationsRequest
       * @instance
       */
      QueryAttestationsRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new QueryAttestationsRequest instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {gravity.v1.IQueryAttestationsRequest=} [properties] Properties to set
       * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest instance
       */
      QueryAttestationsRequest.create = function create(properties) {
        return new QueryAttestationsRequest(properties);
      };

      /**
       * Encodes the specified QueryAttestationsRequest message. Does not implicitly {@link gravity.v1.QueryAttestationsRequest.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {gravity.v1.IQueryAttestationsRequest} message QueryAttestationsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAttestationsRequest.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.limit);
        return writer;
      };

      /**
       * Encodes the specified QueryAttestationsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryAttestationsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {gravity.v1.IQueryAttestationsRequest} message QueryAttestationsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAttestationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAttestationsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAttestationsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryAttestationsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.limit = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAttestationsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAttestationsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAttestationsRequest message.
       * @function verify
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAttestationsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.limit != null && message.hasOwnProperty("limit"))
          if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
            return "limit: integer|Long expected";
        return null;
      };

      /**
       * Creates a QueryAttestationsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest
       */
      QueryAttestationsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryAttestationsRequest)
          return object;
        let message = new $root.gravity.v1.QueryAttestationsRequest();
        if (object.limit != null)
          if ($util.Long)
            (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
          else if (typeof object.limit === "string")
            message.limit = parseInt(object.limit, 10);
          else if (typeof object.limit === "number")
            message.limit = object.limit;
          else if (typeof object.limit === "object")
            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryAttestationsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryAttestationsRequest
       * @static
       * @param {gravity.v1.QueryAttestationsRequest} message QueryAttestationsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAttestationsRequest.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.limit = options.longs === String ? "0" : 0;
        if (message.limit != null && message.hasOwnProperty("limit"))
          if (typeof message.limit === "number")
            object.limit = options.longs === String ? String(message.limit) : message.limit;
          else
            object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
        return object;
      };

      /**
       * Converts this QueryAttestationsRequest to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryAttestationsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAttestationsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAttestationsRequest;
    })();

    v1.QueryAttestationsResponse = (function() {

      /**
       * Properties of a QueryAttestationsResponse.
       * @memberof gravity.v1
       * @interface IQueryAttestationsResponse
       * @property {Array.<gravity.v1.IAttestation>|null} [attestations] QueryAttestationsResponse attestations
       */

      /**
       * Constructs a new QueryAttestationsResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryAttestationsResponse.
       * @implements IQueryAttestationsResponse
       * @constructor
       * @param {gravity.v1.IQueryAttestationsResponse=} [properties] Properties to set
       */
      function QueryAttestationsResponse(properties) {
        this.attestations = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAttestationsResponse attestations.
       * @member {Array.<gravity.v1.IAttestation>} attestations
       * @memberof gravity.v1.QueryAttestationsResponse
       * @instance
       */
      QueryAttestationsResponse.prototype.attestations = $util.emptyArray;

      /**
       * Creates a new QueryAttestationsResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {gravity.v1.IQueryAttestationsResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse instance
       */
      QueryAttestationsResponse.create = function create(properties) {
        return new QueryAttestationsResponse(properties);
      };

      /**
       * Encodes the specified QueryAttestationsResponse message. Does not implicitly {@link gravity.v1.QueryAttestationsResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {gravity.v1.IQueryAttestationsResponse} message QueryAttestationsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAttestationsResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.attestations != null && message.attestations.length)
          for (let i = 0; i < message.attestations.length; ++i)
            $root.gravity.v1.Attestation.encode(message.attestations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAttestationsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryAttestationsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {gravity.v1.IQueryAttestationsResponse} message QueryAttestationsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAttestationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAttestationsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAttestationsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryAttestationsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.attestations && message.attestations.length))
                message.attestations = [];
              message.attestations.push($root.gravity.v1.Attestation.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAttestationsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAttestationsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAttestationsResponse message.
       * @function verify
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAttestationsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.attestations != null && message.hasOwnProperty("attestations")) {
          if (!Array.isArray(message.attestations))
            return "attestations: array expected";
          for (let i = 0; i < message.attestations.length; ++i) {
            let error = $root.gravity.v1.Attestation.verify(message.attestations[i]);
            if (error)
              return "attestations." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAttestationsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse
       */
      QueryAttestationsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryAttestationsResponse)
          return object;
        let message = new $root.gravity.v1.QueryAttestationsResponse();
        if (object.attestations) {
          if (!Array.isArray(object.attestations))
            throw TypeError(".gravity.v1.QueryAttestationsResponse.attestations: array expected");
          message.attestations = [];
          for (let i = 0; i < object.attestations.length; ++i) {
            if (typeof object.attestations[i] !== "object")
              throw TypeError(".gravity.v1.QueryAttestationsResponse.attestations: object expected");
            message.attestations[i] = $root.gravity.v1.Attestation.fromObject(object.attestations[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAttestationsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryAttestationsResponse
       * @static
       * @param {gravity.v1.QueryAttestationsResponse} message QueryAttestationsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAttestationsResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.attestations = [];
        if (message.attestations && message.attestations.length) {
          object.attestations = [];
          for (let j = 0; j < message.attestations.length; ++j)
            object.attestations[j] = $root.gravity.v1.Attestation.toObject(message.attestations[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryAttestationsResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryAttestationsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAttestationsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAttestationsResponse;
    })();

    v1.QueryDelegateKeysByValidatorAddress = (function() {

      /**
       * Properties of a QueryDelegateKeysByValidatorAddress.
       * @memberof gravity.v1
       * @interface IQueryDelegateKeysByValidatorAddress
       * @property {string|null} [validatorAddress] QueryDelegateKeysByValidatorAddress validatorAddress
       */

      /**
       * Constructs a new QueryDelegateKeysByValidatorAddress.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDelegateKeysByValidatorAddress.
       * @implements IQueryDelegateKeysByValidatorAddress
       * @constructor
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress=} [properties] Properties to set
       */
      function QueryDelegateKeysByValidatorAddress(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDelegateKeysByValidatorAddress validatorAddress.
       * @member {string} validatorAddress
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @instance
       */
      QueryDelegateKeysByValidatorAddress.prototype.validatorAddress = "";

      /**
       * Creates a new QueryDelegateKeysByValidatorAddress instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress=} [properties] Properties to set
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress instance
       */
      QueryDelegateKeysByValidatorAddress.create = function create(properties) {
        return new QueryDelegateKeysByValidatorAddress(properties);
      };

      /**
       * Encodes the specified QueryDelegateKeysByValidatorAddress message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddress.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} message QueryDelegateKeysByValidatorAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByValidatorAddress.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.validatorAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryDelegateKeysByValidatorAddress message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddress.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} message QueryDelegateKeysByValidatorAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByValidatorAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDelegateKeysByValidatorAddress message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByValidatorAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddress();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDelegateKeysByValidatorAddress message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByValidatorAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDelegateKeysByValidatorAddress message.
       * @function verify
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDelegateKeysByValidatorAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
          if (!$util.isString(message.validatorAddress))
            return "validatorAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryDelegateKeysByValidatorAddress message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress
       */
      QueryDelegateKeysByValidatorAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDelegateKeysByValidatorAddress)
          return object;
        let message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddress();
        if (object.validatorAddress != null)
          message.validatorAddress = String(object.validatorAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryDelegateKeysByValidatorAddress message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @static
       * @param {gravity.v1.QueryDelegateKeysByValidatorAddress} message QueryDelegateKeysByValidatorAddress
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDelegateKeysByValidatorAddress.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.validatorAddress = "";
        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
          object.validatorAddress = message.validatorAddress;
        return object;
      };

      /**
       * Converts this QueryDelegateKeysByValidatorAddress to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDelegateKeysByValidatorAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDelegateKeysByValidatorAddress;
    })();

    v1.QueryDelegateKeysByValidatorAddressResponse = (function() {

      /**
       * Properties of a QueryDelegateKeysByValidatorAddressResponse.
       * @memberof gravity.v1
       * @interface IQueryDelegateKeysByValidatorAddressResponse
       * @property {string|null} [ethAddress] QueryDelegateKeysByValidatorAddressResponse ethAddress
       * @property {string|null} [orchestratorAddress] QueryDelegateKeysByValidatorAddressResponse orchestratorAddress
       */

      /**
       * Constructs a new QueryDelegateKeysByValidatorAddressResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDelegateKeysByValidatorAddressResponse.
       * @implements IQueryDelegateKeysByValidatorAddressResponse
       * @constructor
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse=} [properties] Properties to set
       */
      function QueryDelegateKeysByValidatorAddressResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDelegateKeysByValidatorAddressResponse ethAddress.
       * @member {string} ethAddress
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @instance
       */
      QueryDelegateKeysByValidatorAddressResponse.prototype.ethAddress = "";

      /**
       * QueryDelegateKeysByValidatorAddressResponse orchestratorAddress.
       * @member {string} orchestratorAddress
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @instance
       */
      QueryDelegateKeysByValidatorAddressResponse.prototype.orchestratorAddress = "";

      /**
       * Creates a new QueryDelegateKeysByValidatorAddressResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse instance
       */
      QueryDelegateKeysByValidatorAddressResponse.create = function create(properties) {
        return new QueryDelegateKeysByValidatorAddressResponse(properties);
      };

      /**
       * Encodes the specified QueryDelegateKeysByValidatorAddressResponse message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddressResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse} message QueryDelegateKeysByValidatorAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByValidatorAddressResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.ethAddress != null && Object.hasOwnProperty.call(message, "ethAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.ethAddress);
        if (message.orchestratorAddress != null && Object.hasOwnProperty.call(message, "orchestratorAddress"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestratorAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryDelegateKeysByValidatorAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddressResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse} message QueryDelegateKeysByValidatorAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByValidatorAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDelegateKeysByValidatorAddressResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByValidatorAddressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ethAddress = reader.string();
              break;
            case 2:
              message.orchestratorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDelegateKeysByValidatorAddressResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByValidatorAddressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDelegateKeysByValidatorAddressResponse message.
       * @function verify
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDelegateKeysByValidatorAddressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          if (!$util.isString(message.ethAddress))
            return "ethAddress: string expected";
        if (message.orchestratorAddress != null && message.hasOwnProperty("orchestratorAddress"))
          if (!$util.isString(message.orchestratorAddress))
            return "orchestratorAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryDelegateKeysByValidatorAddressResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse
       */
      QueryDelegateKeysByValidatorAddressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse)
          return object;
        let message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse();
        if (object.ethAddress != null)
          message.ethAddress = String(object.ethAddress);
        if (object.orchestratorAddress != null)
          message.orchestratorAddress = String(object.orchestratorAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryDelegateKeysByValidatorAddressResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @static
       * @param {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} message QueryDelegateKeysByValidatorAddressResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDelegateKeysByValidatorAddressResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.ethAddress = "";
          object.orchestratorAddress = "";
        }
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          object.ethAddress = message.ethAddress;
        if (message.orchestratorAddress != null && message.hasOwnProperty("orchestratorAddress"))
          object.orchestratorAddress = message.orchestratorAddress;
        return object;
      };

      /**
       * Converts this QueryDelegateKeysByValidatorAddressResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDelegateKeysByValidatorAddressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDelegateKeysByValidatorAddressResponse;
    })();

    v1.QueryDelegateKeysByEthAddress = (function() {

      /**
       * Properties of a QueryDelegateKeysByEthAddress.
       * @memberof gravity.v1
       * @interface IQueryDelegateKeysByEthAddress
       * @property {string|null} [ethAddress] QueryDelegateKeysByEthAddress ethAddress
       */

      /**
       * Constructs a new QueryDelegateKeysByEthAddress.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDelegateKeysByEthAddress.
       * @implements IQueryDelegateKeysByEthAddress
       * @constructor
       * @param {gravity.v1.IQueryDelegateKeysByEthAddress=} [properties] Properties to set
       */
      function QueryDelegateKeysByEthAddress(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDelegateKeysByEthAddress ethAddress.
       * @member {string} ethAddress
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @instance
       */
      QueryDelegateKeysByEthAddress.prototype.ethAddress = "";

      /**
       * Creates a new QueryDelegateKeysByEthAddress instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByEthAddress=} [properties] Properties to set
       * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress instance
       */
      QueryDelegateKeysByEthAddress.create = function create(properties) {
        return new QueryDelegateKeysByEthAddress(properties);
      };

      /**
       * Encodes the specified QueryDelegateKeysByEthAddress message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddress.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByEthAddress} message QueryDelegateKeysByEthAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByEthAddress.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.ethAddress != null && Object.hasOwnProperty.call(message, "ethAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.ethAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryDelegateKeysByEthAddress message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddress.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByEthAddress} message QueryDelegateKeysByEthAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByEthAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDelegateKeysByEthAddress message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByEthAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByEthAddress();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ethAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDelegateKeysByEthAddress message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByEthAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDelegateKeysByEthAddress message.
       * @function verify
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDelegateKeysByEthAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          if (!$util.isString(message.ethAddress))
            return "ethAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryDelegateKeysByEthAddress message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress
       */
      QueryDelegateKeysByEthAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDelegateKeysByEthAddress)
          return object;
        let message = new $root.gravity.v1.QueryDelegateKeysByEthAddress();
        if (object.ethAddress != null)
          message.ethAddress = String(object.ethAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryDelegateKeysByEthAddress message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @static
       * @param {gravity.v1.QueryDelegateKeysByEthAddress} message QueryDelegateKeysByEthAddress
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDelegateKeysByEthAddress.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.ethAddress = "";
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          object.ethAddress = message.ethAddress;
        return object;
      };

      /**
       * Converts this QueryDelegateKeysByEthAddress to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDelegateKeysByEthAddress
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDelegateKeysByEthAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDelegateKeysByEthAddress;
    })();

    v1.QueryDelegateKeysByEthAddressResponse = (function() {

      /**
       * Properties of a QueryDelegateKeysByEthAddressResponse.
       * @memberof gravity.v1
       * @interface IQueryDelegateKeysByEthAddressResponse
       * @property {string|null} [validatorAddress] QueryDelegateKeysByEthAddressResponse validatorAddress
       * @property {string|null} [orchestratorAddress] QueryDelegateKeysByEthAddressResponse orchestratorAddress
       */

      /**
       * Constructs a new QueryDelegateKeysByEthAddressResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDelegateKeysByEthAddressResponse.
       * @implements IQueryDelegateKeysByEthAddressResponse
       * @constructor
       * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse=} [properties] Properties to set
       */
      function QueryDelegateKeysByEthAddressResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDelegateKeysByEthAddressResponse validatorAddress.
       * @member {string} validatorAddress
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @instance
       */
      QueryDelegateKeysByEthAddressResponse.prototype.validatorAddress = "";

      /**
       * QueryDelegateKeysByEthAddressResponse orchestratorAddress.
       * @member {string} orchestratorAddress
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @instance
       */
      QueryDelegateKeysByEthAddressResponse.prototype.orchestratorAddress = "";

      /**
       * Creates a new QueryDelegateKeysByEthAddressResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse instance
       */
      QueryDelegateKeysByEthAddressResponse.create = function create(properties) {
        return new QueryDelegateKeysByEthAddressResponse(properties);
      };

      /**
       * Encodes the specified QueryDelegateKeysByEthAddressResponse message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddressResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse} message QueryDelegateKeysByEthAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByEthAddressResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.validatorAddress);
        if (message.orchestratorAddress != null && Object.hasOwnProperty.call(message, "orchestratorAddress"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestratorAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryDelegateKeysByEthAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddressResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse} message QueryDelegateKeysByEthAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByEthAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDelegateKeysByEthAddressResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByEthAddressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByEthAddressResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.orchestratorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDelegateKeysByEthAddressResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByEthAddressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDelegateKeysByEthAddressResponse message.
       * @function verify
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDelegateKeysByEthAddressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
          if (!$util.isString(message.validatorAddress))
            return "validatorAddress: string expected";
        if (message.orchestratorAddress != null && message.hasOwnProperty("orchestratorAddress"))
          if (!$util.isString(message.orchestratorAddress))
            return "orchestratorAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryDelegateKeysByEthAddressResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse
       */
      QueryDelegateKeysByEthAddressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDelegateKeysByEthAddressResponse)
          return object;
        let message = new $root.gravity.v1.QueryDelegateKeysByEthAddressResponse();
        if (object.validatorAddress != null)
          message.validatorAddress = String(object.validatorAddress);
        if (object.orchestratorAddress != null)
          message.orchestratorAddress = String(object.orchestratorAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryDelegateKeysByEthAddressResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @static
       * @param {gravity.v1.QueryDelegateKeysByEthAddressResponse} message QueryDelegateKeysByEthAddressResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDelegateKeysByEthAddressResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.validatorAddress = "";
          object.orchestratorAddress = "";
        }
        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
          object.validatorAddress = message.validatorAddress;
        if (message.orchestratorAddress != null && message.hasOwnProperty("orchestratorAddress"))
          object.orchestratorAddress = message.orchestratorAddress;
        return object;
      };

      /**
       * Converts this QueryDelegateKeysByEthAddressResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDelegateKeysByEthAddressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDelegateKeysByEthAddressResponse;
    })();

    v1.QueryDelegateKeysByOrchestratorAddress = (function() {

      /**
       * Properties of a QueryDelegateKeysByOrchestratorAddress.
       * @memberof gravity.v1
       * @interface IQueryDelegateKeysByOrchestratorAddress
       * @property {string|null} [orchestratorAddress] QueryDelegateKeysByOrchestratorAddress orchestratorAddress
       */

      /**
       * Constructs a new QueryDelegateKeysByOrchestratorAddress.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDelegateKeysByOrchestratorAddress.
       * @implements IQueryDelegateKeysByOrchestratorAddress
       * @constructor
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress=} [properties] Properties to set
       */
      function QueryDelegateKeysByOrchestratorAddress(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDelegateKeysByOrchestratorAddress orchestratorAddress.
       * @member {string} orchestratorAddress
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @instance
       */
      QueryDelegateKeysByOrchestratorAddress.prototype.orchestratorAddress = "";

      /**
       * Creates a new QueryDelegateKeysByOrchestratorAddress instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress=} [properties] Properties to set
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress instance
       */
      QueryDelegateKeysByOrchestratorAddress.create = function create(properties) {
        return new QueryDelegateKeysByOrchestratorAddress(properties);
      };

      /**
       * Encodes the specified QueryDelegateKeysByOrchestratorAddress message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddress.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} message QueryDelegateKeysByOrchestratorAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByOrchestratorAddress.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.orchestratorAddress != null && Object.hasOwnProperty.call(message, "orchestratorAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.orchestratorAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryDelegateKeysByOrchestratorAddress message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddress.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} message QueryDelegateKeysByOrchestratorAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByOrchestratorAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDelegateKeysByOrchestratorAddress message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByOrchestratorAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.orchestratorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDelegateKeysByOrchestratorAddress message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByOrchestratorAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDelegateKeysByOrchestratorAddress message.
       * @function verify
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDelegateKeysByOrchestratorAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.orchestratorAddress != null && message.hasOwnProperty("orchestratorAddress"))
          if (!$util.isString(message.orchestratorAddress))
            return "orchestratorAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryDelegateKeysByOrchestratorAddress message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress
       */
      QueryDelegateKeysByOrchestratorAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress)
          return object;
        let message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress();
        if (object.orchestratorAddress != null)
          message.orchestratorAddress = String(object.orchestratorAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryDelegateKeysByOrchestratorAddress message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @static
       * @param {gravity.v1.QueryDelegateKeysByOrchestratorAddress} message QueryDelegateKeysByOrchestratorAddress
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDelegateKeysByOrchestratorAddress.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.orchestratorAddress = "";
        if (message.orchestratorAddress != null && message.hasOwnProperty("orchestratorAddress"))
          object.orchestratorAddress = message.orchestratorAddress;
        return object;
      };

      /**
       * Converts this QueryDelegateKeysByOrchestratorAddress to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDelegateKeysByOrchestratorAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDelegateKeysByOrchestratorAddress;
    })();

    v1.QueryDelegateKeysByOrchestratorAddressResponse = (function() {

      /**
       * Properties of a QueryDelegateKeysByOrchestratorAddressResponse.
       * @memberof gravity.v1
       * @interface IQueryDelegateKeysByOrchestratorAddressResponse
       * @property {string|null} [validatorAddress] QueryDelegateKeysByOrchestratorAddressResponse validatorAddress
       * @property {string|null} [ethAddress] QueryDelegateKeysByOrchestratorAddressResponse ethAddress
       */

      /**
       * Constructs a new QueryDelegateKeysByOrchestratorAddressResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryDelegateKeysByOrchestratorAddressResponse.
       * @implements IQueryDelegateKeysByOrchestratorAddressResponse
       * @constructor
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse=} [properties] Properties to set
       */
      function QueryDelegateKeysByOrchestratorAddressResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDelegateKeysByOrchestratorAddressResponse validatorAddress.
       * @member {string} validatorAddress
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @instance
       */
      QueryDelegateKeysByOrchestratorAddressResponse.prototype.validatorAddress = "";

      /**
       * QueryDelegateKeysByOrchestratorAddressResponse ethAddress.
       * @member {string} ethAddress
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @instance
       */
      QueryDelegateKeysByOrchestratorAddressResponse.prototype.ethAddress = "";

      /**
       * Creates a new QueryDelegateKeysByOrchestratorAddressResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse instance
       */
      QueryDelegateKeysByOrchestratorAddressResponse.create = function create(properties) {
        return new QueryDelegateKeysByOrchestratorAddressResponse(properties);
      };

      /**
       * Encodes the specified QueryDelegateKeysByOrchestratorAddressResponse message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse} message QueryDelegateKeysByOrchestratorAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByOrchestratorAddressResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.validatorAddress != null && Object.hasOwnProperty.call(message, "validatorAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.validatorAddress);
        if (message.ethAddress != null && Object.hasOwnProperty.call(message, "ethAddress"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.ethAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryDelegateKeysByOrchestratorAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse} message QueryDelegateKeysByOrchestratorAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDelegateKeysByOrchestratorAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDelegateKeysByOrchestratorAddressResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByOrchestratorAddressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.ethAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDelegateKeysByOrchestratorAddressResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDelegateKeysByOrchestratorAddressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDelegateKeysByOrchestratorAddressResponse message.
       * @function verify
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDelegateKeysByOrchestratorAddressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
          if (!$util.isString(message.validatorAddress))
            return "validatorAddress: string expected";
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          if (!$util.isString(message.ethAddress))
            return "ethAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryDelegateKeysByOrchestratorAddressResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse
       */
      QueryDelegateKeysByOrchestratorAddressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse)
          return object;
        let message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse();
        if (object.validatorAddress != null)
          message.validatorAddress = String(object.validatorAddress);
        if (object.ethAddress != null)
          message.ethAddress = String(object.ethAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryDelegateKeysByOrchestratorAddressResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} message QueryDelegateKeysByOrchestratorAddressResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDelegateKeysByOrchestratorAddressResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.validatorAddress = "";
          object.ethAddress = "";
        }
        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
          object.validatorAddress = message.validatorAddress;
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          object.ethAddress = message.ethAddress;
        return object;
      };

      /**
       * Converts this QueryDelegateKeysByOrchestratorAddressResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDelegateKeysByOrchestratorAddressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDelegateKeysByOrchestratorAddressResponse;
    })();

    v1.QueryPendingSendToEth = (function() {

      /**
       * Properties of a QueryPendingSendToEth.
       * @memberof gravity.v1
       * @interface IQueryPendingSendToEth
       * @property {string|null} [senderAddress] QueryPendingSendToEth senderAddress
       */

      /**
       * Constructs a new QueryPendingSendToEth.
       * @memberof gravity.v1
       * @classdesc Represents a QueryPendingSendToEth.
       * @implements IQueryPendingSendToEth
       * @constructor
       * @param {gravity.v1.IQueryPendingSendToEth=} [properties] Properties to set
       */
      function QueryPendingSendToEth(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPendingSendToEth senderAddress.
       * @member {string} senderAddress
       * @memberof gravity.v1.QueryPendingSendToEth
       * @instance
       */
      QueryPendingSendToEth.prototype.senderAddress = "";

      /**
       * Creates a new QueryPendingSendToEth instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {gravity.v1.IQueryPendingSendToEth=} [properties] Properties to set
       * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth instance
       */
      QueryPendingSendToEth.create = function create(properties) {
        return new QueryPendingSendToEth(properties);
      };

      /**
       * Encodes the specified QueryPendingSendToEth message. Does not implicitly {@link gravity.v1.QueryPendingSendToEth.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {gravity.v1.IQueryPendingSendToEth} message QueryPendingSendToEth message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingSendToEth.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.senderAddress != null && Object.hasOwnProperty.call(message, "senderAddress"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderAddress);
        return writer;
      };

      /**
       * Encodes the specified QueryPendingSendToEth message, length delimited. Does not implicitly {@link gravity.v1.QueryPendingSendToEth.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {gravity.v1.IQueryPendingSendToEth} message QueryPendingSendToEth message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingSendToEth.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPendingSendToEth message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingSendToEth.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryPendingSendToEth();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.senderAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPendingSendToEth message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingSendToEth.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPendingSendToEth message.
       * @function verify
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPendingSendToEth.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
          if (!$util.isString(message.senderAddress))
            return "senderAddress: string expected";
        return null;
      };

      /**
       * Creates a QueryPendingSendToEth message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth
       */
      QueryPendingSendToEth.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryPendingSendToEth)
          return object;
        let message = new $root.gravity.v1.QueryPendingSendToEth();
        if (object.senderAddress != null)
          message.senderAddress = String(object.senderAddress);
        return message;
      };

      /**
       * Creates a plain object from a QueryPendingSendToEth message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryPendingSendToEth
       * @static
       * @param {gravity.v1.QueryPendingSendToEth} message QueryPendingSendToEth
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPendingSendToEth.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults)
          object.senderAddress = "";
        if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
          object.senderAddress = message.senderAddress;
        return object;
      };

      /**
       * Converts this QueryPendingSendToEth to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryPendingSendToEth
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPendingSendToEth.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPendingSendToEth;
    })();

    v1.QueryPendingSendToEthResponse = (function() {

      /**
       * Properties of a QueryPendingSendToEthResponse.
       * @memberof gravity.v1
       * @interface IQueryPendingSendToEthResponse
       * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [transfersInBatches] QueryPendingSendToEthResponse transfersInBatches
       * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [unbatchedTransfers] QueryPendingSendToEthResponse unbatchedTransfers
       */

      /**
       * Constructs a new QueryPendingSendToEthResponse.
       * @memberof gravity.v1
       * @classdesc Represents a QueryPendingSendToEthResponse.
       * @implements IQueryPendingSendToEthResponse
       * @constructor
       * @param {gravity.v1.IQueryPendingSendToEthResponse=} [properties] Properties to set
       */
      function QueryPendingSendToEthResponse(properties) {
        this.transfersInBatches = [];
        this.unbatchedTransfers = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPendingSendToEthResponse transfersInBatches.
       * @member {Array.<gravity.v1.IOutgoingTransferTx>} transfersInBatches
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @instance
       */
      QueryPendingSendToEthResponse.prototype.transfersInBatches = $util.emptyArray;

      /**
       * QueryPendingSendToEthResponse unbatchedTransfers.
       * @member {Array.<gravity.v1.IOutgoingTransferTx>} unbatchedTransfers
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @instance
       */
      QueryPendingSendToEthResponse.prototype.unbatchedTransfers = $util.emptyArray;

      /**
       * Creates a new QueryPendingSendToEthResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {gravity.v1.IQueryPendingSendToEthResponse=} [properties] Properties to set
       * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse instance
       */
      QueryPendingSendToEthResponse.create = function create(properties) {
        return new QueryPendingSendToEthResponse(properties);
      };

      /**
       * Encodes the specified QueryPendingSendToEthResponse message. Does not implicitly {@link gravity.v1.QueryPendingSendToEthResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {gravity.v1.IQueryPendingSendToEthResponse} message QueryPendingSendToEthResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingSendToEthResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.transfersInBatches != null && message.transfersInBatches.length)
          for (let i = 0; i < message.transfersInBatches.length; ++i)
            $root.gravity.v1.OutgoingTransferTx.encode(message.transfersInBatches[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unbatchedTransfers != null && message.unbatchedTransfers.length)
          for (let i = 0; i < message.unbatchedTransfers.length; ++i)
            $root.gravity.v1.OutgoingTransferTx.encode(message.unbatchedTransfers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPendingSendToEthResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryPendingSendToEthResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {gravity.v1.IQueryPendingSendToEthResponse} message QueryPendingSendToEthResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingSendToEthResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPendingSendToEthResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingSendToEthResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryPendingSendToEthResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.transfersInBatches && message.transfersInBatches.length))
                message.transfersInBatches = [];
              message.transfersInBatches.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.unbatchedTransfers && message.unbatchedTransfers.length))
                message.unbatchedTransfers = [];
              message.unbatchedTransfers.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPendingSendToEthResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingSendToEthResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPendingSendToEthResponse message.
       * @function verify
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPendingSendToEthResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.transfersInBatches != null && message.hasOwnProperty("transfersInBatches")) {
          if (!Array.isArray(message.transfersInBatches))
            return "transfersInBatches: array expected";
          for (let i = 0; i < message.transfersInBatches.length; ++i) {
            let error = $root.gravity.v1.OutgoingTransferTx.verify(message.transfersInBatches[i]);
            if (error)
              return "transfersInBatches." + error;
          }
        }
        if (message.unbatchedTransfers != null && message.hasOwnProperty("unbatchedTransfers")) {
          if (!Array.isArray(message.unbatchedTransfers))
            return "unbatchedTransfers: array expected";
          for (let i = 0; i < message.unbatchedTransfers.length; ++i) {
            let error = $root.gravity.v1.OutgoingTransferTx.verify(message.unbatchedTransfers[i]);
            if (error)
              return "unbatchedTransfers." + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryPendingSendToEthResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse
       */
      QueryPendingSendToEthResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.QueryPendingSendToEthResponse)
          return object;
        let message = new $root.gravity.v1.QueryPendingSendToEthResponse();
        if (object.transfersInBatches) {
          if (!Array.isArray(object.transfersInBatches))
            throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.transfersInBatches: array expected");
          message.transfersInBatches = [];
          for (let i = 0; i < object.transfersInBatches.length; ++i) {
            if (typeof object.transfersInBatches[i] !== "object")
              throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.transfersInBatches: object expected");
            message.transfersInBatches[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.transfersInBatches[i]);
          }
        }
        if (object.unbatchedTransfers) {
          if (!Array.isArray(object.unbatchedTransfers))
            throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.unbatchedTransfers: array expected");
          message.unbatchedTransfers = [];
          for (let i = 0; i < object.unbatchedTransfers.length; ++i) {
            if (typeof object.unbatchedTransfers[i] !== "object")
              throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.unbatchedTransfers: object expected");
            message.unbatchedTransfers[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.unbatchedTransfers[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPendingSendToEthResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @static
       * @param {gravity.v1.QueryPendingSendToEthResponse} message QueryPendingSendToEthResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPendingSendToEthResponse.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.transfersInBatches = [];
          object.unbatchedTransfers = [];
        }
        if (message.transfersInBatches && message.transfersInBatches.length) {
          object.transfersInBatches = [];
          for (let j = 0; j < message.transfersInBatches.length; ++j)
            object.transfersInBatches[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.transfersInBatches[j], options);
        }
        if (message.unbatchedTransfers && message.unbatchedTransfers.length) {
          object.unbatchedTransfers = [];
          for (let j = 0; j < message.unbatchedTransfers.length; ++j)
            object.unbatchedTransfers[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.unbatchedTransfers[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryPendingSendToEthResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.QueryPendingSendToEthResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPendingSendToEthResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPendingSendToEthResponse;
    })();

    /**
     * SignType enum.
     * @name gravity.v1.SignType
     * @enum {number}
     * @property {number} SIGN_TYPE_UNSPECIFIED=0 SIGN_TYPE_UNSPECIFIED value
     * @property {number} SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE=1 SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE value
     * @property {number} SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH=2 SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH value
     */
    v1.SignType = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "SIGN_TYPE_UNSPECIFIED"] = 0;
      values[valuesById[1] = "SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE"] = 1;
      values[valuesById[2] = "SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH"] = 2;
      return values;
    })();

    v1.Params = (function() {

      /**
       * Properties of a Params.
       * @memberof gravity.v1
       * @interface IParams
       * @property {string|null} [gravityId] Params gravityId
       * @property {string|null} [contractSourceHash] Params contractSourceHash
       * @property {string|null} [bridgeEthereumAddress] Params bridgeEthereumAddress
       * @property {number|Long|null} [bridgeChainId] Params bridgeChainId
       * @property {number|Long|null} [signedValsetsWindow] Params signedValsetsWindow
       * @property {number|Long|null} [signedBatchesWindow] Params signedBatchesWindow
       * @property {number|Long|null} [signedLogicCallsWindow] Params signedLogicCallsWindow
       * @property {number|Long|null} [targetBatchTimeout] Params targetBatchTimeout
       * @property {number|Long|null} [averageBlockTime] Params averageBlockTime
       * @property {number|Long|null} [averageEthereumBlockTime] Params averageEthereumBlockTime
       * @property {Uint8Array|null} [slashFractionValset] Params slashFractionValset
       * @property {Uint8Array|null} [slashFractionBatch] Params slashFractionBatch
       * @property {Uint8Array|null} [slashFractionLogicCall] Params slashFractionLogicCall
       * @property {number|Long|null} [unbondSlashingValsetsWindow] Params unbondSlashingValsetsWindow
       * @property {Uint8Array|null} [slashFractionBadEthSignature] Params slashFractionBadEthSignature
       * @property {cosmos.base.v1beta1.ICoin|null} [valsetReward] Params valsetReward
       * @property {boolean|null} [bridgeActive] Params bridgeActive
       * @property {Array.<string>|null} [ethereumBlacklist] Params ethereumBlacklist
       */

      /**
       * Constructs a new Params.
       * @memberof gravity.v1
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {gravity.v1.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.ethereumBlacklist = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params gravityId.
       * @member {string} gravityId
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.gravityId = "";

      /**
       * Params contractSourceHash.
       * @member {string} contractSourceHash
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.contractSourceHash = "";

      /**
       * Params bridgeEthereumAddress.
       * @member {string} bridgeEthereumAddress
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.bridgeEthereumAddress = "";

      /**
       * Params bridgeChainId.
       * @member {number|Long} bridgeChainId
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.bridgeChainId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params signedValsetsWindow.
       * @member {number|Long} signedValsetsWindow
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.signedValsetsWindow = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params signedBatchesWindow.
       * @member {number|Long} signedBatchesWindow
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.signedBatchesWindow = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params signedLogicCallsWindow.
       * @member {number|Long} signedLogicCallsWindow
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.signedLogicCallsWindow = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params targetBatchTimeout.
       * @member {number|Long} targetBatchTimeout
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.targetBatchTimeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params averageBlockTime.
       * @member {number|Long} averageBlockTime
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.averageBlockTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params averageEthereumBlockTime.
       * @member {number|Long} averageEthereumBlockTime
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.averageEthereumBlockTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params slashFractionValset.
       * @member {Uint8Array} slashFractionValset
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.slashFractionValset = $util.newBuffer([]);

      /**
       * Params slashFractionBatch.
       * @member {Uint8Array} slashFractionBatch
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.slashFractionBatch = $util.newBuffer([]);

      /**
       * Params slashFractionLogicCall.
       * @member {Uint8Array} slashFractionLogicCall
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.slashFractionLogicCall = $util.newBuffer([]);

      /**
       * Params unbondSlashingValsetsWindow.
       * @member {number|Long} unbondSlashingValsetsWindow
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.unbondSlashingValsetsWindow = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Params slashFractionBadEthSignature.
       * @member {Uint8Array} slashFractionBadEthSignature
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.slashFractionBadEthSignature = $util.newBuffer([]);

      /**
       * Params valsetReward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} valsetReward
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.valsetReward = null;

      /**
       * Params bridgeActive.
       * @member {boolean} bridgeActive
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.bridgeActive = false;

      /**
       * Params ethereumBlacklist.
       * @member {Array.<string>} ethereumBlacklist
       * @memberof gravity.v1.Params
       * @instance
       */
      Params.prototype.ethereumBlacklist = $util.emptyArray;

      /**
       * Creates a new Params instance using the specified properties.
       * @function create
       * @memberof gravity.v1.Params
       * @static
       * @param {gravity.v1.IParams=} [properties] Properties to set
       * @returns {gravity.v1.Params} Params instance
       */
      Params.create = function create(properties) {
        return new Params(properties);
      };

      /**
       * Encodes the specified Params message. Does not implicitly {@link gravity.v1.Params.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.Params
       * @static
       * @param {gravity.v1.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.gravityId != null && Object.hasOwnProperty.call(message, "gravityId"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.gravityId);
        if (message.contractSourceHash != null && Object.hasOwnProperty.call(message, "contractSourceHash"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.contractSourceHash);
        if (message.bridgeEthereumAddress != null && Object.hasOwnProperty.call(message, "bridgeEthereumAddress"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.bridgeEthereumAddress);
        if (message.bridgeChainId != null && Object.hasOwnProperty.call(message, "bridgeChainId"))
          writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.bridgeChainId);
        if (message.signedValsetsWindow != null && Object.hasOwnProperty.call(message, "signedValsetsWindow"))
          writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.signedValsetsWindow);
        if (message.signedBatchesWindow != null && Object.hasOwnProperty.call(message, "signedBatchesWindow"))
          writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.signedBatchesWindow);
        if (message.signedLogicCallsWindow != null && Object.hasOwnProperty.call(message, "signedLogicCallsWindow"))
          writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.signedLogicCallsWindow);
        if (message.targetBatchTimeout != null && Object.hasOwnProperty.call(message, "targetBatchTimeout"))
          writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.targetBatchTimeout);
        if (message.averageBlockTime != null && Object.hasOwnProperty.call(message, "averageBlockTime"))
          writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.averageBlockTime);
        if (message.averageEthereumBlockTime != null && Object.hasOwnProperty.call(message, "averageEthereumBlockTime"))
          writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.averageEthereumBlockTime);
        if (message.slashFractionValset != null && Object.hasOwnProperty.call(message, "slashFractionValset"))
          writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.slashFractionValset);
        if (message.slashFractionBatch != null && Object.hasOwnProperty.call(message, "slashFractionBatch"))
          writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.slashFractionBatch);
        if (message.slashFractionLogicCall != null && Object.hasOwnProperty.call(message, "slashFractionLogicCall"))
          writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.slashFractionLogicCall);
        if (message.unbondSlashingValsetsWindow != null && Object.hasOwnProperty.call(message, "unbondSlashingValsetsWindow"))
          writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.unbondSlashingValsetsWindow);
        if (message.slashFractionBadEthSignature != null && Object.hasOwnProperty.call(message, "slashFractionBadEthSignature"))
          writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.slashFractionBadEthSignature);
        if (message.valsetReward != null && Object.hasOwnProperty.call(message, "valsetReward"))
          $root.cosmos.base.v1beta1.Coin.encode(message.valsetReward, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.bridgeActive != null && Object.hasOwnProperty.call(message, "bridgeActive"))
          writer.uint32(/* id 18, wireType 0 =*/144).bool(message.bridgeActive);
        if (message.ethereumBlacklist != null && message.ethereumBlacklist.length)
          for (let i = 0; i < message.ethereumBlacklist.length; ++i)
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.ethereumBlacklist[i]);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link gravity.v1.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.Params
       * @static
       * @param {gravity.v1.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gravityId = reader.string();
              break;
            case 2:
              message.contractSourceHash = reader.string();
              break;
            case 4:
              message.bridgeEthereumAddress = reader.string();
              break;
            case 5:
              message.bridgeChainId = reader.uint64();
              break;
            case 6:
              message.signedValsetsWindow = reader.uint64();
              break;
            case 7:
              message.signedBatchesWindow = reader.uint64();
              break;
            case 8:
              message.signedLogicCallsWindow = reader.uint64();
              break;
            case 9:
              message.targetBatchTimeout = reader.uint64();
              break;
            case 10:
              message.averageBlockTime = reader.uint64();
              break;
            case 11:
              message.averageEthereumBlockTime = reader.uint64();
              break;
            case 12:
              message.slashFractionValset = reader.bytes();
              break;
            case 13:
              message.slashFractionBatch = reader.bytes();
              break;
            case 14:
              message.slashFractionLogicCall = reader.bytes();
              break;
            case 15:
              message.unbondSlashingValsetsWindow = reader.uint64();
              break;
            case 16:
              message.slashFractionBadEthSignature = reader.bytes();
              break;
            case 17:
              message.valsetReward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 18:
              message.bridgeActive = reader.bool();
              break;
            case 19:
              if (!(message.ethereumBlacklist && message.ethereumBlacklist.length))
                message.ethereumBlacklist = [];
              message.ethereumBlacklist.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof gravity.v1.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.gravityId != null && message.hasOwnProperty("gravityId"))
          if (!$util.isString(message.gravityId))
            return "gravityId: string expected";
        if (message.contractSourceHash != null && message.hasOwnProperty("contractSourceHash"))
          if (!$util.isString(message.contractSourceHash))
            return "contractSourceHash: string expected";
        if (message.bridgeEthereumAddress != null && message.hasOwnProperty("bridgeEthereumAddress"))
          if (!$util.isString(message.bridgeEthereumAddress))
            return "bridgeEthereumAddress: string expected";
        if (message.bridgeChainId != null && message.hasOwnProperty("bridgeChainId"))
          if (!$util.isInteger(message.bridgeChainId) && !(message.bridgeChainId && $util.isInteger(message.bridgeChainId.low) && $util.isInteger(message.bridgeChainId.high)))
            return "bridgeChainId: integer|Long expected";
        if (message.signedValsetsWindow != null && message.hasOwnProperty("signedValsetsWindow"))
          if (!$util.isInteger(message.signedValsetsWindow) && !(message.signedValsetsWindow && $util.isInteger(message.signedValsetsWindow.low) && $util.isInteger(message.signedValsetsWindow.high)))
            return "signedValsetsWindow: integer|Long expected";
        if (message.signedBatchesWindow != null && message.hasOwnProperty("signedBatchesWindow"))
          if (!$util.isInteger(message.signedBatchesWindow) && !(message.signedBatchesWindow && $util.isInteger(message.signedBatchesWindow.low) && $util.isInteger(message.signedBatchesWindow.high)))
            return "signedBatchesWindow: integer|Long expected";
        if (message.signedLogicCallsWindow != null && message.hasOwnProperty("signedLogicCallsWindow"))
          if (!$util.isInteger(message.signedLogicCallsWindow) && !(message.signedLogicCallsWindow && $util.isInteger(message.signedLogicCallsWindow.low) && $util.isInteger(message.signedLogicCallsWindow.high)))
            return "signedLogicCallsWindow: integer|Long expected";
        if (message.targetBatchTimeout != null && message.hasOwnProperty("targetBatchTimeout"))
          if (!$util.isInteger(message.targetBatchTimeout) && !(message.targetBatchTimeout && $util.isInteger(message.targetBatchTimeout.low) && $util.isInteger(message.targetBatchTimeout.high)))
            return "targetBatchTimeout: integer|Long expected";
        if (message.averageBlockTime != null && message.hasOwnProperty("averageBlockTime"))
          if (!$util.isInteger(message.averageBlockTime) && !(message.averageBlockTime && $util.isInteger(message.averageBlockTime.low) && $util.isInteger(message.averageBlockTime.high)))
            return "averageBlockTime: integer|Long expected";
        if (message.averageEthereumBlockTime != null && message.hasOwnProperty("averageEthereumBlockTime"))
          if (!$util.isInteger(message.averageEthereumBlockTime) && !(message.averageEthereumBlockTime && $util.isInteger(message.averageEthereumBlockTime.low) && $util.isInteger(message.averageEthereumBlockTime.high)))
            return "averageEthereumBlockTime: integer|Long expected";
        if (message.slashFractionValset != null && message.hasOwnProperty("slashFractionValset"))
          if (!(message.slashFractionValset && typeof message.slashFractionValset.length === "number" || $util.isString(message.slashFractionValset)))
            return "slashFractionValset: buffer expected";
        if (message.slashFractionBatch != null && message.hasOwnProperty("slashFractionBatch"))
          if (!(message.slashFractionBatch && typeof message.slashFractionBatch.length === "number" || $util.isString(message.slashFractionBatch)))
            return "slashFractionBatch: buffer expected";
        if (message.slashFractionLogicCall != null && message.hasOwnProperty("slashFractionLogicCall"))
          if (!(message.slashFractionLogicCall && typeof message.slashFractionLogicCall.length === "number" || $util.isString(message.slashFractionLogicCall)))
            return "slashFractionLogicCall: buffer expected";
        if (message.unbondSlashingValsetsWindow != null && message.hasOwnProperty("unbondSlashingValsetsWindow"))
          if (!$util.isInteger(message.unbondSlashingValsetsWindow) && !(message.unbondSlashingValsetsWindow && $util.isInteger(message.unbondSlashingValsetsWindow.low) && $util.isInteger(message.unbondSlashingValsetsWindow.high)))
            return "unbondSlashingValsetsWindow: integer|Long expected";
        if (message.slashFractionBadEthSignature != null && message.hasOwnProperty("slashFractionBadEthSignature"))
          if (!(message.slashFractionBadEthSignature && typeof message.slashFractionBadEthSignature.length === "number" || $util.isString(message.slashFractionBadEthSignature)))
            return "slashFractionBadEthSignature: buffer expected";
        if (message.valsetReward != null && message.hasOwnProperty("valsetReward")) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.valsetReward);
          if (error)
            return "valsetReward." + error;
        }
        if (message.bridgeActive != null && message.hasOwnProperty("bridgeActive"))
          if (typeof message.bridgeActive !== "boolean")
            return "bridgeActive: boolean expected";
        if (message.ethereumBlacklist != null && message.hasOwnProperty("ethereumBlacklist")) {
          if (!Array.isArray(message.ethereumBlacklist))
            return "ethereumBlacklist: array expected";
          for (let i = 0; i < message.ethereumBlacklist.length; ++i)
            if (!$util.isString(message.ethereumBlacklist[i]))
              return "ethereumBlacklist: string[] expected";
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.Params)
          return object;
        let message = new $root.gravity.v1.Params();
        if (object.gravityId != null)
          message.gravityId = String(object.gravityId);
        if (object.contractSourceHash != null)
          message.contractSourceHash = String(object.contractSourceHash);
        if (object.bridgeEthereumAddress != null)
          message.bridgeEthereumAddress = String(object.bridgeEthereumAddress);
        if (object.bridgeChainId != null)
          if ($util.Long)
            (message.bridgeChainId = $util.Long.fromValue(object.bridgeChainId)).unsigned = true;
          else if (typeof object.bridgeChainId === "string")
            message.bridgeChainId = parseInt(object.bridgeChainId, 10);
          else if (typeof object.bridgeChainId === "number")
            message.bridgeChainId = object.bridgeChainId;
          else if (typeof object.bridgeChainId === "object")
            message.bridgeChainId = new $util.LongBits(object.bridgeChainId.low >>> 0, object.bridgeChainId.high >>> 0).toNumber(true);
        if (object.signedValsetsWindow != null)
          if ($util.Long)
            (message.signedValsetsWindow = $util.Long.fromValue(object.signedValsetsWindow)).unsigned = true;
          else if (typeof object.signedValsetsWindow === "string")
            message.signedValsetsWindow = parseInt(object.signedValsetsWindow, 10);
          else if (typeof object.signedValsetsWindow === "number")
            message.signedValsetsWindow = object.signedValsetsWindow;
          else if (typeof object.signedValsetsWindow === "object")
            message.signedValsetsWindow = new $util.LongBits(object.signedValsetsWindow.low >>> 0, object.signedValsetsWindow.high >>> 0).toNumber(true);
        if (object.signedBatchesWindow != null)
          if ($util.Long)
            (message.signedBatchesWindow = $util.Long.fromValue(object.signedBatchesWindow)).unsigned = true;
          else if (typeof object.signedBatchesWindow === "string")
            message.signedBatchesWindow = parseInt(object.signedBatchesWindow, 10);
          else if (typeof object.signedBatchesWindow === "number")
            message.signedBatchesWindow = object.signedBatchesWindow;
          else if (typeof object.signedBatchesWindow === "object")
            message.signedBatchesWindow = new $util.LongBits(object.signedBatchesWindow.low >>> 0, object.signedBatchesWindow.high >>> 0).toNumber(true);
        if (object.signedLogicCallsWindow != null)
          if ($util.Long)
            (message.signedLogicCallsWindow = $util.Long.fromValue(object.signedLogicCallsWindow)).unsigned = true;
          else if (typeof object.signedLogicCallsWindow === "string")
            message.signedLogicCallsWindow = parseInt(object.signedLogicCallsWindow, 10);
          else if (typeof object.signedLogicCallsWindow === "number")
            message.signedLogicCallsWindow = object.signedLogicCallsWindow;
          else if (typeof object.signedLogicCallsWindow === "object")
            message.signedLogicCallsWindow = new $util.LongBits(object.signedLogicCallsWindow.low >>> 0, object.signedLogicCallsWindow.high >>> 0).toNumber(true);
        if (object.targetBatchTimeout != null)
          if ($util.Long)
            (message.targetBatchTimeout = $util.Long.fromValue(object.targetBatchTimeout)).unsigned = true;
          else if (typeof object.targetBatchTimeout === "string")
            message.targetBatchTimeout = parseInt(object.targetBatchTimeout, 10);
          else if (typeof object.targetBatchTimeout === "number")
            message.targetBatchTimeout = object.targetBatchTimeout;
          else if (typeof object.targetBatchTimeout === "object")
            message.targetBatchTimeout = new $util.LongBits(object.targetBatchTimeout.low >>> 0, object.targetBatchTimeout.high >>> 0).toNumber(true);
        if (object.averageBlockTime != null)
          if ($util.Long)
            (message.averageBlockTime = $util.Long.fromValue(object.averageBlockTime)).unsigned = true;
          else if (typeof object.averageBlockTime === "string")
            message.averageBlockTime = parseInt(object.averageBlockTime, 10);
          else if (typeof object.averageBlockTime === "number")
            message.averageBlockTime = object.averageBlockTime;
          else if (typeof object.averageBlockTime === "object")
            message.averageBlockTime = new $util.LongBits(object.averageBlockTime.low >>> 0, object.averageBlockTime.high >>> 0).toNumber(true);
        if (object.averageEthereumBlockTime != null)
          if ($util.Long)
            (message.averageEthereumBlockTime = $util.Long.fromValue(object.averageEthereumBlockTime)).unsigned = true;
          else if (typeof object.averageEthereumBlockTime === "string")
            message.averageEthereumBlockTime = parseInt(object.averageEthereumBlockTime, 10);
          else if (typeof object.averageEthereumBlockTime === "number")
            message.averageEthereumBlockTime = object.averageEthereumBlockTime;
          else if (typeof object.averageEthereumBlockTime === "object")
            message.averageEthereumBlockTime = new $util.LongBits(object.averageEthereumBlockTime.low >>> 0, object.averageEthereumBlockTime.high >>> 0).toNumber(true);
        if (object.slashFractionValset != null)
          if (typeof object.slashFractionValset === "string")
            $util.base64.decode(object.slashFractionValset, message.slashFractionValset = $util.newBuffer($util.base64.length(object.slashFractionValset)), 0);
          else if (object.slashFractionValset.length)
            message.slashFractionValset = object.slashFractionValset;
        if (object.slashFractionBatch != null)
          if (typeof object.slashFractionBatch === "string")
            $util.base64.decode(object.slashFractionBatch, message.slashFractionBatch = $util.newBuffer($util.base64.length(object.slashFractionBatch)), 0);
          else if (object.slashFractionBatch.length)
            message.slashFractionBatch = object.slashFractionBatch;
        if (object.slashFractionLogicCall != null)
          if (typeof object.slashFractionLogicCall === "string")
            $util.base64.decode(object.slashFractionLogicCall, message.slashFractionLogicCall = $util.newBuffer($util.base64.length(object.slashFractionLogicCall)), 0);
          else if (object.slashFractionLogicCall.length)
            message.slashFractionLogicCall = object.slashFractionLogicCall;
        if (object.unbondSlashingValsetsWindow != null)
          if ($util.Long)
            (message.unbondSlashingValsetsWindow = $util.Long.fromValue(object.unbondSlashingValsetsWindow)).unsigned = true;
          else if (typeof object.unbondSlashingValsetsWindow === "string")
            message.unbondSlashingValsetsWindow = parseInt(object.unbondSlashingValsetsWindow, 10);
          else if (typeof object.unbondSlashingValsetsWindow === "number")
            message.unbondSlashingValsetsWindow = object.unbondSlashingValsetsWindow;
          else if (typeof object.unbondSlashingValsetsWindow === "object")
            message.unbondSlashingValsetsWindow = new $util.LongBits(object.unbondSlashingValsetsWindow.low >>> 0, object.unbondSlashingValsetsWindow.high >>> 0).toNumber(true);
        if (object.slashFractionBadEthSignature != null)
          if (typeof object.slashFractionBadEthSignature === "string")
            $util.base64.decode(object.slashFractionBadEthSignature, message.slashFractionBadEthSignature = $util.newBuffer($util.base64.length(object.slashFractionBadEthSignature)), 0);
          else if (object.slashFractionBadEthSignature.length)
            message.slashFractionBadEthSignature = object.slashFractionBadEthSignature;
        if (object.valsetReward != null) {
          if (typeof object.valsetReward !== "object")
            throw TypeError(".gravity.v1.Params.valsetReward: object expected");
          message.valsetReward = $root.cosmos.base.v1beta1.Coin.fromObject(object.valsetReward);
        }
        if (object.bridgeActive != null)
          message.bridgeActive = Boolean(object.bridgeActive);
        if (object.ethereumBlacklist) {
          if (!Array.isArray(object.ethereumBlacklist))
            throw TypeError(".gravity.v1.Params.ethereumBlacklist: array expected");
          message.ethereumBlacklist = [];
          for (let i = 0; i < object.ethereumBlacklist.length; ++i)
            message.ethereumBlacklist[i] = String(object.ethereumBlacklist[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.Params
       * @static
       * @param {gravity.v1.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.ethereumBlacklist = [];
        if (options.defaults) {
          object.gravityId = "";
          object.contractSourceHash = "";
          object.bridgeEthereumAddress = "";
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.bridgeChainId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.bridgeChainId = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.signedValsetsWindow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.signedValsetsWindow = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.signedBatchesWindow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.signedBatchesWindow = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.signedLogicCallsWindow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.signedLogicCallsWindow = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.targetBatchTimeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.targetBatchTimeout = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.averageBlockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.averageBlockTime = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.averageEthereumBlockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.averageEthereumBlockTime = options.longs === String ? "0" : 0;
          if (options.bytes === String)
            object.slashFractionValset = "";
          else {
            object.slashFractionValset = [];
            if (options.bytes !== Array)
              object.slashFractionValset = $util.newBuffer(object.slashFractionValset);
          }
          if (options.bytes === String)
            object.slashFractionBatch = "";
          else {
            object.slashFractionBatch = [];
            if (options.bytes !== Array)
              object.slashFractionBatch = $util.newBuffer(object.slashFractionBatch);
          }
          if (options.bytes === String)
            object.slashFractionLogicCall = "";
          else {
            object.slashFractionLogicCall = [];
            if (options.bytes !== Array)
              object.slashFractionLogicCall = $util.newBuffer(object.slashFractionLogicCall);
          }
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.unbondSlashingValsetsWindow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.unbondSlashingValsetsWindow = options.longs === String ? "0" : 0;
          if (options.bytes === String)
            object.slashFractionBadEthSignature = "";
          else {
            object.slashFractionBadEthSignature = [];
            if (options.bytes !== Array)
              object.slashFractionBadEthSignature = $util.newBuffer(object.slashFractionBadEthSignature);
          }
          object.valsetReward = null;
          object.bridgeActive = false;
        }
        if (message.gravityId != null && message.hasOwnProperty("gravityId"))
          object.gravityId = message.gravityId;
        if (message.contractSourceHash != null && message.hasOwnProperty("contractSourceHash"))
          object.contractSourceHash = message.contractSourceHash;
        if (message.bridgeEthereumAddress != null && message.hasOwnProperty("bridgeEthereumAddress"))
          object.bridgeEthereumAddress = message.bridgeEthereumAddress;
        if (message.bridgeChainId != null && message.hasOwnProperty("bridgeChainId"))
          if (typeof message.bridgeChainId === "number")
            object.bridgeChainId = options.longs === String ? String(message.bridgeChainId) : message.bridgeChainId;
          else
            object.bridgeChainId = options.longs === String ? $util.Long.prototype.toString.call(message.bridgeChainId) : options.longs === Number ? new $util.LongBits(message.bridgeChainId.low >>> 0, message.bridgeChainId.high >>> 0).toNumber(true) : message.bridgeChainId;
        if (message.signedValsetsWindow != null && message.hasOwnProperty("signedValsetsWindow"))
          if (typeof message.signedValsetsWindow === "number")
            object.signedValsetsWindow = options.longs === String ? String(message.signedValsetsWindow) : message.signedValsetsWindow;
          else
            object.signedValsetsWindow = options.longs === String ? $util.Long.prototype.toString.call(message.signedValsetsWindow) : options.longs === Number ? new $util.LongBits(message.signedValsetsWindow.low >>> 0, message.signedValsetsWindow.high >>> 0).toNumber(true) : message.signedValsetsWindow;
        if (message.signedBatchesWindow != null && message.hasOwnProperty("signedBatchesWindow"))
          if (typeof message.signedBatchesWindow === "number")
            object.signedBatchesWindow = options.longs === String ? String(message.signedBatchesWindow) : message.signedBatchesWindow;
          else
            object.signedBatchesWindow = options.longs === String ? $util.Long.prototype.toString.call(message.signedBatchesWindow) : options.longs === Number ? new $util.LongBits(message.signedBatchesWindow.low >>> 0, message.signedBatchesWindow.high >>> 0).toNumber(true) : message.signedBatchesWindow;
        if (message.signedLogicCallsWindow != null && message.hasOwnProperty("signedLogicCallsWindow"))
          if (typeof message.signedLogicCallsWindow === "number")
            object.signedLogicCallsWindow = options.longs === String ? String(message.signedLogicCallsWindow) : message.signedLogicCallsWindow;
          else
            object.signedLogicCallsWindow = options.longs === String ? $util.Long.prototype.toString.call(message.signedLogicCallsWindow) : options.longs === Number ? new $util.LongBits(message.signedLogicCallsWindow.low >>> 0, message.signedLogicCallsWindow.high >>> 0).toNumber(true) : message.signedLogicCallsWindow;
        if (message.targetBatchTimeout != null && message.hasOwnProperty("targetBatchTimeout"))
          if (typeof message.targetBatchTimeout === "number")
            object.targetBatchTimeout = options.longs === String ? String(message.targetBatchTimeout) : message.targetBatchTimeout;
          else
            object.targetBatchTimeout = options.longs === String ? $util.Long.prototype.toString.call(message.targetBatchTimeout) : options.longs === Number ? new $util.LongBits(message.targetBatchTimeout.low >>> 0, message.targetBatchTimeout.high >>> 0).toNumber(true) : message.targetBatchTimeout;
        if (message.averageBlockTime != null && message.hasOwnProperty("averageBlockTime"))
          if (typeof message.averageBlockTime === "number")
            object.averageBlockTime = options.longs === String ? String(message.averageBlockTime) : message.averageBlockTime;
          else
            object.averageBlockTime = options.longs === String ? $util.Long.prototype.toString.call(message.averageBlockTime) : options.longs === Number ? new $util.LongBits(message.averageBlockTime.low >>> 0, message.averageBlockTime.high >>> 0).toNumber(true) : message.averageBlockTime;
        if (message.averageEthereumBlockTime != null && message.hasOwnProperty("averageEthereumBlockTime"))
          if (typeof message.averageEthereumBlockTime === "number")
            object.averageEthereumBlockTime = options.longs === String ? String(message.averageEthereumBlockTime) : message.averageEthereumBlockTime;
          else
            object.averageEthereumBlockTime = options.longs === String ? $util.Long.prototype.toString.call(message.averageEthereumBlockTime) : options.longs === Number ? new $util.LongBits(message.averageEthereumBlockTime.low >>> 0, message.averageEthereumBlockTime.high >>> 0).toNumber(true) : message.averageEthereumBlockTime;
        if (message.slashFractionValset != null && message.hasOwnProperty("slashFractionValset"))
          object.slashFractionValset = options.bytes === String ? $util.base64.encode(message.slashFractionValset, 0, message.slashFractionValset.length) : options.bytes === Array ? Array.prototype.slice.call(message.slashFractionValset) : message.slashFractionValset;
        if (message.slashFractionBatch != null && message.hasOwnProperty("slashFractionBatch"))
          object.slashFractionBatch = options.bytes === String ? $util.base64.encode(message.slashFractionBatch, 0, message.slashFractionBatch.length) : options.bytes === Array ? Array.prototype.slice.call(message.slashFractionBatch) : message.slashFractionBatch;
        if (message.slashFractionLogicCall != null && message.hasOwnProperty("slashFractionLogicCall"))
          object.slashFractionLogicCall = options.bytes === String ? $util.base64.encode(message.slashFractionLogicCall, 0, message.slashFractionLogicCall.length) : options.bytes === Array ? Array.prototype.slice.call(message.slashFractionLogicCall) : message.slashFractionLogicCall;
        if (message.unbondSlashingValsetsWindow != null && message.hasOwnProperty("unbondSlashingValsetsWindow"))
          if (typeof message.unbondSlashingValsetsWindow === "number")
            object.unbondSlashingValsetsWindow = options.longs === String ? String(message.unbondSlashingValsetsWindow) : message.unbondSlashingValsetsWindow;
          else
            object.unbondSlashingValsetsWindow = options.longs === String ? $util.Long.prototype.toString.call(message.unbondSlashingValsetsWindow) : options.longs === Number ? new $util.LongBits(message.unbondSlashingValsetsWindow.low >>> 0, message.unbondSlashingValsetsWindow.high >>> 0).toNumber(true) : message.unbondSlashingValsetsWindow;
        if (message.slashFractionBadEthSignature != null && message.hasOwnProperty("slashFractionBadEthSignature"))
          object.slashFractionBadEthSignature = options.bytes === String ? $util.base64.encode(message.slashFractionBadEthSignature, 0, message.slashFractionBadEthSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.slashFractionBadEthSignature) : message.slashFractionBadEthSignature;
        if (message.valsetReward != null && message.hasOwnProperty("valsetReward"))
          object.valsetReward = $root.cosmos.base.v1beta1.Coin.toObject(message.valsetReward, options);
        if (message.bridgeActive != null && message.hasOwnProperty("bridgeActive"))
          object.bridgeActive = message.bridgeActive;
        if (message.ethereumBlacklist && message.ethereumBlacklist.length) {
          object.ethereumBlacklist = [];
          for (let j = 0; j < message.ethereumBlacklist.length; ++j)
            object.ethereumBlacklist[j] = message.ethereumBlacklist[j];
        }
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof gravity.v1.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    v1.GenesisState = (function() {

      /**
       * Properties of a GenesisState.
       * @memberof gravity.v1
       * @interface IGenesisState
       * @property {gravity.v1.IParams|null} [params] GenesisState params
       * @property {gravity.v1.IGravityNonces|null} [gravityNonces] GenesisState gravityNonces
       * @property {Array.<gravity.v1.IValset>|null} [valsets] GenesisState valsets
       * @property {Array.<gravity.v1.IMsgValsetConfirm>|null} [valsetConfirms] GenesisState valsetConfirms
       * @property {Array.<gravity.v1.IOutgoingTxBatch>|null} [batches] GenesisState batches
       * @property {Array.<gravity.v1.IMsgConfirmBatch>|null} [batchConfirms] GenesisState batchConfirms
       * @property {Array.<gravity.v1.IOutgoingLogicCall>|null} [logicCalls] GenesisState logicCalls
       * @property {Array.<gravity.v1.IMsgConfirmLogicCall>|null} [logicCallConfirms] GenesisState logicCallConfirms
       * @property {Array.<gravity.v1.IAttestation>|null} [attestations] GenesisState attestations
       * @property {Array.<gravity.v1.IMsgSetOrchestratorAddress>|null} [delegateKeys] GenesisState delegateKeys
       * @property {Array.<gravity.v1.IERC20ToDenom>|null} [erc20ToDenoms] GenesisState erc20ToDenoms
       * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [unbatchedTransfers] GenesisState unbatchedTransfers
       */

      /**
       * Constructs a new GenesisState.
       * @memberof gravity.v1
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {gravity.v1.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.valsets = [];
        this.valsetConfirms = [];
        this.batches = [];
        this.batchConfirms = [];
        this.logicCalls = [];
        this.logicCallConfirms = [];
        this.attestations = [];
        this.delegateKeys = [];
        this.erc20ToDenoms = [];
        this.unbatchedTransfers = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {gravity.v1.IParams|null|undefined} params
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState gravityNonces.
       * @member {gravity.v1.IGravityNonces|null|undefined} gravityNonces
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.gravityNonces = null;

      /**
       * GenesisState valsets.
       * @member {Array.<gravity.v1.IValset>} valsets
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.valsets = $util.emptyArray;

      /**
       * GenesisState valsetConfirms.
       * @member {Array.<gravity.v1.IMsgValsetConfirm>} valsetConfirms
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.valsetConfirms = $util.emptyArray;

      /**
       * GenesisState batches.
       * @member {Array.<gravity.v1.IOutgoingTxBatch>} batches
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.batches = $util.emptyArray;

      /**
       * GenesisState batchConfirms.
       * @member {Array.<gravity.v1.IMsgConfirmBatch>} batchConfirms
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.batchConfirms = $util.emptyArray;

      /**
       * GenesisState logicCalls.
       * @member {Array.<gravity.v1.IOutgoingLogicCall>} logicCalls
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.logicCalls = $util.emptyArray;

      /**
       * GenesisState logicCallConfirms.
       * @member {Array.<gravity.v1.IMsgConfirmLogicCall>} logicCallConfirms
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.logicCallConfirms = $util.emptyArray;

      /**
       * GenesisState attestations.
       * @member {Array.<gravity.v1.IAttestation>} attestations
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.attestations = $util.emptyArray;

      /**
       * GenesisState delegateKeys.
       * @member {Array.<gravity.v1.IMsgSetOrchestratorAddress>} delegateKeys
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.delegateKeys = $util.emptyArray;

      /**
       * GenesisState erc20ToDenoms.
       * @member {Array.<gravity.v1.IERC20ToDenom>} erc20ToDenoms
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.erc20ToDenoms = $util.emptyArray;

      /**
       * GenesisState unbatchedTransfers.
       * @member {Array.<gravity.v1.IOutgoingTransferTx>} unbatchedTransfers
       * @memberof gravity.v1.GenesisState
       * @instance
       */
      GenesisState.prototype.unbatchedTransfers = $util.emptyArray;

      /**
       * Creates a new GenesisState instance using the specified properties.
       * @function create
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {gravity.v1.IGenesisState=} [properties] Properties to set
       * @returns {gravity.v1.GenesisState} GenesisState instance
       */
      GenesisState.create = function create(properties) {
        return new GenesisState(properties);
      };

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link gravity.v1.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {gravity.v1.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, "params"))
          $root.gravity.v1.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.gravityNonces != null && Object.hasOwnProperty.call(message, "gravityNonces"))
          $root.gravity.v1.GravityNonces.encode(message.gravityNonces, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.valsets != null && message.valsets.length)
          for (let i = 0; i < message.valsets.length; ++i)
            $root.gravity.v1.Valset.encode(message.valsets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.valsetConfirms != null && message.valsetConfirms.length)
          for (let i = 0; i < message.valsetConfirms.length; ++i)
            $root.gravity.v1.MsgValsetConfirm.encode(message.valsetConfirms[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.batches != null && message.batches.length)
          for (let i = 0; i < message.batches.length; ++i)
            $root.gravity.v1.OutgoingTxBatch.encode(message.batches[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.batchConfirms != null && message.batchConfirms.length)
          for (let i = 0; i < message.batchConfirms.length; ++i)
            $root.gravity.v1.MsgConfirmBatch.encode(message.batchConfirms[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.logicCalls != null && message.logicCalls.length)
          for (let i = 0; i < message.logicCalls.length; ++i)
            $root.gravity.v1.OutgoingLogicCall.encode(message.logicCalls[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.logicCallConfirms != null && message.logicCallConfirms.length)
          for (let i = 0; i < message.logicCallConfirms.length; ++i)
            $root.gravity.v1.MsgConfirmLogicCall.encode(message.logicCallConfirms[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.attestations != null && message.attestations.length)
          for (let i = 0; i < message.attestations.length; ++i)
            $root.gravity.v1.Attestation.encode(message.attestations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.delegateKeys != null && message.delegateKeys.length)
          for (let i = 0; i < message.delegateKeys.length; ++i)
            $root.gravity.v1.MsgSetOrchestratorAddress.encode(message.delegateKeys[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.erc20ToDenoms != null && message.erc20ToDenoms.length)
          for (let i = 0; i < message.erc20ToDenoms.length; ++i)
            $root.gravity.v1.ERC20ToDenom.encode(message.erc20ToDenoms[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.unbatchedTransfers != null && message.unbatchedTransfers.length)
          for (let i = 0; i < message.unbatchedTransfers.length; ++i)
            $root.gravity.v1.OutgoingTransferTx.encode(message.unbatchedTransfers[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link gravity.v1.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {gravity.v1.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.gravity.v1.Params.decode(reader, reader.uint32());
              break;
            case 2:
              message.gravityNonces = $root.gravity.v1.GravityNonces.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.valsets && message.valsets.length))
                message.valsets = [];
              message.valsets.push($root.gravity.v1.Valset.decode(reader, reader.uint32()));
              break;
            case 4:
              if (!(message.valsetConfirms && message.valsetConfirms.length))
                message.valsetConfirms = [];
              message.valsetConfirms.push($root.gravity.v1.MsgValsetConfirm.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.batches && message.batches.length))
                message.batches = [];
              message.batches.push($root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.batchConfirms && message.batchConfirms.length))
                message.batchConfirms = [];
              message.batchConfirms.push($root.gravity.v1.MsgConfirmBatch.decode(reader, reader.uint32()));
              break;
            case 7:
              if (!(message.logicCalls && message.logicCalls.length))
                message.logicCalls = [];
              message.logicCalls.push($root.gravity.v1.OutgoingLogicCall.decode(reader, reader.uint32()));
              break;
            case 8:
              if (!(message.logicCallConfirms && message.logicCallConfirms.length))
                message.logicCallConfirms = [];
              message.logicCallConfirms.push($root.gravity.v1.MsgConfirmLogicCall.decode(reader, reader.uint32()));
              break;
            case 9:
              if (!(message.attestations && message.attestations.length))
                message.attestations = [];
              message.attestations.push($root.gravity.v1.Attestation.decode(reader, reader.uint32()));
              break;
            case 10:
              if (!(message.delegateKeys && message.delegateKeys.length))
                message.delegateKeys = [];
              message.delegateKeys.push($root.gravity.v1.MsgSetOrchestratorAddress.decode(reader, reader.uint32()));
              break;
            case 11:
              if (!(message.erc20ToDenoms && message.erc20ToDenoms.length))
                message.erc20ToDenoms = [];
              message.erc20ToDenoms.push($root.gravity.v1.ERC20ToDenom.decode(reader, reader.uint32()));
              break;
            case 12:
              if (!(message.unbatchedTransfers && message.unbatchedTransfers.length))
                message.unbatchedTransfers = [];
              message.unbatchedTransfers.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.params != null && message.hasOwnProperty("params")) {
          let error = $root.gravity.v1.Params.verify(message.params);
          if (error)
            return "params." + error;
        }
        if (message.gravityNonces != null && message.hasOwnProperty("gravityNonces")) {
          let error = $root.gravity.v1.GravityNonces.verify(message.gravityNonces);
          if (error)
            return "gravityNonces." + error;
        }
        if (message.valsets != null && message.hasOwnProperty("valsets")) {
          if (!Array.isArray(message.valsets))
            return "valsets: array expected";
          for (let i = 0; i < message.valsets.length; ++i) {
            let error = $root.gravity.v1.Valset.verify(message.valsets[i]);
            if (error)
              return "valsets." + error;
          }
        }
        if (message.valsetConfirms != null && message.hasOwnProperty("valsetConfirms")) {
          if (!Array.isArray(message.valsetConfirms))
            return "valsetConfirms: array expected";
          for (let i = 0; i < message.valsetConfirms.length; ++i) {
            let error = $root.gravity.v1.MsgValsetConfirm.verify(message.valsetConfirms[i]);
            if (error)
              return "valsetConfirms." + error;
          }
        }
        if (message.batches != null && message.hasOwnProperty("batches")) {
          if (!Array.isArray(message.batches))
            return "batches: array expected";
          for (let i = 0; i < message.batches.length; ++i) {
            let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batches[i]);
            if (error)
              return "batches." + error;
          }
        }
        if (message.batchConfirms != null && message.hasOwnProperty("batchConfirms")) {
          if (!Array.isArray(message.batchConfirms))
            return "batchConfirms: array expected";
          for (let i = 0; i < message.batchConfirms.length; ++i) {
            let error = $root.gravity.v1.MsgConfirmBatch.verify(message.batchConfirms[i]);
            if (error)
              return "batchConfirms." + error;
          }
        }
        if (message.logicCalls != null && message.hasOwnProperty("logicCalls")) {
          if (!Array.isArray(message.logicCalls))
            return "logicCalls: array expected";
          for (let i = 0; i < message.logicCalls.length; ++i) {
            let error = $root.gravity.v1.OutgoingLogicCall.verify(message.logicCalls[i]);
            if (error)
              return "logicCalls." + error;
          }
        }
        if (message.logicCallConfirms != null && message.hasOwnProperty("logicCallConfirms")) {
          if (!Array.isArray(message.logicCallConfirms))
            return "logicCallConfirms: array expected";
          for (let i = 0; i < message.logicCallConfirms.length; ++i) {
            let error = $root.gravity.v1.MsgConfirmLogicCall.verify(message.logicCallConfirms[i]);
            if (error)
              return "logicCallConfirms." + error;
          }
        }
        if (message.attestations != null && message.hasOwnProperty("attestations")) {
          if (!Array.isArray(message.attestations))
            return "attestations: array expected";
          for (let i = 0; i < message.attestations.length; ++i) {
            let error = $root.gravity.v1.Attestation.verify(message.attestations[i]);
            if (error)
              return "attestations." + error;
          }
        }
        if (message.delegateKeys != null && message.hasOwnProperty("delegateKeys")) {
          if (!Array.isArray(message.delegateKeys))
            return "delegateKeys: array expected";
          for (let i = 0; i < message.delegateKeys.length; ++i) {
            let error = $root.gravity.v1.MsgSetOrchestratorAddress.verify(message.delegateKeys[i]);
            if (error)
              return "delegateKeys." + error;
          }
        }
        if (message.erc20ToDenoms != null && message.hasOwnProperty("erc20ToDenoms")) {
          if (!Array.isArray(message.erc20ToDenoms))
            return "erc20ToDenoms: array expected";
          for (let i = 0; i < message.erc20ToDenoms.length; ++i) {
            let error = $root.gravity.v1.ERC20ToDenom.verify(message.erc20ToDenoms[i]);
            if (error)
              return "erc20ToDenoms." + error;
          }
        }
        if (message.unbatchedTransfers != null && message.hasOwnProperty("unbatchedTransfers")) {
          if (!Array.isArray(message.unbatchedTransfers))
            return "unbatchedTransfers: array expected";
          for (let i = 0; i < message.unbatchedTransfers.length; ++i) {
            let error = $root.gravity.v1.OutgoingTransferTx.verify(message.unbatchedTransfers[i]);
            if (error)
              return "unbatchedTransfers." + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.GenesisState)
          return object;
        let message = new $root.gravity.v1.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== "object")
            throw TypeError(".gravity.v1.GenesisState.params: object expected");
          message.params = $root.gravity.v1.Params.fromObject(object.params);
        }
        if (object.gravityNonces != null) {
          if (typeof object.gravityNonces !== "object")
            throw TypeError(".gravity.v1.GenesisState.gravityNonces: object expected");
          message.gravityNonces = $root.gravity.v1.GravityNonces.fromObject(object.gravityNonces);
        }
        if (object.valsets) {
          if (!Array.isArray(object.valsets))
            throw TypeError(".gravity.v1.GenesisState.valsets: array expected");
          message.valsets = [];
          for (let i = 0; i < object.valsets.length; ++i) {
            if (typeof object.valsets[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.valsets: object expected");
            message.valsets[i] = $root.gravity.v1.Valset.fromObject(object.valsets[i]);
          }
        }
        if (object.valsetConfirms) {
          if (!Array.isArray(object.valsetConfirms))
            throw TypeError(".gravity.v1.GenesisState.valsetConfirms: array expected");
          message.valsetConfirms = [];
          for (let i = 0; i < object.valsetConfirms.length; ++i) {
            if (typeof object.valsetConfirms[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.valsetConfirms: object expected");
            message.valsetConfirms[i] = $root.gravity.v1.MsgValsetConfirm.fromObject(object.valsetConfirms[i]);
          }
        }
        if (object.batches) {
          if (!Array.isArray(object.batches))
            throw TypeError(".gravity.v1.GenesisState.batches: array expected");
          message.batches = [];
          for (let i = 0; i < object.batches.length; ++i) {
            if (typeof object.batches[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.batches: object expected");
            message.batches[i] = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batches[i]);
          }
        }
        if (object.batchConfirms) {
          if (!Array.isArray(object.batchConfirms))
            throw TypeError(".gravity.v1.GenesisState.batchConfirms: array expected");
          message.batchConfirms = [];
          for (let i = 0; i < object.batchConfirms.length; ++i) {
            if (typeof object.batchConfirms[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.batchConfirms: object expected");
            message.batchConfirms[i] = $root.gravity.v1.MsgConfirmBatch.fromObject(object.batchConfirms[i]);
          }
        }
        if (object.logicCalls) {
          if (!Array.isArray(object.logicCalls))
            throw TypeError(".gravity.v1.GenesisState.logicCalls: array expected");
          message.logicCalls = [];
          for (let i = 0; i < object.logicCalls.length; ++i) {
            if (typeof object.logicCalls[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.logicCalls: object expected");
            message.logicCalls[i] = $root.gravity.v1.OutgoingLogicCall.fromObject(object.logicCalls[i]);
          }
        }
        if (object.logicCallConfirms) {
          if (!Array.isArray(object.logicCallConfirms))
            throw TypeError(".gravity.v1.GenesisState.logicCallConfirms: array expected");
          message.logicCallConfirms = [];
          for (let i = 0; i < object.logicCallConfirms.length; ++i) {
            if (typeof object.logicCallConfirms[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.logicCallConfirms: object expected");
            message.logicCallConfirms[i] = $root.gravity.v1.MsgConfirmLogicCall.fromObject(object.logicCallConfirms[i]);
          }
        }
        if (object.attestations) {
          if (!Array.isArray(object.attestations))
            throw TypeError(".gravity.v1.GenesisState.attestations: array expected");
          message.attestations = [];
          for (let i = 0; i < object.attestations.length; ++i) {
            if (typeof object.attestations[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.attestations: object expected");
            message.attestations[i] = $root.gravity.v1.Attestation.fromObject(object.attestations[i]);
          }
        }
        if (object.delegateKeys) {
          if (!Array.isArray(object.delegateKeys))
            throw TypeError(".gravity.v1.GenesisState.delegateKeys: array expected");
          message.delegateKeys = [];
          for (let i = 0; i < object.delegateKeys.length; ++i) {
            if (typeof object.delegateKeys[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.delegateKeys: object expected");
            message.delegateKeys[i] = $root.gravity.v1.MsgSetOrchestratorAddress.fromObject(object.delegateKeys[i]);
          }
        }
        if (object.erc20ToDenoms) {
          if (!Array.isArray(object.erc20ToDenoms))
            throw TypeError(".gravity.v1.GenesisState.erc20ToDenoms: array expected");
          message.erc20ToDenoms = [];
          for (let i = 0; i < object.erc20ToDenoms.length; ++i) {
            if (typeof object.erc20ToDenoms[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.erc20ToDenoms: object expected");
            message.erc20ToDenoms[i] = $root.gravity.v1.ERC20ToDenom.fromObject(object.erc20ToDenoms[i]);
          }
        }
        if (object.unbatchedTransfers) {
          if (!Array.isArray(object.unbatchedTransfers))
            throw TypeError(".gravity.v1.GenesisState.unbatchedTransfers: array expected");
          message.unbatchedTransfers = [];
          for (let i = 0; i < object.unbatchedTransfers.length; ++i) {
            if (typeof object.unbatchedTransfers[i] !== "object")
              throw TypeError(".gravity.v1.GenesisState.unbatchedTransfers: object expected");
            message.unbatchedTransfers[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.unbatchedTransfers[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.GenesisState
       * @static
       * @param {gravity.v1.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.valsets = [];
          object.valsetConfirms = [];
          object.batches = [];
          object.batchConfirms = [];
          object.logicCalls = [];
          object.logicCallConfirms = [];
          object.attestations = [];
          object.delegateKeys = [];
          object.erc20ToDenoms = [];
          object.unbatchedTransfers = [];
        }
        if (options.defaults) {
          object.params = null;
          object.gravityNonces = null;
        }
        if (message.params != null && message.hasOwnProperty("params"))
          object.params = $root.gravity.v1.Params.toObject(message.params, options);
        if (message.gravityNonces != null && message.hasOwnProperty("gravityNonces"))
          object.gravityNonces = $root.gravity.v1.GravityNonces.toObject(message.gravityNonces, options);
        if (message.valsets && message.valsets.length) {
          object.valsets = [];
          for (let j = 0; j < message.valsets.length; ++j)
            object.valsets[j] = $root.gravity.v1.Valset.toObject(message.valsets[j], options);
        }
        if (message.valsetConfirms && message.valsetConfirms.length) {
          object.valsetConfirms = [];
          for (let j = 0; j < message.valsetConfirms.length; ++j)
            object.valsetConfirms[j] = $root.gravity.v1.MsgValsetConfirm.toObject(message.valsetConfirms[j], options);
        }
        if (message.batches && message.batches.length) {
          object.batches = [];
          for (let j = 0; j < message.batches.length; ++j)
            object.batches[j] = $root.gravity.v1.OutgoingTxBatch.toObject(message.batches[j], options);
        }
        if (message.batchConfirms && message.batchConfirms.length) {
          object.batchConfirms = [];
          for (let j = 0; j < message.batchConfirms.length; ++j)
            object.batchConfirms[j] = $root.gravity.v1.MsgConfirmBatch.toObject(message.batchConfirms[j], options);
        }
        if (message.logicCalls && message.logicCalls.length) {
          object.logicCalls = [];
          for (let j = 0; j < message.logicCalls.length; ++j)
            object.logicCalls[j] = $root.gravity.v1.OutgoingLogicCall.toObject(message.logicCalls[j], options);
        }
        if (message.logicCallConfirms && message.logicCallConfirms.length) {
          object.logicCallConfirms = [];
          for (let j = 0; j < message.logicCallConfirms.length; ++j)
            object.logicCallConfirms[j] = $root.gravity.v1.MsgConfirmLogicCall.toObject(message.logicCallConfirms[j], options);
        }
        if (message.attestations && message.attestations.length) {
          object.attestations = [];
          for (let j = 0; j < message.attestations.length; ++j)
            object.attestations[j] = $root.gravity.v1.Attestation.toObject(message.attestations[j], options);
        }
        if (message.delegateKeys && message.delegateKeys.length) {
          object.delegateKeys = [];
          for (let j = 0; j < message.delegateKeys.length; ++j)
            object.delegateKeys[j] = $root.gravity.v1.MsgSetOrchestratorAddress.toObject(message.delegateKeys[j], options);
        }
        if (message.erc20ToDenoms && message.erc20ToDenoms.length) {
          object.erc20ToDenoms = [];
          for (let j = 0; j < message.erc20ToDenoms.length; ++j)
            object.erc20ToDenoms[j] = $root.gravity.v1.ERC20ToDenom.toObject(message.erc20ToDenoms[j], options);
        }
        if (message.unbatchedTransfers && message.unbatchedTransfers.length) {
          object.unbatchedTransfers = [];
          for (let j = 0; j < message.unbatchedTransfers.length; ++j)
            object.unbatchedTransfers[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.unbatchedTransfers[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof gravity.v1.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    v1.GravityNonces = (function() {

      /**
       * Properties of a GravityNonces.
       * @memberof gravity.v1
       * @interface IGravityNonces
       * @property {number|Long|null} [latestValsetNonce] GravityNonces latestValsetNonce
       * @property {number|Long|null} [lastObservedNonce] GravityNonces lastObservedNonce
       * @property {number|Long|null} [lastSlashedValsetNonce] GravityNonces lastSlashedValsetNonce
       * @property {number|Long|null} [lastSlashedBatchBlock] GravityNonces lastSlashedBatchBlock
       * @property {number|Long|null} [lastSlashedLogicCallBlock] GravityNonces lastSlashedLogicCallBlock
       * @property {number|Long|null} [lastTxPoolId] GravityNonces lastTxPoolId
       * @property {number|Long|null} [lastBatchId] GravityNonces lastBatchId
       */

      /**
       * Constructs a new GravityNonces.
       * @memberof gravity.v1
       * @classdesc Represents a GravityNonces.
       * @implements IGravityNonces
       * @constructor
       * @param {gravity.v1.IGravityNonces=} [properties] Properties to set
       */
      function GravityNonces(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * GravityNonces latestValsetNonce.
       * @member {number|Long} latestValsetNonce
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.latestValsetNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * GravityNonces lastObservedNonce.
       * @member {number|Long} lastObservedNonce
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.lastObservedNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * GravityNonces lastSlashedValsetNonce.
       * @member {number|Long} lastSlashedValsetNonce
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.lastSlashedValsetNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * GravityNonces lastSlashedBatchBlock.
       * @member {number|Long} lastSlashedBatchBlock
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.lastSlashedBatchBlock = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * GravityNonces lastSlashedLogicCallBlock.
       * @member {number|Long} lastSlashedLogicCallBlock
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.lastSlashedLogicCallBlock = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * GravityNonces lastTxPoolId.
       * @member {number|Long} lastTxPoolId
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.lastTxPoolId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * GravityNonces lastBatchId.
       * @member {number|Long} lastBatchId
       * @memberof gravity.v1.GravityNonces
       * @instance
       */
      GravityNonces.prototype.lastBatchId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new GravityNonces instance using the specified properties.
       * @function create
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {gravity.v1.IGravityNonces=} [properties] Properties to set
       * @returns {gravity.v1.GravityNonces} GravityNonces instance
       */
      GravityNonces.create = function create(properties) {
        return new GravityNonces(properties);
      };

      /**
       * Encodes the specified GravityNonces message. Does not implicitly {@link gravity.v1.GravityNonces.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {gravity.v1.IGravityNonces} message GravityNonces message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GravityNonces.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.latestValsetNonce != null && Object.hasOwnProperty.call(message, "latestValsetNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.latestValsetNonce);
        if (message.lastObservedNonce != null && Object.hasOwnProperty.call(message, "lastObservedNonce"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastObservedNonce);
        if (message.lastSlashedValsetNonce != null && Object.hasOwnProperty.call(message, "lastSlashedValsetNonce"))
          writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.lastSlashedValsetNonce);
        if (message.lastSlashedBatchBlock != null && Object.hasOwnProperty.call(message, "lastSlashedBatchBlock"))
          writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.lastSlashedBatchBlock);
        if (message.lastSlashedLogicCallBlock != null && Object.hasOwnProperty.call(message, "lastSlashedLogicCallBlock"))
          writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.lastSlashedLogicCallBlock);
        if (message.lastTxPoolId != null && Object.hasOwnProperty.call(message, "lastTxPoolId"))
          writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.lastTxPoolId);
        if (message.lastBatchId != null && Object.hasOwnProperty.call(message, "lastBatchId"))
          writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.lastBatchId);
        return writer;
      };

      /**
       * Encodes the specified GravityNonces message, length delimited. Does not implicitly {@link gravity.v1.GravityNonces.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {gravity.v1.IGravityNonces} message GravityNonces message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GravityNonces.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GravityNonces message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.GravityNonces} GravityNonces
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GravityNonces.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.GravityNonces();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.latestValsetNonce = reader.uint64();
              break;
            case 2:
              message.lastObservedNonce = reader.uint64();
              break;
            case 3:
              message.lastSlashedValsetNonce = reader.uint64();
              break;
            case 4:
              message.lastSlashedBatchBlock = reader.uint64();
              break;
            case 5:
              message.lastSlashedLogicCallBlock = reader.uint64();
              break;
            case 6:
              message.lastTxPoolId = reader.uint64();
              break;
            case 7:
              message.lastBatchId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GravityNonces message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.GravityNonces} GravityNonces
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GravityNonces.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GravityNonces message.
       * @function verify
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GravityNonces.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latestValsetNonce != null && message.hasOwnProperty("latestValsetNonce"))
          if (!$util.isInteger(message.latestValsetNonce) && !(message.latestValsetNonce && $util.isInteger(message.latestValsetNonce.low) && $util.isInteger(message.latestValsetNonce.high)))
            return "latestValsetNonce: integer|Long expected";
        if (message.lastObservedNonce != null && message.hasOwnProperty("lastObservedNonce"))
          if (!$util.isInteger(message.lastObservedNonce) && !(message.lastObservedNonce && $util.isInteger(message.lastObservedNonce.low) && $util.isInteger(message.lastObservedNonce.high)))
            return "lastObservedNonce: integer|Long expected";
        if (message.lastSlashedValsetNonce != null && message.hasOwnProperty("lastSlashedValsetNonce"))
          if (!$util.isInteger(message.lastSlashedValsetNonce) && !(message.lastSlashedValsetNonce && $util.isInteger(message.lastSlashedValsetNonce.low) && $util.isInteger(message.lastSlashedValsetNonce.high)))
            return "lastSlashedValsetNonce: integer|Long expected";
        if (message.lastSlashedBatchBlock != null && message.hasOwnProperty("lastSlashedBatchBlock"))
          if (!$util.isInteger(message.lastSlashedBatchBlock) && !(message.lastSlashedBatchBlock && $util.isInteger(message.lastSlashedBatchBlock.low) && $util.isInteger(message.lastSlashedBatchBlock.high)))
            return "lastSlashedBatchBlock: integer|Long expected";
        if (message.lastSlashedLogicCallBlock != null && message.hasOwnProperty("lastSlashedLogicCallBlock"))
          if (!$util.isInteger(message.lastSlashedLogicCallBlock) && !(message.lastSlashedLogicCallBlock && $util.isInteger(message.lastSlashedLogicCallBlock.low) && $util.isInteger(message.lastSlashedLogicCallBlock.high)))
            return "lastSlashedLogicCallBlock: integer|Long expected";
        if (message.lastTxPoolId != null && message.hasOwnProperty("lastTxPoolId"))
          if (!$util.isInteger(message.lastTxPoolId) && !(message.lastTxPoolId && $util.isInteger(message.lastTxPoolId.low) && $util.isInteger(message.lastTxPoolId.high)))
            return "lastTxPoolId: integer|Long expected";
        if (message.lastBatchId != null && message.hasOwnProperty("lastBatchId"))
          if (!$util.isInteger(message.lastBatchId) && !(message.lastBatchId && $util.isInteger(message.lastBatchId.low) && $util.isInteger(message.lastBatchId.high)))
            return "lastBatchId: integer|Long expected";
        return null;
      };

      /**
       * Creates a GravityNonces message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.GravityNonces} GravityNonces
       */
      GravityNonces.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.GravityNonces)
          return object;
        let message = new $root.gravity.v1.GravityNonces();
        if (object.latestValsetNonce != null)
          if ($util.Long)
            (message.latestValsetNonce = $util.Long.fromValue(object.latestValsetNonce)).unsigned = true;
          else if (typeof object.latestValsetNonce === "string")
            message.latestValsetNonce = parseInt(object.latestValsetNonce, 10);
          else if (typeof object.latestValsetNonce === "number")
            message.latestValsetNonce = object.latestValsetNonce;
          else if (typeof object.latestValsetNonce === "object")
            message.latestValsetNonce = new $util.LongBits(object.latestValsetNonce.low >>> 0, object.latestValsetNonce.high >>> 0).toNumber(true);
        if (object.lastObservedNonce != null)
          if ($util.Long)
            (message.lastObservedNonce = $util.Long.fromValue(object.lastObservedNonce)).unsigned = true;
          else if (typeof object.lastObservedNonce === "string")
            message.lastObservedNonce = parseInt(object.lastObservedNonce, 10);
          else if (typeof object.lastObservedNonce === "number")
            message.lastObservedNonce = object.lastObservedNonce;
          else if (typeof object.lastObservedNonce === "object")
            message.lastObservedNonce = new $util.LongBits(object.lastObservedNonce.low >>> 0, object.lastObservedNonce.high >>> 0).toNumber(true);
        if (object.lastSlashedValsetNonce != null)
          if ($util.Long)
            (message.lastSlashedValsetNonce = $util.Long.fromValue(object.lastSlashedValsetNonce)).unsigned = true;
          else if (typeof object.lastSlashedValsetNonce === "string")
            message.lastSlashedValsetNonce = parseInt(object.lastSlashedValsetNonce, 10);
          else if (typeof object.lastSlashedValsetNonce === "number")
            message.lastSlashedValsetNonce = object.lastSlashedValsetNonce;
          else if (typeof object.lastSlashedValsetNonce === "object")
            message.lastSlashedValsetNonce = new $util.LongBits(object.lastSlashedValsetNonce.low >>> 0, object.lastSlashedValsetNonce.high >>> 0).toNumber(true);
        if (object.lastSlashedBatchBlock != null)
          if ($util.Long)
            (message.lastSlashedBatchBlock = $util.Long.fromValue(object.lastSlashedBatchBlock)).unsigned = true;
          else if (typeof object.lastSlashedBatchBlock === "string")
            message.lastSlashedBatchBlock = parseInt(object.lastSlashedBatchBlock, 10);
          else if (typeof object.lastSlashedBatchBlock === "number")
            message.lastSlashedBatchBlock = object.lastSlashedBatchBlock;
          else if (typeof object.lastSlashedBatchBlock === "object")
            message.lastSlashedBatchBlock = new $util.LongBits(object.lastSlashedBatchBlock.low >>> 0, object.lastSlashedBatchBlock.high >>> 0).toNumber(true);
        if (object.lastSlashedLogicCallBlock != null)
          if ($util.Long)
            (message.lastSlashedLogicCallBlock = $util.Long.fromValue(object.lastSlashedLogicCallBlock)).unsigned = true;
          else if (typeof object.lastSlashedLogicCallBlock === "string")
            message.lastSlashedLogicCallBlock = parseInt(object.lastSlashedLogicCallBlock, 10);
          else if (typeof object.lastSlashedLogicCallBlock === "number")
            message.lastSlashedLogicCallBlock = object.lastSlashedLogicCallBlock;
          else if (typeof object.lastSlashedLogicCallBlock === "object")
            message.lastSlashedLogicCallBlock = new $util.LongBits(object.lastSlashedLogicCallBlock.low >>> 0, object.lastSlashedLogicCallBlock.high >>> 0).toNumber(true);
        if (object.lastTxPoolId != null)
          if ($util.Long)
            (message.lastTxPoolId = $util.Long.fromValue(object.lastTxPoolId)).unsigned = true;
          else if (typeof object.lastTxPoolId === "string")
            message.lastTxPoolId = parseInt(object.lastTxPoolId, 10);
          else if (typeof object.lastTxPoolId === "number")
            message.lastTxPoolId = object.lastTxPoolId;
          else if (typeof object.lastTxPoolId === "object")
            message.lastTxPoolId = new $util.LongBits(object.lastTxPoolId.low >>> 0, object.lastTxPoolId.high >>> 0).toNumber(true);
        if (object.lastBatchId != null)
          if ($util.Long)
            (message.lastBatchId = $util.Long.fromValue(object.lastBatchId)).unsigned = true;
          else if (typeof object.lastBatchId === "string")
            message.lastBatchId = parseInt(object.lastBatchId, 10);
          else if (typeof object.lastBatchId === "number")
            message.lastBatchId = object.lastBatchId;
          else if (typeof object.lastBatchId === "object")
            message.lastBatchId = new $util.LongBits(object.lastBatchId.low >>> 0, object.lastBatchId.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a GravityNonces message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.GravityNonces
       * @static
       * @param {gravity.v1.GravityNonces} message GravityNonces
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GravityNonces.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.latestValsetNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.latestValsetNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.lastObservedNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.lastObservedNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.lastSlashedValsetNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.lastSlashedValsetNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.lastSlashedBatchBlock = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.lastSlashedBatchBlock = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.lastSlashedLogicCallBlock = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.lastSlashedLogicCallBlock = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.lastTxPoolId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.lastTxPoolId = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.lastBatchId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.lastBatchId = options.longs === String ? "0" : 0;
        }
        if (message.latestValsetNonce != null && message.hasOwnProperty("latestValsetNonce"))
          if (typeof message.latestValsetNonce === "number")
            object.latestValsetNonce = options.longs === String ? String(message.latestValsetNonce) : message.latestValsetNonce;
          else
            object.latestValsetNonce = options.longs === String ? $util.Long.prototype.toString.call(message.latestValsetNonce) : options.longs === Number ? new $util.LongBits(message.latestValsetNonce.low >>> 0, message.latestValsetNonce.high >>> 0).toNumber(true) : message.latestValsetNonce;
        if (message.lastObservedNonce != null && message.hasOwnProperty("lastObservedNonce"))
          if (typeof message.lastObservedNonce === "number")
            object.lastObservedNonce = options.longs === String ? String(message.lastObservedNonce) : message.lastObservedNonce;
          else
            object.lastObservedNonce = options.longs === String ? $util.Long.prototype.toString.call(message.lastObservedNonce) : options.longs === Number ? new $util.LongBits(message.lastObservedNonce.low >>> 0, message.lastObservedNonce.high >>> 0).toNumber(true) : message.lastObservedNonce;
        if (message.lastSlashedValsetNonce != null && message.hasOwnProperty("lastSlashedValsetNonce"))
          if (typeof message.lastSlashedValsetNonce === "number")
            object.lastSlashedValsetNonce = options.longs === String ? String(message.lastSlashedValsetNonce) : message.lastSlashedValsetNonce;
          else
            object.lastSlashedValsetNonce = options.longs === String ? $util.Long.prototype.toString.call(message.lastSlashedValsetNonce) : options.longs === Number ? new $util.LongBits(message.lastSlashedValsetNonce.low >>> 0, message.lastSlashedValsetNonce.high >>> 0).toNumber(true) : message.lastSlashedValsetNonce;
        if (message.lastSlashedBatchBlock != null && message.hasOwnProperty("lastSlashedBatchBlock"))
          if (typeof message.lastSlashedBatchBlock === "number")
            object.lastSlashedBatchBlock = options.longs === String ? String(message.lastSlashedBatchBlock) : message.lastSlashedBatchBlock;
          else
            object.lastSlashedBatchBlock = options.longs === String ? $util.Long.prototype.toString.call(message.lastSlashedBatchBlock) : options.longs === Number ? new $util.LongBits(message.lastSlashedBatchBlock.low >>> 0, message.lastSlashedBatchBlock.high >>> 0).toNumber(true) : message.lastSlashedBatchBlock;
        if (message.lastSlashedLogicCallBlock != null && message.hasOwnProperty("lastSlashedLogicCallBlock"))
          if (typeof message.lastSlashedLogicCallBlock === "number")
            object.lastSlashedLogicCallBlock = options.longs === String ? String(message.lastSlashedLogicCallBlock) : message.lastSlashedLogicCallBlock;
          else
            object.lastSlashedLogicCallBlock = options.longs === String ? $util.Long.prototype.toString.call(message.lastSlashedLogicCallBlock) : options.longs === Number ? new $util.LongBits(message.lastSlashedLogicCallBlock.low >>> 0, message.lastSlashedLogicCallBlock.high >>> 0).toNumber(true) : message.lastSlashedLogicCallBlock;
        if (message.lastTxPoolId != null && message.hasOwnProperty("lastTxPoolId"))
          if (typeof message.lastTxPoolId === "number")
            object.lastTxPoolId = options.longs === String ? String(message.lastTxPoolId) : message.lastTxPoolId;
          else
            object.lastTxPoolId = options.longs === String ? $util.Long.prototype.toString.call(message.lastTxPoolId) : options.longs === Number ? new $util.LongBits(message.lastTxPoolId.low >>> 0, message.lastTxPoolId.high >>> 0).toNumber(true) : message.lastTxPoolId;
        if (message.lastBatchId != null && message.hasOwnProperty("lastBatchId"))
          if (typeof message.lastBatchId === "number")
            object.lastBatchId = options.longs === String ? String(message.lastBatchId) : message.lastBatchId;
          else
            object.lastBatchId = options.longs === String ? $util.Long.prototype.toString.call(message.lastBatchId) : options.longs === Number ? new $util.LongBits(message.lastBatchId.low >>> 0, message.lastBatchId.high >>> 0).toNumber(true) : message.lastBatchId;
        return object;
      };

      /**
       * Converts this GravityNonces to JSON.
       * @function toJSON
       * @memberof gravity.v1.GravityNonces
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GravityNonces.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GravityNonces;
    })();

    v1.Msg = (function() {

      /**
       * Constructs a new Msg service.
       * @memberof gravity.v1
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Creates new Msg service using the specified rpc implementation.
       * @function create
       * @memberof gravity.v1.Msg
       * @static
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       * @returns {Msg} RPC service. Useful where requests and/or responses are streamed.
       */
      Msg.create = function create(rpcImpl, requestDelimited, responseDelimited) {
        return new this(rpcImpl, requestDelimited, responseDelimited);
      };

      /**
       * Callback as used by {@link gravity.v1.Msg#valsetConfirm}.
       * @memberof gravity.v1.Msg
       * @typedef ValsetConfirmCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgValsetConfirmResponse} [response] MsgValsetConfirmResponse
       */

      /**
       * Calls ValsetConfirm.
       * @function valsetConfirm
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgValsetConfirm} request MsgValsetConfirm message or plain object
       * @param {gravity.v1.Msg.ValsetConfirmCallback} callback Node-style callback called with the error, if any, and MsgValsetConfirmResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.valsetConfirm = function valsetConfirm(request, callback) {
        return this.rpcCall(valsetConfirm, $root.gravity.v1.MsgValsetConfirm, $root.gravity.v1.MsgValsetConfirmResponse, request, callback);
      }, "name", { value: "ValsetConfirm" });

      /**
       * Calls ValsetConfirm.
       * @function valsetConfirm
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgValsetConfirm} request MsgValsetConfirm message or plain object
       * @returns {Promise<gravity.v1.MsgValsetConfirmResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#sendToEth}.
       * @memberof gravity.v1.Msg
       * @typedef SendToEthCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgSendToEthResponse} [response] MsgSendToEthResponse
       */

      /**
       * Calls SendToEth.
       * @function sendToEth
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSendToEth} request MsgSendToEth message or plain object
       * @param {gravity.v1.Msg.SendToEthCallback} callback Node-style callback called with the error, if any, and MsgSendToEthResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.sendToEth = function sendToEth(request, callback) {
        return this.rpcCall(sendToEth, $root.gravity.v1.MsgSendToEth, $root.gravity.v1.MsgSendToEthResponse, request, callback);
      }, "name", { value: "SendToEth" });

      /**
       * Calls SendToEth.
       * @function sendToEth
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSendToEth} request MsgSendToEth message or plain object
       * @returns {Promise<gravity.v1.MsgSendToEthResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#requestBatch}.
       * @memberof gravity.v1.Msg
       * @typedef RequestBatchCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgRequestBatchResponse} [response] MsgRequestBatchResponse
       */

      /**
       * Calls RequestBatch.
       * @function requestBatch
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgRequestBatch} request MsgRequestBatch message or plain object
       * @param {gravity.v1.Msg.RequestBatchCallback} callback Node-style callback called with the error, if any, and MsgRequestBatchResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.requestBatch = function requestBatch(request, callback) {
        return this.rpcCall(requestBatch, $root.gravity.v1.MsgRequestBatch, $root.gravity.v1.MsgRequestBatchResponse, request, callback);
      }, "name", { value: "RequestBatch" });

      /**
       * Calls RequestBatch.
       * @function requestBatch
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgRequestBatch} request MsgRequestBatch message or plain object
       * @returns {Promise<gravity.v1.MsgRequestBatchResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#confirmBatch}.
       * @memberof gravity.v1.Msg
       * @typedef ConfirmBatchCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgConfirmBatchResponse} [response] MsgConfirmBatchResponse
       */

      /**
       * Calls ConfirmBatch.
       * @function confirmBatch
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgConfirmBatch} request MsgConfirmBatch message or plain object
       * @param {gravity.v1.Msg.ConfirmBatchCallback} callback Node-style callback called with the error, if any, and MsgConfirmBatchResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.confirmBatch = function confirmBatch(request, callback) {
        return this.rpcCall(confirmBatch, $root.gravity.v1.MsgConfirmBatch, $root.gravity.v1.MsgConfirmBatchResponse, request, callback);
      }, "name", { value: "ConfirmBatch" });

      /**
       * Calls ConfirmBatch.
       * @function confirmBatch
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgConfirmBatch} request MsgConfirmBatch message or plain object
       * @returns {Promise<gravity.v1.MsgConfirmBatchResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#confirmLogicCall}.
       * @memberof gravity.v1.Msg
       * @typedef ConfirmLogicCallCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgConfirmLogicCallResponse} [response] MsgConfirmLogicCallResponse
       */

      /**
       * Calls ConfirmLogicCall.
       * @function confirmLogicCall
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgConfirmLogicCall} request MsgConfirmLogicCall message or plain object
       * @param {gravity.v1.Msg.ConfirmLogicCallCallback} callback Node-style callback called with the error, if any, and MsgConfirmLogicCallResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.confirmLogicCall = function confirmLogicCall(request, callback) {
        return this.rpcCall(confirmLogicCall, $root.gravity.v1.MsgConfirmLogicCall, $root.gravity.v1.MsgConfirmLogicCallResponse, request, callback);
      }, "name", { value: "ConfirmLogicCall" });

      /**
       * Calls ConfirmLogicCall.
       * @function confirmLogicCall
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgConfirmLogicCall} request MsgConfirmLogicCall message or plain object
       * @returns {Promise<gravity.v1.MsgConfirmLogicCallResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#sendToCosmosClaim}.
       * @memberof gravity.v1.Msg
       * @typedef SendToCosmosClaimCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgSendToCosmosClaimResponse} [response] MsgSendToCosmosClaimResponse
       */

      /**
       * Calls SendToCosmosClaim.
       * @function sendToCosmosClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSendToCosmosClaim} request MsgSendToCosmosClaim message or plain object
       * @param {gravity.v1.Msg.SendToCosmosClaimCallback} callback Node-style callback called with the error, if any, and MsgSendToCosmosClaimResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.sendToCosmosClaim = function sendToCosmosClaim(request, callback) {
        return this.rpcCall(sendToCosmosClaim, $root.gravity.v1.MsgSendToCosmosClaim, $root.gravity.v1.MsgSendToCosmosClaimResponse, request, callback);
      }, "name", { value: "SendToCosmosClaim" });

      /**
       * Calls SendToCosmosClaim.
       * @function sendToCosmosClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSendToCosmosClaim} request MsgSendToCosmosClaim message or plain object
       * @returns {Promise<gravity.v1.MsgSendToCosmosClaimResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#batchSendToEthClaim}.
       * @memberof gravity.v1.Msg
       * @typedef BatchSendToEthClaimCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgBatchSendToEthClaimResponse} [response] MsgBatchSendToEthClaimResponse
       */

      /**
       * Calls BatchSendToEthClaim.
       * @function batchSendToEthClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgBatchSendToEthClaim} request MsgBatchSendToEthClaim message or plain object
       * @param {gravity.v1.Msg.BatchSendToEthClaimCallback} callback Node-style callback called with the error, if any, and MsgBatchSendToEthClaimResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.batchSendToEthClaim = function batchSendToEthClaim(request, callback) {
        return this.rpcCall(batchSendToEthClaim, $root.gravity.v1.MsgBatchSendToEthClaim, $root.gravity.v1.MsgBatchSendToEthClaimResponse, request, callback);
      }, "name", { value: "BatchSendToEthClaim" });

      /**
       * Calls BatchSendToEthClaim.
       * @function batchSendToEthClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgBatchSendToEthClaim} request MsgBatchSendToEthClaim message or plain object
       * @returns {Promise<gravity.v1.MsgBatchSendToEthClaimResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#valsetUpdateClaim}.
       * @memberof gravity.v1.Msg
       * @typedef ValsetUpdateClaimCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgValsetUpdatedClaimResponse} [response] MsgValsetUpdatedClaimResponse
       */

      /**
       * Calls ValsetUpdateClaim.
       * @function valsetUpdateClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgValsetUpdatedClaim} request MsgValsetUpdatedClaim message or plain object
       * @param {gravity.v1.Msg.ValsetUpdateClaimCallback} callback Node-style callback called with the error, if any, and MsgValsetUpdatedClaimResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.valsetUpdateClaim = function valsetUpdateClaim(request, callback) {
        return this.rpcCall(valsetUpdateClaim, $root.gravity.v1.MsgValsetUpdatedClaim, $root.gravity.v1.MsgValsetUpdatedClaimResponse, request, callback);
      }, "name", { value: "ValsetUpdateClaim" });

      /**
       * Calls ValsetUpdateClaim.
       * @function valsetUpdateClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgValsetUpdatedClaim} request MsgValsetUpdatedClaim message or plain object
       * @returns {Promise<gravity.v1.MsgValsetUpdatedClaimResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#eRC20DeployedClaim}.
       * @memberof gravity.v1.Msg
       * @typedef ERC20DeployedClaimCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgERC20DeployedClaimResponse} [response] MsgERC20DeployedClaimResponse
       */

      /**
       * Calls ERC20DeployedClaim.
       * @function eRC20DeployedClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgERC20DeployedClaim} request MsgERC20DeployedClaim message or plain object
       * @param {gravity.v1.Msg.ERC20DeployedClaimCallback} callback Node-style callback called with the error, if any, and MsgERC20DeployedClaimResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.eRC20DeployedClaim = function eRC20DeployedClaim(request, callback) {
        return this.rpcCall(eRC20DeployedClaim, $root.gravity.v1.MsgERC20DeployedClaim, $root.gravity.v1.MsgERC20DeployedClaimResponse, request, callback);
      }, "name", { value: "ERC20DeployedClaim" });

      /**
       * Calls ERC20DeployedClaim.
       * @function eRC20DeployedClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgERC20DeployedClaim} request MsgERC20DeployedClaim message or plain object
       * @returns {Promise<gravity.v1.MsgERC20DeployedClaimResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#logicCallExecutedClaim}.
       * @memberof gravity.v1.Msg
       * @typedef LogicCallExecutedClaimCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgLogicCallExecutedClaimResponse} [response] MsgLogicCallExecutedClaimResponse
       */

      /**
       * Calls LogicCallExecutedClaim.
       * @function logicCallExecutedClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgLogicCallExecutedClaim} request MsgLogicCallExecutedClaim message or plain object
       * @param {gravity.v1.Msg.LogicCallExecutedClaimCallback} callback Node-style callback called with the error, if any, and MsgLogicCallExecutedClaimResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.logicCallExecutedClaim = function logicCallExecutedClaim(request, callback) {
        return this.rpcCall(logicCallExecutedClaim, $root.gravity.v1.MsgLogicCallExecutedClaim, $root.gravity.v1.MsgLogicCallExecutedClaimResponse, request, callback);
      }, "name", { value: "LogicCallExecutedClaim" });

      /**
       * Calls LogicCallExecutedClaim.
       * @function logicCallExecutedClaim
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgLogicCallExecutedClaim} request MsgLogicCallExecutedClaim message or plain object
       * @returns {Promise<gravity.v1.MsgLogicCallExecutedClaimResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#setOrchestratorAddress}.
       * @memberof gravity.v1.Msg
       * @typedef SetOrchestratorAddressCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgSetOrchestratorAddressResponse} [response] MsgSetOrchestratorAddressResponse
       */

      /**
       * Calls SetOrchestratorAddress.
       * @function setOrchestratorAddress
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSetOrchestratorAddress} request MsgSetOrchestratorAddress message or plain object
       * @param {gravity.v1.Msg.SetOrchestratorAddressCallback} callback Node-style callback called with the error, if any, and MsgSetOrchestratorAddressResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.setOrchestratorAddress = function setOrchestratorAddress(request, callback) {
        return this.rpcCall(setOrchestratorAddress, $root.gravity.v1.MsgSetOrchestratorAddress, $root.gravity.v1.MsgSetOrchestratorAddressResponse, request, callback);
      }, "name", { value: "SetOrchestratorAddress" });

      /**
       * Calls SetOrchestratorAddress.
       * @function setOrchestratorAddress
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSetOrchestratorAddress} request MsgSetOrchestratorAddress message or plain object
       * @returns {Promise<gravity.v1.MsgSetOrchestratorAddressResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#cancelSendToEth}.
       * @memberof gravity.v1.Msg
       * @typedef CancelSendToEthCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgCancelSendToEthResponse} [response] MsgCancelSendToEthResponse
       */

      /**
       * Calls CancelSendToEth.
       * @function cancelSendToEth
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgCancelSendToEth} request MsgCancelSendToEth message or plain object
       * @param {gravity.v1.Msg.CancelSendToEthCallback} callback Node-style callback called with the error, if any, and MsgCancelSendToEthResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.cancelSendToEth = function cancelSendToEth(request, callback) {
        return this.rpcCall(cancelSendToEth, $root.gravity.v1.MsgCancelSendToEth, $root.gravity.v1.MsgCancelSendToEthResponse, request, callback);
      }, "name", { value: "CancelSendToEth" });

      /**
       * Calls CancelSendToEth.
       * @function cancelSendToEth
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgCancelSendToEth} request MsgCancelSendToEth message or plain object
       * @returns {Promise<gravity.v1.MsgCancelSendToEthResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link gravity.v1.Msg#submitBadSignatureEvidence}.
       * @memberof gravity.v1.Msg
       * @typedef SubmitBadSignatureEvidenceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} [response] MsgSubmitBadSignatureEvidenceResponse
       */

      /**
       * Calls SubmitBadSignatureEvidence.
       * @function submitBadSignatureEvidence
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} request MsgSubmitBadSignatureEvidence message or plain object
       * @param {gravity.v1.Msg.SubmitBadSignatureEvidenceCallback} callback Node-style callback called with the error, if any, and MsgSubmitBadSignatureEvidenceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(Msg.prototype.submitBadSignatureEvidence = function submitBadSignatureEvidence(request, callback) {
        return this.rpcCall(submitBadSignatureEvidence, $root.gravity.v1.MsgSubmitBadSignatureEvidence, $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse, request, callback);
      }, "name", { value: "SubmitBadSignatureEvidence" });

      /**
       * Calls SubmitBadSignatureEvidence.
       * @function submitBadSignatureEvidence
       * @memberof gravity.v1.Msg
       * @instance
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} request MsgSubmitBadSignatureEvidence message or plain object
       * @returns {Promise<gravity.v1.MsgSubmitBadSignatureEvidenceResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    v1.MsgSetOrchestratorAddress = (function() {

      /**
       * Properties of a MsgSetOrchestratorAddress.
       * @memberof gravity.v1
       * @interface IMsgSetOrchestratorAddress
       * @property {string|null} [validator] MsgSetOrchestratorAddress validator
       * @property {string|null} [orchestrator] MsgSetOrchestratorAddress orchestrator
       * @property {string|null} [ethAddress] MsgSetOrchestratorAddress ethAddress
       */

      /**
       * Constructs a new MsgSetOrchestratorAddress.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSetOrchestratorAddress.
       * @implements IMsgSetOrchestratorAddress
       * @constructor
       * @param {gravity.v1.IMsgSetOrchestratorAddress=} [properties] Properties to set
       */
      function MsgSetOrchestratorAddress(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSetOrchestratorAddress validator.
       * @member {string} validator
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @instance
       */
      MsgSetOrchestratorAddress.prototype.validator = "";

      /**
       * MsgSetOrchestratorAddress orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @instance
       */
      MsgSetOrchestratorAddress.prototype.orchestrator = "";

      /**
       * MsgSetOrchestratorAddress ethAddress.
       * @member {string} ethAddress
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @instance
       */
      MsgSetOrchestratorAddress.prototype.ethAddress = "";

      /**
       * Creates a new MsgSetOrchestratorAddress instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {gravity.v1.IMsgSetOrchestratorAddress=} [properties] Properties to set
       * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress instance
       */
      MsgSetOrchestratorAddress.create = function create(properties) {
        return new MsgSetOrchestratorAddress(properties);
      };

      /**
       * Encodes the specified MsgSetOrchestratorAddress message. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddress.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {gravity.v1.IMsgSetOrchestratorAddress} message MsgSetOrchestratorAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetOrchestratorAddress.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.validator != null && Object.hasOwnProperty.call(message, "validator"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestrator);
        if (message.ethAddress != null && Object.hasOwnProperty.call(message, "ethAddress"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.ethAddress);
        return writer;
      };

      /**
       * Encodes the specified MsgSetOrchestratorAddress message, length delimited. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddress.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {gravity.v1.IMsgSetOrchestratorAddress} message MsgSetOrchestratorAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetOrchestratorAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSetOrchestratorAddress message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetOrchestratorAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSetOrchestratorAddress();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = reader.string();
              break;
            case 2:
              message.orchestrator = reader.string();
              break;
            case 3:
              message.ethAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSetOrchestratorAddress message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetOrchestratorAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSetOrchestratorAddress message.
       * @function verify
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSetOrchestratorAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.validator != null && message.hasOwnProperty("validator"))
          if (!$util.isString(message.validator))
            return "validator: string expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          if (!$util.isString(message.ethAddress))
            return "ethAddress: string expected";
        return null;
      };

      /**
       * Creates a MsgSetOrchestratorAddress message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress
       */
      MsgSetOrchestratorAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSetOrchestratorAddress)
          return object;
        let message = new $root.gravity.v1.MsgSetOrchestratorAddress();
        if (object.validator != null)
          message.validator = String(object.validator);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        if (object.ethAddress != null)
          message.ethAddress = String(object.ethAddress);
        return message;
      };

      /**
       * Creates a plain object from a MsgSetOrchestratorAddress message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @static
       * @param {gravity.v1.MsgSetOrchestratorAddress} message MsgSetOrchestratorAddress
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSetOrchestratorAddress.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.validator = "";
          object.orchestrator = "";
          object.ethAddress = "";
        }
        if (message.validator != null && message.hasOwnProperty("validator"))
          object.validator = message.validator;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          object.ethAddress = message.ethAddress;
        return object;
      };

      /**
       * Converts this MsgSetOrchestratorAddress to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSetOrchestratorAddress
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSetOrchestratorAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSetOrchestratorAddress;
    })();

    v1.MsgSetOrchestratorAddressResponse = (function() {

      /**
       * Properties of a MsgSetOrchestratorAddressResponse.
       * @memberof gravity.v1
       * @interface IMsgSetOrchestratorAddressResponse
       */

      /**
       * Constructs a new MsgSetOrchestratorAddressResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSetOrchestratorAddressResponse.
       * @implements IMsgSetOrchestratorAddressResponse
       * @constructor
       * @param {gravity.v1.IMsgSetOrchestratorAddressResponse=} [properties] Properties to set
       */
      function MsgSetOrchestratorAddressResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgSetOrchestratorAddressResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.IMsgSetOrchestratorAddressResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse instance
       */
      MsgSetOrchestratorAddressResponse.create = function create(properties) {
        return new MsgSetOrchestratorAddressResponse(properties);
      };

      /**
       * Encodes the specified MsgSetOrchestratorAddressResponse message. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddressResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.IMsgSetOrchestratorAddressResponse} message MsgSetOrchestratorAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetOrchestratorAddressResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSetOrchestratorAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddressResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.IMsgSetOrchestratorAddressResponse} message MsgSetOrchestratorAddressResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetOrchestratorAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSetOrchestratorAddressResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetOrchestratorAddressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSetOrchestratorAddressResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSetOrchestratorAddressResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetOrchestratorAddressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSetOrchestratorAddressResponse message.
       * @function verify
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSetOrchestratorAddressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgSetOrchestratorAddressResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse
       */
      MsgSetOrchestratorAddressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSetOrchestratorAddressResponse)
          return object;
        return new $root.gravity.v1.MsgSetOrchestratorAddressResponse();
      };

      /**
       * Creates a plain object from a MsgSetOrchestratorAddressResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @static
       * @param {gravity.v1.MsgSetOrchestratorAddressResponse} message MsgSetOrchestratorAddressResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSetOrchestratorAddressResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSetOrchestratorAddressResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSetOrchestratorAddressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSetOrchestratorAddressResponse;
    })();

    v1.MsgValsetConfirm = (function() {

      /**
       * Properties of a MsgValsetConfirm.
       * @memberof gravity.v1
       * @interface IMsgValsetConfirm
       * @property {number|Long|null} [nonce] MsgValsetConfirm nonce
       * @property {string|null} [orchestrator] MsgValsetConfirm orchestrator
       * @property {string|null} [ethAddress] MsgValsetConfirm ethAddress
       * @property {string|null} [signature] MsgValsetConfirm signature
       */

      /**
       * Constructs a new MsgValsetConfirm.
       * @memberof gravity.v1
       * @classdesc Represents a MsgValsetConfirm.
       * @implements IMsgValsetConfirm
       * @constructor
       * @param {gravity.v1.IMsgValsetConfirm=} [properties] Properties to set
       */
      function MsgValsetConfirm(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgValsetConfirm nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.MsgValsetConfirm
       * @instance
       */
      MsgValsetConfirm.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgValsetConfirm orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgValsetConfirm
       * @instance
       */
      MsgValsetConfirm.prototype.orchestrator = "";

      /**
       * MsgValsetConfirm ethAddress.
       * @member {string} ethAddress
       * @memberof gravity.v1.MsgValsetConfirm
       * @instance
       */
      MsgValsetConfirm.prototype.ethAddress = "";

      /**
       * MsgValsetConfirm signature.
       * @member {string} signature
       * @memberof gravity.v1.MsgValsetConfirm
       * @instance
       */
      MsgValsetConfirm.prototype.signature = "";

      /**
       * Creates a new MsgValsetConfirm instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {gravity.v1.IMsgValsetConfirm=} [properties] Properties to set
       * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm instance
       */
      MsgValsetConfirm.create = function create(properties) {
        return new MsgValsetConfirm(properties);
      };

      /**
       * Encodes the specified MsgValsetConfirm message. Does not implicitly {@link gravity.v1.MsgValsetConfirm.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {gravity.v1.IMsgValsetConfirm} message MsgValsetConfirm message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetConfirm.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestrator);
        if (message.ethAddress != null && Object.hasOwnProperty.call(message, "ethAddress"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.ethAddress);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.signature);
        return writer;
      };

      /**
       * Encodes the specified MsgValsetConfirm message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetConfirm.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {gravity.v1.IMsgValsetConfirm} message MsgValsetConfirm message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetConfirm.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgValsetConfirm message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetConfirm.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetConfirm();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            case 2:
              message.orchestrator = reader.string();
              break;
            case 3:
              message.ethAddress = reader.string();
              break;
            case 4:
              message.signature = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgValsetConfirm message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetConfirm.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgValsetConfirm message.
       * @function verify
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgValsetConfirm.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          if (!$util.isString(message.ethAddress))
            return "ethAddress: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
          if (!$util.isString(message.signature))
            return "signature: string expected";
        return null;
      };

      /**
       * Creates a MsgValsetConfirm message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm
       */
      MsgValsetConfirm.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgValsetConfirm)
          return object;
        let message = new $root.gravity.v1.MsgValsetConfirm();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        if (object.ethAddress != null)
          message.ethAddress = String(object.ethAddress);
        if (object.signature != null)
          message.signature = String(object.signature);
        return message;
      };

      /**
       * Creates a plain object from a MsgValsetConfirm message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgValsetConfirm
       * @static
       * @param {gravity.v1.MsgValsetConfirm} message MsgValsetConfirm
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgValsetConfirm.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
          object.orchestrator = "";
          object.ethAddress = "";
          object.signature = "";
        }
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        if (message.ethAddress != null && message.hasOwnProperty("ethAddress"))
          object.ethAddress = message.ethAddress;
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        return object;
      };

      /**
       * Converts this MsgValsetConfirm to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgValsetConfirm
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgValsetConfirm.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgValsetConfirm;
    })();

    v1.MsgValsetConfirmResponse = (function() {

      /**
       * Properties of a MsgValsetConfirmResponse.
       * @memberof gravity.v1
       * @interface IMsgValsetConfirmResponse
       */

      /**
       * Constructs a new MsgValsetConfirmResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgValsetConfirmResponse.
       * @implements IMsgValsetConfirmResponse
       * @constructor
       * @param {gravity.v1.IMsgValsetConfirmResponse=} [properties] Properties to set
       */
      function MsgValsetConfirmResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgValsetConfirmResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {gravity.v1.IMsgValsetConfirmResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse instance
       */
      MsgValsetConfirmResponse.create = function create(properties) {
        return new MsgValsetConfirmResponse(properties);
      };

      /**
       * Encodes the specified MsgValsetConfirmResponse message. Does not implicitly {@link gravity.v1.MsgValsetConfirmResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {gravity.v1.IMsgValsetConfirmResponse} message MsgValsetConfirmResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetConfirmResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgValsetConfirmResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetConfirmResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {gravity.v1.IMsgValsetConfirmResponse} message MsgValsetConfirmResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetConfirmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgValsetConfirmResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetConfirmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetConfirmResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgValsetConfirmResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetConfirmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgValsetConfirmResponse message.
       * @function verify
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgValsetConfirmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgValsetConfirmResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse
       */
      MsgValsetConfirmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgValsetConfirmResponse)
          return object;
        return new $root.gravity.v1.MsgValsetConfirmResponse();
      };

      /**
       * Creates a plain object from a MsgValsetConfirmResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @static
       * @param {gravity.v1.MsgValsetConfirmResponse} message MsgValsetConfirmResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgValsetConfirmResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgValsetConfirmResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgValsetConfirmResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgValsetConfirmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgValsetConfirmResponse;
    })();

    v1.MsgSendToEth = (function() {

      /**
       * Properties of a MsgSendToEth.
       * @memberof gravity.v1
       * @interface IMsgSendToEth
       * @property {string|null} [sender] MsgSendToEth sender
       * @property {string|null} [ethDest] MsgSendToEth ethDest
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgSendToEth amount
       * @property {cosmos.base.v1beta1.ICoin|null} [bridgeFee] MsgSendToEth bridgeFee
       */

      /**
       * Constructs a new MsgSendToEth.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSendToEth.
       * @implements IMsgSendToEth
       * @constructor
       * @param {gravity.v1.IMsgSendToEth=} [properties] Properties to set
       */
      function MsgSendToEth(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSendToEth sender.
       * @member {string} sender
       * @memberof gravity.v1.MsgSendToEth
       * @instance
       */
      MsgSendToEth.prototype.sender = "";

      /**
       * MsgSendToEth ethDest.
       * @member {string} ethDest
       * @memberof gravity.v1.MsgSendToEth
       * @instance
       */
      MsgSendToEth.prototype.ethDest = "";

      /**
       * MsgSendToEth amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof gravity.v1.MsgSendToEth
       * @instance
       */
      MsgSendToEth.prototype.amount = null;

      /**
       * MsgSendToEth bridgeFee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} bridgeFee
       * @memberof gravity.v1.MsgSendToEth
       * @instance
       */
      MsgSendToEth.prototype.bridgeFee = null;

      /**
       * Creates a new MsgSendToEth instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {gravity.v1.IMsgSendToEth=} [properties] Properties to set
       * @returns {gravity.v1.MsgSendToEth} MsgSendToEth instance
       */
      MsgSendToEth.create = function create(properties) {
        return new MsgSendToEth(properties);
      };

      /**
       * Encodes the specified MsgSendToEth message. Does not implicitly {@link gravity.v1.MsgSendToEth.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {gravity.v1.IMsgSendToEth} message MsgSendToEth message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToEth.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
        if (message.ethDest != null && Object.hasOwnProperty.call(message, "ethDest"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.ethDest);
        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.bridgeFee != null && Object.hasOwnProperty.call(message, "bridgeFee"))
          $root.cosmos.base.v1beta1.Coin.encode(message.bridgeFee, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgSendToEth message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToEth.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {gravity.v1.IMsgSendToEth} message MsgSendToEth message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToEth.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSendToEth message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSendToEth} MsgSendToEth
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToEth.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToEth();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.ethDest = reader.string();
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.bridgeFee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSendToEth message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSendToEth} MsgSendToEth
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToEth.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSendToEth message.
       * @function verify
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSendToEth.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.sender != null && message.hasOwnProperty("sender"))
          if (!$util.isString(message.sender))
            return "sender: string expected";
        if (message.ethDest != null && message.hasOwnProperty("ethDest"))
          if (!$util.isString(message.ethDest))
            return "ethDest: string expected";
        if (message.amount != null && message.hasOwnProperty("amount")) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error)
            return "amount." + error;
        }
        if (message.bridgeFee != null && message.hasOwnProperty("bridgeFee")) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.bridgeFee);
          if (error)
            return "bridgeFee." + error;
        }
        return null;
      };

      /**
       * Creates a MsgSendToEth message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSendToEth} MsgSendToEth
       */
      MsgSendToEth.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSendToEth)
          return object;
        let message = new $root.gravity.v1.MsgSendToEth();
        if (object.sender != null)
          message.sender = String(object.sender);
        if (object.ethDest != null)
          message.ethDest = String(object.ethDest);
        if (object.amount != null) {
          if (typeof object.amount !== "object")
            throw TypeError(".gravity.v1.MsgSendToEth.amount: object expected");
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.bridgeFee != null) {
          if (typeof object.bridgeFee !== "object")
            throw TypeError(".gravity.v1.MsgSendToEth.bridgeFee: object expected");
          message.bridgeFee = $root.cosmos.base.v1beta1.Coin.fromObject(object.bridgeFee);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgSendToEth message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSendToEth
       * @static
       * @param {gravity.v1.MsgSendToEth} message MsgSendToEth
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSendToEth.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.sender = "";
          object.ethDest = "";
          object.amount = null;
          object.bridgeFee = null;
        }
        if (message.sender != null && message.hasOwnProperty("sender"))
          object.sender = message.sender;
        if (message.ethDest != null && message.hasOwnProperty("ethDest"))
          object.ethDest = message.ethDest;
        if (message.amount != null && message.hasOwnProperty("amount"))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.bridgeFee != null && message.hasOwnProperty("bridgeFee"))
          object.bridgeFee = $root.cosmos.base.v1beta1.Coin.toObject(message.bridgeFee, options);
        return object;
      };

      /**
       * Converts this MsgSendToEth to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSendToEth
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSendToEth.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSendToEth;
    })();

    v1.MsgSendToEthResponse = (function() {

      /**
       * Properties of a MsgSendToEthResponse.
       * @memberof gravity.v1
       * @interface IMsgSendToEthResponse
       */

      /**
       * Constructs a new MsgSendToEthResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSendToEthResponse.
       * @implements IMsgSendToEthResponse
       * @constructor
       * @param {gravity.v1.IMsgSendToEthResponse=} [properties] Properties to set
       */
      function MsgSendToEthResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgSendToEthResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {gravity.v1.IMsgSendToEthResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse instance
       */
      MsgSendToEthResponse.create = function create(properties) {
        return new MsgSendToEthResponse(properties);
      };

      /**
       * Encodes the specified MsgSendToEthResponse message. Does not implicitly {@link gravity.v1.MsgSendToEthResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {gravity.v1.IMsgSendToEthResponse} message MsgSendToEthResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToEthResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSendToEthResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToEthResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {gravity.v1.IMsgSendToEthResponse} message MsgSendToEthResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToEthResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSendToEthResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToEthResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToEthResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSendToEthResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToEthResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSendToEthResponse message.
       * @function verify
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSendToEthResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgSendToEthResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse
       */
      MsgSendToEthResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSendToEthResponse)
          return object;
        return new $root.gravity.v1.MsgSendToEthResponse();
      };

      /**
       * Creates a plain object from a MsgSendToEthResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSendToEthResponse
       * @static
       * @param {gravity.v1.MsgSendToEthResponse} message MsgSendToEthResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSendToEthResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSendToEthResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSendToEthResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSendToEthResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSendToEthResponse;
    })();

    v1.MsgRequestBatch = (function() {

      /**
       * Properties of a MsgRequestBatch.
       * @memberof gravity.v1
       * @interface IMsgRequestBatch
       * @property {string|null} [sender] MsgRequestBatch sender
       * @property {string|null} [denom] MsgRequestBatch denom
       */

      /**
       * Constructs a new MsgRequestBatch.
       * @memberof gravity.v1
       * @classdesc Represents a MsgRequestBatch.
       * @implements IMsgRequestBatch
       * @constructor
       * @param {gravity.v1.IMsgRequestBatch=} [properties] Properties to set
       */
      function MsgRequestBatch(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRequestBatch sender.
       * @member {string} sender
       * @memberof gravity.v1.MsgRequestBatch
       * @instance
       */
      MsgRequestBatch.prototype.sender = "";

      /**
       * MsgRequestBatch denom.
       * @member {string} denom
       * @memberof gravity.v1.MsgRequestBatch
       * @instance
       */
      MsgRequestBatch.prototype.denom = "";

      /**
       * Creates a new MsgRequestBatch instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {gravity.v1.IMsgRequestBatch=} [properties] Properties to set
       * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch instance
       */
      MsgRequestBatch.create = function create(properties) {
        return new MsgRequestBatch(properties);
      };

      /**
       * Encodes the specified MsgRequestBatch message. Does not implicitly {@link gravity.v1.MsgRequestBatch.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {gravity.v1.IMsgRequestBatch} message MsgRequestBatch message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRequestBatch.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
        if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified MsgRequestBatch message, length delimited. Does not implicitly {@link gravity.v1.MsgRequestBatch.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {gravity.v1.IMsgRequestBatch} message MsgRequestBatch message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRequestBatch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRequestBatch message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRequestBatch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgRequestBatch();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRequestBatch message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRequestBatch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRequestBatch message.
       * @function verify
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRequestBatch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.sender != null && message.hasOwnProperty("sender"))
          if (!$util.isString(message.sender))
            return "sender: string expected";
        if (message.denom != null && message.hasOwnProperty("denom"))
          if (!$util.isString(message.denom))
            return "denom: string expected";
        return null;
      };

      /**
       * Creates a MsgRequestBatch message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch
       */
      MsgRequestBatch.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgRequestBatch)
          return object;
        let message = new $root.gravity.v1.MsgRequestBatch();
        if (object.sender != null)
          message.sender = String(object.sender);
        if (object.denom != null)
          message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a MsgRequestBatch message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgRequestBatch
       * @static
       * @param {gravity.v1.MsgRequestBatch} message MsgRequestBatch
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRequestBatch.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.sender = "";
          object.denom = "";
        }
        if (message.sender != null && message.hasOwnProperty("sender"))
          object.sender = message.sender;
        if (message.denom != null && message.hasOwnProperty("denom"))
          object.denom = message.denom;
        return object;
      };

      /**
       * Converts this MsgRequestBatch to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgRequestBatch
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRequestBatch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRequestBatch;
    })();

    v1.MsgRequestBatchResponse = (function() {

      /**
       * Properties of a MsgRequestBatchResponse.
       * @memberof gravity.v1
       * @interface IMsgRequestBatchResponse
       */

      /**
       * Constructs a new MsgRequestBatchResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgRequestBatchResponse.
       * @implements IMsgRequestBatchResponse
       * @constructor
       * @param {gravity.v1.IMsgRequestBatchResponse=} [properties] Properties to set
       */
      function MsgRequestBatchResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgRequestBatchResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {gravity.v1.IMsgRequestBatchResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse instance
       */
      MsgRequestBatchResponse.create = function create(properties) {
        return new MsgRequestBatchResponse(properties);
      };

      /**
       * Encodes the specified MsgRequestBatchResponse message. Does not implicitly {@link gravity.v1.MsgRequestBatchResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {gravity.v1.IMsgRequestBatchResponse} message MsgRequestBatchResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRequestBatchResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRequestBatchResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgRequestBatchResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {gravity.v1.IMsgRequestBatchResponse} message MsgRequestBatchResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRequestBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRequestBatchResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRequestBatchResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgRequestBatchResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRequestBatchResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRequestBatchResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRequestBatchResponse message.
       * @function verify
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRequestBatchResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgRequestBatchResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse
       */
      MsgRequestBatchResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgRequestBatchResponse)
          return object;
        return new $root.gravity.v1.MsgRequestBatchResponse();
      };

      /**
       * Creates a plain object from a MsgRequestBatchResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @static
       * @param {gravity.v1.MsgRequestBatchResponse} message MsgRequestBatchResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRequestBatchResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRequestBatchResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgRequestBatchResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRequestBatchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRequestBatchResponse;
    })();

    v1.MsgConfirmBatch = (function() {

      /**
       * Properties of a MsgConfirmBatch.
       * @memberof gravity.v1
       * @interface IMsgConfirmBatch
       * @property {number|Long|null} [nonce] MsgConfirmBatch nonce
       * @property {string|null} [tokenContract] MsgConfirmBatch tokenContract
       * @property {string|null} [ethSigner] MsgConfirmBatch ethSigner
       * @property {string|null} [orchestrator] MsgConfirmBatch orchestrator
       * @property {string|null} [signature] MsgConfirmBatch signature
       */

      /**
       * Constructs a new MsgConfirmBatch.
       * @memberof gravity.v1
       * @classdesc Represents a MsgConfirmBatch.
       * @implements IMsgConfirmBatch
       * @constructor
       * @param {gravity.v1.IMsgConfirmBatch=} [properties] Properties to set
       */
      function MsgConfirmBatch(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgConfirmBatch nonce.
       * @member {number|Long} nonce
       * @memberof gravity.v1.MsgConfirmBatch
       * @instance
       */
      MsgConfirmBatch.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgConfirmBatch tokenContract.
       * @member {string} tokenContract
       * @memberof gravity.v1.MsgConfirmBatch
       * @instance
       */
      MsgConfirmBatch.prototype.tokenContract = "";

      /**
       * MsgConfirmBatch ethSigner.
       * @member {string} ethSigner
       * @memberof gravity.v1.MsgConfirmBatch
       * @instance
       */
      MsgConfirmBatch.prototype.ethSigner = "";

      /**
       * MsgConfirmBatch orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgConfirmBatch
       * @instance
       */
      MsgConfirmBatch.prototype.orchestrator = "";

      /**
       * MsgConfirmBatch signature.
       * @member {string} signature
       * @memberof gravity.v1.MsgConfirmBatch
       * @instance
       */
      MsgConfirmBatch.prototype.signature = "";

      /**
       * Creates a new MsgConfirmBatch instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {gravity.v1.IMsgConfirmBatch=} [properties] Properties to set
       * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch instance
       */
      MsgConfirmBatch.create = function create(properties) {
        return new MsgConfirmBatch(properties);
      };

      /**
       * Encodes the specified MsgConfirmBatch message. Does not implicitly {@link gravity.v1.MsgConfirmBatch.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {gravity.v1.IMsgConfirmBatch} message MsgConfirmBatch message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmBatch.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
        if (message.tokenContract != null && Object.hasOwnProperty.call(message, "tokenContract"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenContract);
        if (message.ethSigner != null && Object.hasOwnProperty.call(message, "ethSigner"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.ethSigner);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.orchestrator);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.signature);
        return writer;
      };

      /**
       * Encodes the specified MsgConfirmBatch message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmBatch.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {gravity.v1.IMsgConfirmBatch} message MsgConfirmBatch message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmBatch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgConfirmBatch message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmBatch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmBatch();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nonce = reader.uint64();
              break;
            case 2:
              message.tokenContract = reader.string();
              break;
            case 3:
              message.ethSigner = reader.string();
              break;
            case 4:
              message.orchestrator = reader.string();
              break;
            case 5:
              message.signature = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgConfirmBatch message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmBatch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgConfirmBatch message.
       * @function verify
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgConfirmBatch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
            return "nonce: integer|Long expected";
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          if (!$util.isString(message.tokenContract))
            return "tokenContract: string expected";
        if (message.ethSigner != null && message.hasOwnProperty("ethSigner"))
          if (!$util.isString(message.ethSigner))
            return "ethSigner: string expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
          if (!$util.isString(message.signature))
            return "signature: string expected";
        return null;
      };

      /**
       * Creates a MsgConfirmBatch message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch
       */
      MsgConfirmBatch.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgConfirmBatch)
          return object;
        let message = new $root.gravity.v1.MsgConfirmBatch();
        if (object.nonce != null)
          if ($util.Long)
            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
          else if (typeof object.nonce === "string")
            message.nonce = parseInt(object.nonce, 10);
          else if (typeof object.nonce === "number")
            message.nonce = object.nonce;
          else if (typeof object.nonce === "object")
            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
        if (object.tokenContract != null)
          message.tokenContract = String(object.tokenContract);
        if (object.ethSigner != null)
          message.ethSigner = String(object.ethSigner);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        if (object.signature != null)
          message.signature = String(object.signature);
        return message;
      };

      /**
       * Creates a plain object from a MsgConfirmBatch message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgConfirmBatch
       * @static
       * @param {gravity.v1.MsgConfirmBatch} message MsgConfirmBatch
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgConfirmBatch.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.nonce = options.longs === String ? "0" : 0;
          object.tokenContract = "";
          object.ethSigner = "";
          object.orchestrator = "";
          object.signature = "";
        }
        if (message.nonce != null && message.hasOwnProperty("nonce"))
          if (typeof message.nonce === "number")
            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
          else
            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          object.tokenContract = message.tokenContract;
        if (message.ethSigner != null && message.hasOwnProperty("ethSigner"))
          object.ethSigner = message.ethSigner;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        return object;
      };

      /**
       * Converts this MsgConfirmBatch to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgConfirmBatch
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgConfirmBatch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgConfirmBatch;
    })();

    v1.MsgConfirmBatchResponse = (function() {

      /**
       * Properties of a MsgConfirmBatchResponse.
       * @memberof gravity.v1
       * @interface IMsgConfirmBatchResponse
       */

      /**
       * Constructs a new MsgConfirmBatchResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgConfirmBatchResponse.
       * @implements IMsgConfirmBatchResponse
       * @constructor
       * @param {gravity.v1.IMsgConfirmBatchResponse=} [properties] Properties to set
       */
      function MsgConfirmBatchResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgConfirmBatchResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {gravity.v1.IMsgConfirmBatchResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse instance
       */
      MsgConfirmBatchResponse.create = function create(properties) {
        return new MsgConfirmBatchResponse(properties);
      };

      /**
       * Encodes the specified MsgConfirmBatchResponse message. Does not implicitly {@link gravity.v1.MsgConfirmBatchResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {gravity.v1.IMsgConfirmBatchResponse} message MsgConfirmBatchResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmBatchResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgConfirmBatchResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmBatchResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {gravity.v1.IMsgConfirmBatchResponse} message MsgConfirmBatchResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgConfirmBatchResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmBatchResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmBatchResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgConfirmBatchResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmBatchResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgConfirmBatchResponse message.
       * @function verify
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgConfirmBatchResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgConfirmBatchResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse
       */
      MsgConfirmBatchResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgConfirmBatchResponse)
          return object;
        return new $root.gravity.v1.MsgConfirmBatchResponse();
      };

      /**
       * Creates a plain object from a MsgConfirmBatchResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @static
       * @param {gravity.v1.MsgConfirmBatchResponse} message MsgConfirmBatchResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgConfirmBatchResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgConfirmBatchResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgConfirmBatchResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgConfirmBatchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgConfirmBatchResponse;
    })();

    v1.MsgConfirmLogicCall = (function() {

      /**
       * Properties of a MsgConfirmLogicCall.
       * @memberof gravity.v1
       * @interface IMsgConfirmLogicCall
       * @property {string|null} [invalidationId] MsgConfirmLogicCall invalidationId
       * @property {number|Long|null} [invalidationNonce] MsgConfirmLogicCall invalidationNonce
       * @property {string|null} [ethSigner] MsgConfirmLogicCall ethSigner
       * @property {string|null} [orchestrator] MsgConfirmLogicCall orchestrator
       * @property {string|null} [signature] MsgConfirmLogicCall signature
       */

      /**
       * Constructs a new MsgConfirmLogicCall.
       * @memberof gravity.v1
       * @classdesc Represents a MsgConfirmLogicCall.
       * @implements IMsgConfirmLogicCall
       * @constructor
       * @param {gravity.v1.IMsgConfirmLogicCall=} [properties] Properties to set
       */
      function MsgConfirmLogicCall(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgConfirmLogicCall invalidationId.
       * @member {string} invalidationId
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @instance
       */
      MsgConfirmLogicCall.prototype.invalidationId = "";

      /**
       * MsgConfirmLogicCall invalidationNonce.
       * @member {number|Long} invalidationNonce
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @instance
       */
      MsgConfirmLogicCall.prototype.invalidationNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgConfirmLogicCall ethSigner.
       * @member {string} ethSigner
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @instance
       */
      MsgConfirmLogicCall.prototype.ethSigner = "";

      /**
       * MsgConfirmLogicCall orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @instance
       */
      MsgConfirmLogicCall.prototype.orchestrator = "";

      /**
       * MsgConfirmLogicCall signature.
       * @member {string} signature
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @instance
       */
      MsgConfirmLogicCall.prototype.signature = "";

      /**
       * Creates a new MsgConfirmLogicCall instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {gravity.v1.IMsgConfirmLogicCall=} [properties] Properties to set
       * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall instance
       */
      MsgConfirmLogicCall.create = function create(properties) {
        return new MsgConfirmLogicCall(properties);
      };

      /**
       * Encodes the specified MsgConfirmLogicCall message. Does not implicitly {@link gravity.v1.MsgConfirmLogicCall.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {gravity.v1.IMsgConfirmLogicCall} message MsgConfirmLogicCall message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmLogicCall.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.invalidationId != null && Object.hasOwnProperty.call(message, "invalidationId"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.invalidationId);
        if (message.invalidationNonce != null && Object.hasOwnProperty.call(message, "invalidationNonce"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.invalidationNonce);
        if (message.ethSigner != null && Object.hasOwnProperty.call(message, "ethSigner"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.ethSigner);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.orchestrator);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.signature);
        return writer;
      };

      /**
       * Encodes the specified MsgConfirmLogicCall message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmLogicCall.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {gravity.v1.IMsgConfirmLogicCall} message MsgConfirmLogicCall message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmLogicCall.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgConfirmLogicCall message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmLogicCall.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmLogicCall();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.invalidationId = reader.string();
              break;
            case 2:
              message.invalidationNonce = reader.uint64();
              break;
            case 3:
              message.ethSigner = reader.string();
              break;
            case 4:
              message.orchestrator = reader.string();
              break;
            case 5:
              message.signature = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgConfirmLogicCall message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmLogicCall.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgConfirmLogicCall message.
       * @function verify
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgConfirmLogicCall.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          if (!$util.isString(message.invalidationId))
            return "invalidationId: string expected";
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (!$util.isInteger(message.invalidationNonce) && !(message.invalidationNonce && $util.isInteger(message.invalidationNonce.low) && $util.isInteger(message.invalidationNonce.high)))
            return "invalidationNonce: integer|Long expected";
        if (message.ethSigner != null && message.hasOwnProperty("ethSigner"))
          if (!$util.isString(message.ethSigner))
            return "ethSigner: string expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
          if (!$util.isString(message.signature))
            return "signature: string expected";
        return null;
      };

      /**
       * Creates a MsgConfirmLogicCall message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall
       */
      MsgConfirmLogicCall.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgConfirmLogicCall)
          return object;
        let message = new $root.gravity.v1.MsgConfirmLogicCall();
        if (object.invalidationId != null)
          message.invalidationId = String(object.invalidationId);
        if (object.invalidationNonce != null)
          if ($util.Long)
            (message.invalidationNonce = $util.Long.fromValue(object.invalidationNonce)).unsigned = true;
          else if (typeof object.invalidationNonce === "string")
            message.invalidationNonce = parseInt(object.invalidationNonce, 10);
          else if (typeof object.invalidationNonce === "number")
            message.invalidationNonce = object.invalidationNonce;
          else if (typeof object.invalidationNonce === "object")
            message.invalidationNonce = new $util.LongBits(object.invalidationNonce.low >>> 0, object.invalidationNonce.high >>> 0).toNumber(true);
        if (object.ethSigner != null)
          message.ethSigner = String(object.ethSigner);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        if (object.signature != null)
          message.signature = String(object.signature);
        return message;
      };

      /**
       * Creates a plain object from a MsgConfirmLogicCall message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @static
       * @param {gravity.v1.MsgConfirmLogicCall} message MsgConfirmLogicCall
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgConfirmLogicCall.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.invalidationId = "";
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.invalidationNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.invalidationNonce = options.longs === String ? "0" : 0;
          object.ethSigner = "";
          object.orchestrator = "";
          object.signature = "";
        }
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          object.invalidationId = message.invalidationId;
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (typeof message.invalidationNonce === "number")
            object.invalidationNonce = options.longs === String ? String(message.invalidationNonce) : message.invalidationNonce;
          else
            object.invalidationNonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidationNonce) : options.longs === Number ? new $util.LongBits(message.invalidationNonce.low >>> 0, message.invalidationNonce.high >>> 0).toNumber(true) : message.invalidationNonce;
        if (message.ethSigner != null && message.hasOwnProperty("ethSigner"))
          object.ethSigner = message.ethSigner;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        return object;
      };

      /**
       * Converts this MsgConfirmLogicCall to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgConfirmLogicCall
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgConfirmLogicCall.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgConfirmLogicCall;
    })();

    v1.MsgConfirmLogicCallResponse = (function() {

      /**
       * Properties of a MsgConfirmLogicCallResponse.
       * @memberof gravity.v1
       * @interface IMsgConfirmLogicCallResponse
       */

      /**
       * Constructs a new MsgConfirmLogicCallResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgConfirmLogicCallResponse.
       * @implements IMsgConfirmLogicCallResponse
       * @constructor
       * @param {gravity.v1.IMsgConfirmLogicCallResponse=} [properties] Properties to set
       */
      function MsgConfirmLogicCallResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgConfirmLogicCallResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {gravity.v1.IMsgConfirmLogicCallResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse instance
       */
      MsgConfirmLogicCallResponse.create = function create(properties) {
        return new MsgConfirmLogicCallResponse(properties);
      };

      /**
       * Encodes the specified MsgConfirmLogicCallResponse message. Does not implicitly {@link gravity.v1.MsgConfirmLogicCallResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {gravity.v1.IMsgConfirmLogicCallResponse} message MsgConfirmLogicCallResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmLogicCallResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgConfirmLogicCallResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmLogicCallResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {gravity.v1.IMsgConfirmLogicCallResponse} message MsgConfirmLogicCallResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgConfirmLogicCallResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgConfirmLogicCallResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmLogicCallResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmLogicCallResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgConfirmLogicCallResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgConfirmLogicCallResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgConfirmLogicCallResponse message.
       * @function verify
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgConfirmLogicCallResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgConfirmLogicCallResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse
       */
      MsgConfirmLogicCallResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgConfirmLogicCallResponse)
          return object;
        return new $root.gravity.v1.MsgConfirmLogicCallResponse();
      };

      /**
       * Creates a plain object from a MsgConfirmLogicCallResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @static
       * @param {gravity.v1.MsgConfirmLogicCallResponse} message MsgConfirmLogicCallResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgConfirmLogicCallResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgConfirmLogicCallResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgConfirmLogicCallResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgConfirmLogicCallResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgConfirmLogicCallResponse;
    })();

    v1.MsgSendToCosmosClaim = (function() {

      /**
       * Properties of a MsgSendToCosmosClaim.
       * @memberof gravity.v1
       * @interface IMsgSendToCosmosClaim
       * @property {number|Long|null} [eventNonce] MsgSendToCosmosClaim eventNonce
       * @property {number|Long|null} [blockHeight] MsgSendToCosmosClaim blockHeight
       * @property {string|null} [tokenContract] MsgSendToCosmosClaim tokenContract
       * @property {string|null} [amount] MsgSendToCosmosClaim amount
       * @property {string|null} [ethereumSender] MsgSendToCosmosClaim ethereumSender
       * @property {string|null} [cosmosReceiver] MsgSendToCosmosClaim cosmosReceiver
       * @property {string|null} [orchestrator] MsgSendToCosmosClaim orchestrator
       */

      /**
       * Constructs a new MsgSendToCosmosClaim.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSendToCosmosClaim.
       * @implements IMsgSendToCosmosClaim
       * @constructor
       * @param {gravity.v1.IMsgSendToCosmosClaim=} [properties] Properties to set
       */
      function MsgSendToCosmosClaim(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSendToCosmosClaim eventNonce.
       * @member {number|Long} eventNonce
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.eventNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgSendToCosmosClaim blockHeight.
       * @member {number|Long} blockHeight
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgSendToCosmosClaim tokenContract.
       * @member {string} tokenContract
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.tokenContract = "";

      /**
       * MsgSendToCosmosClaim amount.
       * @member {string} amount
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.amount = "";

      /**
       * MsgSendToCosmosClaim ethereumSender.
       * @member {string} ethereumSender
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.ethereumSender = "";

      /**
       * MsgSendToCosmosClaim cosmosReceiver.
       * @member {string} cosmosReceiver
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.cosmosReceiver = "";

      /**
       * MsgSendToCosmosClaim orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       */
      MsgSendToCosmosClaim.prototype.orchestrator = "";

      /**
       * Creates a new MsgSendToCosmosClaim instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {gravity.v1.IMsgSendToCosmosClaim=} [properties] Properties to set
       * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim instance
       */
      MsgSendToCosmosClaim.create = function create(properties) {
        return new MsgSendToCosmosClaim(properties);
      };

      /**
       * Encodes the specified MsgSendToCosmosClaim message. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaim.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {gravity.v1.IMsgSendToCosmosClaim} message MsgSendToCosmosClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToCosmosClaim.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.eventNonce != null && Object.hasOwnProperty.call(message, "eventNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eventNonce);
        if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockHeight);
        if (message.tokenContract != null && Object.hasOwnProperty.call(message, "tokenContract"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.tokenContract);
        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
        if (message.ethereumSender != null && Object.hasOwnProperty.call(message, "ethereumSender"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.ethereumSender);
        if (message.cosmosReceiver != null && Object.hasOwnProperty.call(message, "cosmosReceiver"))
          writer.uint32(/* id 6, wireType 2 =*/50).string(message.cosmosReceiver);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 7, wireType 2 =*/58).string(message.orchestrator);
        return writer;
      };

      /**
       * Encodes the specified MsgSendToCosmosClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {gravity.v1.IMsgSendToCosmosClaim} message MsgSendToCosmosClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToCosmosClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSendToCosmosClaim message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToCosmosClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToCosmosClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.eventNonce = reader.uint64();
              break;
            case 2:
              message.blockHeight = reader.uint64();
              break;
            case 3:
              message.tokenContract = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.ethereumSender = reader.string();
              break;
            case 6:
              message.cosmosReceiver = reader.string();
              break;
            case 7:
              message.orchestrator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSendToCosmosClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToCosmosClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSendToCosmosClaim message.
       * @function verify
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSendToCosmosClaim.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (!$util.isInteger(message.eventNonce) && !(message.eventNonce && $util.isInteger(message.eventNonce.low) && $util.isInteger(message.eventNonce.high)))
            return "eventNonce: integer|Long expected";
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
            return "blockHeight: integer|Long expected";
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          if (!$util.isString(message.tokenContract))
            return "tokenContract: string expected";
        if (message.amount != null && message.hasOwnProperty("amount"))
          if (!$util.isString(message.amount))
            return "amount: string expected";
        if (message.ethereumSender != null && message.hasOwnProperty("ethereumSender"))
          if (!$util.isString(message.ethereumSender))
            return "ethereumSender: string expected";
        if (message.cosmosReceiver != null && message.hasOwnProperty("cosmosReceiver"))
          if (!$util.isString(message.cosmosReceiver))
            return "cosmosReceiver: string expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        return null;
      };

      /**
       * Creates a MsgSendToCosmosClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim
       */
      MsgSendToCosmosClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSendToCosmosClaim)
          return object;
        let message = new $root.gravity.v1.MsgSendToCosmosClaim();
        if (object.eventNonce != null)
          if ($util.Long)
            (message.eventNonce = $util.Long.fromValue(object.eventNonce)).unsigned = true;
          else if (typeof object.eventNonce === "string")
            message.eventNonce = parseInt(object.eventNonce, 10);
          else if (typeof object.eventNonce === "number")
            message.eventNonce = object.eventNonce;
          else if (typeof object.eventNonce === "object")
            message.eventNonce = new $util.LongBits(object.eventNonce.low >>> 0, object.eventNonce.high >>> 0).toNumber(true);
        if (object.blockHeight != null)
          if ($util.Long)
            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
          else if (typeof object.blockHeight === "string")
            message.blockHeight = parseInt(object.blockHeight, 10);
          else if (typeof object.blockHeight === "number")
            message.blockHeight = object.blockHeight;
          else if (typeof object.blockHeight === "object")
            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
        if (object.tokenContract != null)
          message.tokenContract = String(object.tokenContract);
        if (object.amount != null)
          message.amount = String(object.amount);
        if (object.ethereumSender != null)
          message.ethereumSender = String(object.ethereumSender);
        if (object.cosmosReceiver != null)
          message.cosmosReceiver = String(object.cosmosReceiver);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        return message;
      };

      /**
       * Creates a plain object from a MsgSendToCosmosClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @static
       * @param {gravity.v1.MsgSendToCosmosClaim} message MsgSendToCosmosClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSendToCosmosClaim.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.eventNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.eventNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.blockHeight = options.longs === String ? "0" : 0;
          object.tokenContract = "";
          object.amount = "";
          object.ethereumSender = "";
          object.cosmosReceiver = "";
          object.orchestrator = "";
        }
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (typeof message.eventNonce === "number")
            object.eventNonce = options.longs === String ? String(message.eventNonce) : message.eventNonce;
          else
            object.eventNonce = options.longs === String ? $util.Long.prototype.toString.call(message.eventNonce) : options.longs === Number ? new $util.LongBits(message.eventNonce.low >>> 0, message.eventNonce.high >>> 0).toNumber(true) : message.eventNonce;
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (typeof message.blockHeight === "number")
            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
          else
            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          object.tokenContract = message.tokenContract;
        if (message.amount != null && message.hasOwnProperty("amount"))
          object.amount = message.amount;
        if (message.ethereumSender != null && message.hasOwnProperty("ethereumSender"))
          object.ethereumSender = message.ethereumSender;
        if (message.cosmosReceiver != null && message.hasOwnProperty("cosmosReceiver"))
          object.cosmosReceiver = message.cosmosReceiver;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        return object;
      };

      /**
       * Converts this MsgSendToCosmosClaim to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSendToCosmosClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSendToCosmosClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSendToCosmosClaim;
    })();

    v1.MsgSendToCosmosClaimResponse = (function() {

      /**
       * Properties of a MsgSendToCosmosClaimResponse.
       * @memberof gravity.v1
       * @interface IMsgSendToCosmosClaimResponse
       */

      /**
       * Constructs a new MsgSendToCosmosClaimResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSendToCosmosClaimResponse.
       * @implements IMsgSendToCosmosClaimResponse
       * @constructor
       * @param {gravity.v1.IMsgSendToCosmosClaimResponse=} [properties] Properties to set
       */
      function MsgSendToCosmosClaimResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgSendToCosmosClaimResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {gravity.v1.IMsgSendToCosmosClaimResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse instance
       */
      MsgSendToCosmosClaimResponse.create = function create(properties) {
        return new MsgSendToCosmosClaimResponse(properties);
      };

      /**
       * Encodes the specified MsgSendToCosmosClaimResponse message. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaimResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {gravity.v1.IMsgSendToCosmosClaimResponse} message MsgSendToCosmosClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToCosmosClaimResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSendToCosmosClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaimResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {gravity.v1.IMsgSendToCosmosClaimResponse} message MsgSendToCosmosClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendToCosmosClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSendToCosmosClaimResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToCosmosClaimResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToCosmosClaimResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSendToCosmosClaimResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendToCosmosClaimResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSendToCosmosClaimResponse message.
       * @function verify
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSendToCosmosClaimResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgSendToCosmosClaimResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse
       */
      MsgSendToCosmosClaimResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSendToCosmosClaimResponse)
          return object;
        return new $root.gravity.v1.MsgSendToCosmosClaimResponse();
      };

      /**
       * Creates a plain object from a MsgSendToCosmosClaimResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @static
       * @param {gravity.v1.MsgSendToCosmosClaimResponse} message MsgSendToCosmosClaimResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSendToCosmosClaimResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSendToCosmosClaimResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSendToCosmosClaimResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSendToCosmosClaimResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSendToCosmosClaimResponse;
    })();

    v1.MsgBatchSendToEthClaim = (function() {

      /**
       * Properties of a MsgBatchSendToEthClaim.
       * @memberof gravity.v1
       * @interface IMsgBatchSendToEthClaim
       * @property {number|Long|null} [eventNonce] MsgBatchSendToEthClaim eventNonce
       * @property {number|Long|null} [blockHeight] MsgBatchSendToEthClaim blockHeight
       * @property {number|Long|null} [batchNonce] MsgBatchSendToEthClaim batchNonce
       * @property {string|null} [tokenContract] MsgBatchSendToEthClaim tokenContract
       * @property {string|null} [orchestrator] MsgBatchSendToEthClaim orchestrator
       */

      /**
       * Constructs a new MsgBatchSendToEthClaim.
       * @memberof gravity.v1
       * @classdesc Represents a MsgBatchSendToEthClaim.
       * @implements IMsgBatchSendToEthClaim
       * @constructor
       * @param {gravity.v1.IMsgBatchSendToEthClaim=} [properties] Properties to set
       */
      function MsgBatchSendToEthClaim(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgBatchSendToEthClaim eventNonce.
       * @member {number|Long} eventNonce
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @instance
       */
      MsgBatchSendToEthClaim.prototype.eventNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgBatchSendToEthClaim blockHeight.
       * @member {number|Long} blockHeight
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @instance
       */
      MsgBatchSendToEthClaim.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgBatchSendToEthClaim batchNonce.
       * @member {number|Long} batchNonce
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @instance
       */
      MsgBatchSendToEthClaim.prototype.batchNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgBatchSendToEthClaim tokenContract.
       * @member {string} tokenContract
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @instance
       */
      MsgBatchSendToEthClaim.prototype.tokenContract = "";

      /**
       * MsgBatchSendToEthClaim orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @instance
       */
      MsgBatchSendToEthClaim.prototype.orchestrator = "";

      /**
       * Creates a new MsgBatchSendToEthClaim instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {gravity.v1.IMsgBatchSendToEthClaim=} [properties] Properties to set
       * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim instance
       */
      MsgBatchSendToEthClaim.create = function create(properties) {
        return new MsgBatchSendToEthClaim(properties);
      };

      /**
       * Encodes the specified MsgBatchSendToEthClaim message. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaim.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {gravity.v1.IMsgBatchSendToEthClaim} message MsgBatchSendToEthClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBatchSendToEthClaim.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.eventNonce != null && Object.hasOwnProperty.call(message, "eventNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eventNonce);
        if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockHeight);
        if (message.batchNonce != null && Object.hasOwnProperty.call(message, "batchNonce"))
          writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.batchNonce);
        if (message.tokenContract != null && Object.hasOwnProperty.call(message, "tokenContract"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.tokenContract);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.orchestrator);
        return writer;
      };

      /**
       * Encodes the specified MsgBatchSendToEthClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {gravity.v1.IMsgBatchSendToEthClaim} message MsgBatchSendToEthClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBatchSendToEthClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBatchSendToEthClaim message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBatchSendToEthClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgBatchSendToEthClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.eventNonce = reader.uint64();
              break;
            case 2:
              message.blockHeight = reader.uint64();
              break;
            case 3:
              message.batchNonce = reader.uint64();
              break;
            case 4:
              message.tokenContract = reader.string();
              break;
            case 5:
              message.orchestrator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBatchSendToEthClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBatchSendToEthClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBatchSendToEthClaim message.
       * @function verify
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBatchSendToEthClaim.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (!$util.isInteger(message.eventNonce) && !(message.eventNonce && $util.isInteger(message.eventNonce.low) && $util.isInteger(message.eventNonce.high)))
            return "eventNonce: integer|Long expected";
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
            return "blockHeight: integer|Long expected";
        if (message.batchNonce != null && message.hasOwnProperty("batchNonce"))
          if (!$util.isInteger(message.batchNonce) && !(message.batchNonce && $util.isInteger(message.batchNonce.low) && $util.isInteger(message.batchNonce.high)))
            return "batchNonce: integer|Long expected";
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          if (!$util.isString(message.tokenContract))
            return "tokenContract: string expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        return null;
      };

      /**
       * Creates a MsgBatchSendToEthClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim
       */
      MsgBatchSendToEthClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgBatchSendToEthClaim)
          return object;
        let message = new $root.gravity.v1.MsgBatchSendToEthClaim();
        if (object.eventNonce != null)
          if ($util.Long)
            (message.eventNonce = $util.Long.fromValue(object.eventNonce)).unsigned = true;
          else if (typeof object.eventNonce === "string")
            message.eventNonce = parseInt(object.eventNonce, 10);
          else if (typeof object.eventNonce === "number")
            message.eventNonce = object.eventNonce;
          else if (typeof object.eventNonce === "object")
            message.eventNonce = new $util.LongBits(object.eventNonce.low >>> 0, object.eventNonce.high >>> 0).toNumber(true);
        if (object.blockHeight != null)
          if ($util.Long)
            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
          else if (typeof object.blockHeight === "string")
            message.blockHeight = parseInt(object.blockHeight, 10);
          else if (typeof object.blockHeight === "number")
            message.blockHeight = object.blockHeight;
          else if (typeof object.blockHeight === "object")
            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
        if (object.batchNonce != null)
          if ($util.Long)
            (message.batchNonce = $util.Long.fromValue(object.batchNonce)).unsigned = true;
          else if (typeof object.batchNonce === "string")
            message.batchNonce = parseInt(object.batchNonce, 10);
          else if (typeof object.batchNonce === "number")
            message.batchNonce = object.batchNonce;
          else if (typeof object.batchNonce === "object")
            message.batchNonce = new $util.LongBits(object.batchNonce.low >>> 0, object.batchNonce.high >>> 0).toNumber(true);
        if (object.tokenContract != null)
          message.tokenContract = String(object.tokenContract);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        return message;
      };

      /**
       * Creates a plain object from a MsgBatchSendToEthClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @static
       * @param {gravity.v1.MsgBatchSendToEthClaim} message MsgBatchSendToEthClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBatchSendToEthClaim.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.eventNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.eventNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.blockHeight = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.batchNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.batchNonce = options.longs === String ? "0" : 0;
          object.tokenContract = "";
          object.orchestrator = "";
        }
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (typeof message.eventNonce === "number")
            object.eventNonce = options.longs === String ? String(message.eventNonce) : message.eventNonce;
          else
            object.eventNonce = options.longs === String ? $util.Long.prototype.toString.call(message.eventNonce) : options.longs === Number ? new $util.LongBits(message.eventNonce.low >>> 0, message.eventNonce.high >>> 0).toNumber(true) : message.eventNonce;
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (typeof message.blockHeight === "number")
            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
          else
            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
        if (message.batchNonce != null && message.hasOwnProperty("batchNonce"))
          if (typeof message.batchNonce === "number")
            object.batchNonce = options.longs === String ? String(message.batchNonce) : message.batchNonce;
          else
            object.batchNonce = options.longs === String ? $util.Long.prototype.toString.call(message.batchNonce) : options.longs === Number ? new $util.LongBits(message.batchNonce.low >>> 0, message.batchNonce.high >>> 0).toNumber(true) : message.batchNonce;
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          object.tokenContract = message.tokenContract;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        return object;
      };

      /**
       * Converts this MsgBatchSendToEthClaim to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgBatchSendToEthClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBatchSendToEthClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBatchSendToEthClaim;
    })();

    v1.MsgBatchSendToEthClaimResponse = (function() {

      /**
       * Properties of a MsgBatchSendToEthClaimResponse.
       * @memberof gravity.v1
       * @interface IMsgBatchSendToEthClaimResponse
       */

      /**
       * Constructs a new MsgBatchSendToEthClaimResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgBatchSendToEthClaimResponse.
       * @implements IMsgBatchSendToEthClaimResponse
       * @constructor
       * @param {gravity.v1.IMsgBatchSendToEthClaimResponse=} [properties] Properties to set
       */
      function MsgBatchSendToEthClaimResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgBatchSendToEthClaimResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {gravity.v1.IMsgBatchSendToEthClaimResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse instance
       */
      MsgBatchSendToEthClaimResponse.create = function create(properties) {
        return new MsgBatchSendToEthClaimResponse(properties);
      };

      /**
       * Encodes the specified MsgBatchSendToEthClaimResponse message. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaimResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {gravity.v1.IMsgBatchSendToEthClaimResponse} message MsgBatchSendToEthClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBatchSendToEthClaimResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgBatchSendToEthClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaimResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {gravity.v1.IMsgBatchSendToEthClaimResponse} message MsgBatchSendToEthClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBatchSendToEthClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBatchSendToEthClaimResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBatchSendToEthClaimResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgBatchSendToEthClaimResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBatchSendToEthClaimResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBatchSendToEthClaimResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBatchSendToEthClaimResponse message.
       * @function verify
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBatchSendToEthClaimResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgBatchSendToEthClaimResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse
       */
      MsgBatchSendToEthClaimResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgBatchSendToEthClaimResponse)
          return object;
        return new $root.gravity.v1.MsgBatchSendToEthClaimResponse();
      };

      /**
       * Creates a plain object from a MsgBatchSendToEthClaimResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @static
       * @param {gravity.v1.MsgBatchSendToEthClaimResponse} message MsgBatchSendToEthClaimResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBatchSendToEthClaimResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgBatchSendToEthClaimResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBatchSendToEthClaimResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBatchSendToEthClaimResponse;
    })();

    v1.MsgERC20DeployedClaim = (function() {

      /**
       * Properties of a MsgERC20DeployedClaim.
       * @memberof gravity.v1
       * @interface IMsgERC20DeployedClaim
       * @property {number|Long|null} [eventNonce] MsgERC20DeployedClaim eventNonce
       * @property {number|Long|null} [blockHeight] MsgERC20DeployedClaim blockHeight
       * @property {string|null} [cosmosDenom] MsgERC20DeployedClaim cosmosDenom
       * @property {string|null} [tokenContract] MsgERC20DeployedClaim tokenContract
       * @property {string|null} [name] MsgERC20DeployedClaim name
       * @property {string|null} [symbol] MsgERC20DeployedClaim symbol
       * @property {number|Long|null} [decimals] MsgERC20DeployedClaim decimals
       * @property {string|null} [orchestrator] MsgERC20DeployedClaim orchestrator
       */

      /**
       * Constructs a new MsgERC20DeployedClaim.
       * @memberof gravity.v1
       * @classdesc Represents a MsgERC20DeployedClaim.
       * @implements IMsgERC20DeployedClaim
       * @constructor
       * @param {gravity.v1.IMsgERC20DeployedClaim=} [properties] Properties to set
       */
      function MsgERC20DeployedClaim(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgERC20DeployedClaim eventNonce.
       * @member {number|Long} eventNonce
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.eventNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgERC20DeployedClaim blockHeight.
       * @member {number|Long} blockHeight
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgERC20DeployedClaim cosmosDenom.
       * @member {string} cosmosDenom
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.cosmosDenom = "";

      /**
       * MsgERC20DeployedClaim tokenContract.
       * @member {string} tokenContract
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.tokenContract = "";

      /**
       * MsgERC20DeployedClaim name.
       * @member {string} name
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.name = "";

      /**
       * MsgERC20DeployedClaim symbol.
       * @member {string} symbol
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.symbol = "";

      /**
       * MsgERC20DeployedClaim decimals.
       * @member {number|Long} decimals
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.decimals = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgERC20DeployedClaim orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       */
      MsgERC20DeployedClaim.prototype.orchestrator = "";

      /**
       * Creates a new MsgERC20DeployedClaim instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {gravity.v1.IMsgERC20DeployedClaim=} [properties] Properties to set
       * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim instance
       */
      MsgERC20DeployedClaim.create = function create(properties) {
        return new MsgERC20DeployedClaim(properties);
      };

      /**
       * Encodes the specified MsgERC20DeployedClaim message. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaim.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {gravity.v1.IMsgERC20DeployedClaim} message MsgERC20DeployedClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgERC20DeployedClaim.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.eventNonce != null && Object.hasOwnProperty.call(message, "eventNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eventNonce);
        if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockHeight);
        if (message.cosmosDenom != null && Object.hasOwnProperty.call(message, "cosmosDenom"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.cosmosDenom);
        if (message.tokenContract != null && Object.hasOwnProperty.call(message, "tokenContract"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.tokenContract);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
        if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
          writer.uint32(/* id 6, wireType 2 =*/50).string(message.symbol);
        if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
          writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.decimals);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 8, wireType 2 =*/66).string(message.orchestrator);
        return writer;
      };

      /**
       * Encodes the specified MsgERC20DeployedClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {gravity.v1.IMsgERC20DeployedClaim} message MsgERC20DeployedClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgERC20DeployedClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgERC20DeployedClaim message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgERC20DeployedClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgERC20DeployedClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.eventNonce = reader.uint64();
              break;
            case 2:
              message.blockHeight = reader.uint64();
              break;
            case 3:
              message.cosmosDenom = reader.string();
              break;
            case 4:
              message.tokenContract = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            case 7:
              message.decimals = reader.uint64();
              break;
            case 8:
              message.orchestrator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgERC20DeployedClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgERC20DeployedClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgERC20DeployedClaim message.
       * @function verify
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgERC20DeployedClaim.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (!$util.isInteger(message.eventNonce) && !(message.eventNonce && $util.isInteger(message.eventNonce.low) && $util.isInteger(message.eventNonce.high)))
            return "eventNonce: integer|Long expected";
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
            return "blockHeight: integer|Long expected";
        if (message.cosmosDenom != null && message.hasOwnProperty("cosmosDenom"))
          if (!$util.isString(message.cosmosDenom))
            return "cosmosDenom: string expected";
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          if (!$util.isString(message.tokenContract))
            return "tokenContract: string expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.symbol != null && message.hasOwnProperty("symbol"))
          if (!$util.isString(message.symbol))
            return "symbol: string expected";
        if (message.decimals != null && message.hasOwnProperty("decimals"))
          if (!$util.isInteger(message.decimals) && !(message.decimals && $util.isInteger(message.decimals.low) && $util.isInteger(message.decimals.high)))
            return "decimals: integer|Long expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        return null;
      };

      /**
       * Creates a MsgERC20DeployedClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim
       */
      MsgERC20DeployedClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgERC20DeployedClaim)
          return object;
        let message = new $root.gravity.v1.MsgERC20DeployedClaim();
        if (object.eventNonce != null)
          if ($util.Long)
            (message.eventNonce = $util.Long.fromValue(object.eventNonce)).unsigned = true;
          else if (typeof object.eventNonce === "string")
            message.eventNonce = parseInt(object.eventNonce, 10);
          else if (typeof object.eventNonce === "number")
            message.eventNonce = object.eventNonce;
          else if (typeof object.eventNonce === "object")
            message.eventNonce = new $util.LongBits(object.eventNonce.low >>> 0, object.eventNonce.high >>> 0).toNumber(true);
        if (object.blockHeight != null)
          if ($util.Long)
            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
          else if (typeof object.blockHeight === "string")
            message.blockHeight = parseInt(object.blockHeight, 10);
          else if (typeof object.blockHeight === "number")
            message.blockHeight = object.blockHeight;
          else if (typeof object.blockHeight === "object")
            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
        if (object.cosmosDenom != null)
          message.cosmosDenom = String(object.cosmosDenom);
        if (object.tokenContract != null)
          message.tokenContract = String(object.tokenContract);
        if (object.name != null)
          message.name = String(object.name);
        if (object.symbol != null)
          message.symbol = String(object.symbol);
        if (object.decimals != null)
          if ($util.Long)
            (message.decimals = $util.Long.fromValue(object.decimals)).unsigned = true;
          else if (typeof object.decimals === "string")
            message.decimals = parseInt(object.decimals, 10);
          else if (typeof object.decimals === "number")
            message.decimals = object.decimals;
          else if (typeof object.decimals === "object")
            message.decimals = new $util.LongBits(object.decimals.low >>> 0, object.decimals.high >>> 0).toNumber(true);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        return message;
      };

      /**
       * Creates a plain object from a MsgERC20DeployedClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @static
       * @param {gravity.v1.MsgERC20DeployedClaim} message MsgERC20DeployedClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgERC20DeployedClaim.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.eventNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.eventNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.blockHeight = options.longs === String ? "0" : 0;
          object.cosmosDenom = "";
          object.tokenContract = "";
          object.name = "";
          object.symbol = "";
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.decimals = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.decimals = options.longs === String ? "0" : 0;
          object.orchestrator = "";
        }
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (typeof message.eventNonce === "number")
            object.eventNonce = options.longs === String ? String(message.eventNonce) : message.eventNonce;
          else
            object.eventNonce = options.longs === String ? $util.Long.prototype.toString.call(message.eventNonce) : options.longs === Number ? new $util.LongBits(message.eventNonce.low >>> 0, message.eventNonce.high >>> 0).toNumber(true) : message.eventNonce;
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (typeof message.blockHeight === "number")
            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
          else
            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
        if (message.cosmosDenom != null && message.hasOwnProperty("cosmosDenom"))
          object.cosmosDenom = message.cosmosDenom;
        if (message.tokenContract != null && message.hasOwnProperty("tokenContract"))
          object.tokenContract = message.tokenContract;
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.symbol != null && message.hasOwnProperty("symbol"))
          object.symbol = message.symbol;
        if (message.decimals != null && message.hasOwnProperty("decimals"))
          if (typeof message.decimals === "number")
            object.decimals = options.longs === String ? String(message.decimals) : message.decimals;
          else
            object.decimals = options.longs === String ? $util.Long.prototype.toString.call(message.decimals) : options.longs === Number ? new $util.LongBits(message.decimals.low >>> 0, message.decimals.high >>> 0).toNumber(true) : message.decimals;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        return object;
      };

      /**
       * Converts this MsgERC20DeployedClaim to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgERC20DeployedClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgERC20DeployedClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgERC20DeployedClaim;
    })();

    v1.MsgERC20DeployedClaimResponse = (function() {

      /**
       * Properties of a MsgERC20DeployedClaimResponse.
       * @memberof gravity.v1
       * @interface IMsgERC20DeployedClaimResponse
       */

      /**
       * Constructs a new MsgERC20DeployedClaimResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgERC20DeployedClaimResponse.
       * @implements IMsgERC20DeployedClaimResponse
       * @constructor
       * @param {gravity.v1.IMsgERC20DeployedClaimResponse=} [properties] Properties to set
       */
      function MsgERC20DeployedClaimResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgERC20DeployedClaimResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {gravity.v1.IMsgERC20DeployedClaimResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse instance
       */
      MsgERC20DeployedClaimResponse.create = function create(properties) {
        return new MsgERC20DeployedClaimResponse(properties);
      };

      /**
       * Encodes the specified MsgERC20DeployedClaimResponse message. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaimResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {gravity.v1.IMsgERC20DeployedClaimResponse} message MsgERC20DeployedClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgERC20DeployedClaimResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgERC20DeployedClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaimResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {gravity.v1.IMsgERC20DeployedClaimResponse} message MsgERC20DeployedClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgERC20DeployedClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgERC20DeployedClaimResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgERC20DeployedClaimResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgERC20DeployedClaimResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgERC20DeployedClaimResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgERC20DeployedClaimResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgERC20DeployedClaimResponse message.
       * @function verify
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgERC20DeployedClaimResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgERC20DeployedClaimResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse
       */
      MsgERC20DeployedClaimResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgERC20DeployedClaimResponse)
          return object;
        return new $root.gravity.v1.MsgERC20DeployedClaimResponse();
      };

      /**
       * Creates a plain object from a MsgERC20DeployedClaimResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @static
       * @param {gravity.v1.MsgERC20DeployedClaimResponse} message MsgERC20DeployedClaimResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgERC20DeployedClaimResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgERC20DeployedClaimResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgERC20DeployedClaimResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgERC20DeployedClaimResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgERC20DeployedClaimResponse;
    })();

    v1.MsgLogicCallExecutedClaim = (function() {

      /**
       * Properties of a MsgLogicCallExecutedClaim.
       * @memberof gravity.v1
       * @interface IMsgLogicCallExecutedClaim
       * @property {number|Long|null} [eventNonce] MsgLogicCallExecutedClaim eventNonce
       * @property {number|Long|null} [blockHeight] MsgLogicCallExecutedClaim blockHeight
       * @property {Uint8Array|null} [invalidationId] MsgLogicCallExecutedClaim invalidationId
       * @property {number|Long|null} [invalidationNonce] MsgLogicCallExecutedClaim invalidationNonce
       * @property {string|null} [orchestrator] MsgLogicCallExecutedClaim orchestrator
       */

      /**
       * Constructs a new MsgLogicCallExecutedClaim.
       * @memberof gravity.v1
       * @classdesc Represents a MsgLogicCallExecutedClaim.
       * @implements IMsgLogicCallExecutedClaim
       * @constructor
       * @param {gravity.v1.IMsgLogicCallExecutedClaim=} [properties] Properties to set
       */
      function MsgLogicCallExecutedClaim(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgLogicCallExecutedClaim eventNonce.
       * @member {number|Long} eventNonce
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @instance
       */
      MsgLogicCallExecutedClaim.prototype.eventNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgLogicCallExecutedClaim blockHeight.
       * @member {number|Long} blockHeight
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @instance
       */
      MsgLogicCallExecutedClaim.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgLogicCallExecutedClaim invalidationId.
       * @member {Uint8Array} invalidationId
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @instance
       */
      MsgLogicCallExecutedClaim.prototype.invalidationId = $util.newBuffer([]);

      /**
       * MsgLogicCallExecutedClaim invalidationNonce.
       * @member {number|Long} invalidationNonce
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @instance
       */
      MsgLogicCallExecutedClaim.prototype.invalidationNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgLogicCallExecutedClaim orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @instance
       */
      MsgLogicCallExecutedClaim.prototype.orchestrator = "";

      /**
       * Creates a new MsgLogicCallExecutedClaim instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {gravity.v1.IMsgLogicCallExecutedClaim=} [properties] Properties to set
       * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim instance
       */
      MsgLogicCallExecutedClaim.create = function create(properties) {
        return new MsgLogicCallExecutedClaim(properties);
      };

      /**
       * Encodes the specified MsgLogicCallExecutedClaim message. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaim.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {gravity.v1.IMsgLogicCallExecutedClaim} message MsgLogicCallExecutedClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLogicCallExecutedClaim.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.eventNonce != null && Object.hasOwnProperty.call(message, "eventNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eventNonce);
        if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockHeight);
        if (message.invalidationId != null && Object.hasOwnProperty.call(message, "invalidationId"))
          writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.invalidationId);
        if (message.invalidationNonce != null && Object.hasOwnProperty.call(message, "invalidationNonce"))
          writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.invalidationNonce);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.orchestrator);
        return writer;
      };

      /**
       * Encodes the specified MsgLogicCallExecutedClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {gravity.v1.IMsgLogicCallExecutedClaim} message MsgLogicCallExecutedClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLogicCallExecutedClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgLogicCallExecutedClaim message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLogicCallExecutedClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgLogicCallExecutedClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.eventNonce = reader.uint64();
              break;
            case 2:
              message.blockHeight = reader.uint64();
              break;
            case 3:
              message.invalidationId = reader.bytes();
              break;
            case 4:
              message.invalidationNonce = reader.uint64();
              break;
            case 5:
              message.orchestrator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgLogicCallExecutedClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLogicCallExecutedClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgLogicCallExecutedClaim message.
       * @function verify
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgLogicCallExecutedClaim.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (!$util.isInteger(message.eventNonce) && !(message.eventNonce && $util.isInteger(message.eventNonce.low) && $util.isInteger(message.eventNonce.high)))
            return "eventNonce: integer|Long expected";
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
            return "blockHeight: integer|Long expected";
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          if (!(message.invalidationId && typeof message.invalidationId.length === "number" || $util.isString(message.invalidationId)))
            return "invalidationId: buffer expected";
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (!$util.isInteger(message.invalidationNonce) && !(message.invalidationNonce && $util.isInteger(message.invalidationNonce.low) && $util.isInteger(message.invalidationNonce.high)))
            return "invalidationNonce: integer|Long expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        return null;
      };

      /**
       * Creates a MsgLogicCallExecutedClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim
       */
      MsgLogicCallExecutedClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgLogicCallExecutedClaim)
          return object;
        let message = new $root.gravity.v1.MsgLogicCallExecutedClaim();
        if (object.eventNonce != null)
          if ($util.Long)
            (message.eventNonce = $util.Long.fromValue(object.eventNonce)).unsigned = true;
          else if (typeof object.eventNonce === "string")
            message.eventNonce = parseInt(object.eventNonce, 10);
          else if (typeof object.eventNonce === "number")
            message.eventNonce = object.eventNonce;
          else if (typeof object.eventNonce === "object")
            message.eventNonce = new $util.LongBits(object.eventNonce.low >>> 0, object.eventNonce.high >>> 0).toNumber(true);
        if (object.blockHeight != null)
          if ($util.Long)
            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
          else if (typeof object.blockHeight === "string")
            message.blockHeight = parseInt(object.blockHeight, 10);
          else if (typeof object.blockHeight === "number")
            message.blockHeight = object.blockHeight;
          else if (typeof object.blockHeight === "object")
            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
        if (object.invalidationId != null)
          if (typeof object.invalidationId === "string")
            $util.base64.decode(object.invalidationId, message.invalidationId = $util.newBuffer($util.base64.length(object.invalidationId)), 0);
          else if (object.invalidationId.length)
            message.invalidationId = object.invalidationId;
        if (object.invalidationNonce != null)
          if ($util.Long)
            (message.invalidationNonce = $util.Long.fromValue(object.invalidationNonce)).unsigned = true;
          else if (typeof object.invalidationNonce === "string")
            message.invalidationNonce = parseInt(object.invalidationNonce, 10);
          else if (typeof object.invalidationNonce === "number")
            message.invalidationNonce = object.invalidationNonce;
          else if (typeof object.invalidationNonce === "object")
            message.invalidationNonce = new $util.LongBits(object.invalidationNonce.low >>> 0, object.invalidationNonce.high >>> 0).toNumber(true);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        return message;
      };

      /**
       * Creates a plain object from a MsgLogicCallExecutedClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @static
       * @param {gravity.v1.MsgLogicCallExecutedClaim} message MsgLogicCallExecutedClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgLogicCallExecutedClaim.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.eventNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.eventNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.blockHeight = options.longs === String ? "0" : 0;
          if (options.bytes === String)
            object.invalidationId = "";
          else {
            object.invalidationId = [];
            if (options.bytes !== Array)
              object.invalidationId = $util.newBuffer(object.invalidationId);
          }
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.invalidationNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.invalidationNonce = options.longs === String ? "0" : 0;
          object.orchestrator = "";
        }
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (typeof message.eventNonce === "number")
            object.eventNonce = options.longs === String ? String(message.eventNonce) : message.eventNonce;
          else
            object.eventNonce = options.longs === String ? $util.Long.prototype.toString.call(message.eventNonce) : options.longs === Number ? new $util.LongBits(message.eventNonce.low >>> 0, message.eventNonce.high >>> 0).toNumber(true) : message.eventNonce;
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (typeof message.blockHeight === "number")
            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
          else
            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
        if (message.invalidationId != null && message.hasOwnProperty("invalidationId"))
          object.invalidationId = options.bytes === String ? $util.base64.encode(message.invalidationId, 0, message.invalidationId.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidationId) : message.invalidationId;
        if (message.invalidationNonce != null && message.hasOwnProperty("invalidationNonce"))
          if (typeof message.invalidationNonce === "number")
            object.invalidationNonce = options.longs === String ? String(message.invalidationNonce) : message.invalidationNonce;
          else
            object.invalidationNonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidationNonce) : options.longs === Number ? new $util.LongBits(message.invalidationNonce.low >>> 0, message.invalidationNonce.high >>> 0).toNumber(true) : message.invalidationNonce;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        return object;
      };

      /**
       * Converts this MsgLogicCallExecutedClaim to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgLogicCallExecutedClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgLogicCallExecutedClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgLogicCallExecutedClaim;
    })();

    v1.MsgLogicCallExecutedClaimResponse = (function() {

      /**
       * Properties of a MsgLogicCallExecutedClaimResponse.
       * @memberof gravity.v1
       * @interface IMsgLogicCallExecutedClaimResponse
       */

      /**
       * Constructs a new MsgLogicCallExecutedClaimResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgLogicCallExecutedClaimResponse.
       * @implements IMsgLogicCallExecutedClaimResponse
       * @constructor
       * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse=} [properties] Properties to set
       */
      function MsgLogicCallExecutedClaimResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgLogicCallExecutedClaimResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse instance
       */
      MsgLogicCallExecutedClaimResponse.create = function create(properties) {
        return new MsgLogicCallExecutedClaimResponse(properties);
      };

      /**
       * Encodes the specified MsgLogicCallExecutedClaimResponse message. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaimResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse} message MsgLogicCallExecutedClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLogicCallExecutedClaimResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgLogicCallExecutedClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaimResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse} message MsgLogicCallExecutedClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLogicCallExecutedClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgLogicCallExecutedClaimResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLogicCallExecutedClaimResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgLogicCallExecutedClaimResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgLogicCallExecutedClaimResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLogicCallExecutedClaimResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgLogicCallExecutedClaimResponse message.
       * @function verify
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgLogicCallExecutedClaimResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgLogicCallExecutedClaimResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse
       */
      MsgLogicCallExecutedClaimResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgLogicCallExecutedClaimResponse)
          return object;
        return new $root.gravity.v1.MsgLogicCallExecutedClaimResponse();
      };

      /**
       * Creates a plain object from a MsgLogicCallExecutedClaimResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @static
       * @param {gravity.v1.MsgLogicCallExecutedClaimResponse} message MsgLogicCallExecutedClaimResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgLogicCallExecutedClaimResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgLogicCallExecutedClaimResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgLogicCallExecutedClaimResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgLogicCallExecutedClaimResponse;
    })();

    v1.MsgValsetUpdatedClaim = (function() {

      /**
       * Properties of a MsgValsetUpdatedClaim.
       * @memberof gravity.v1
       * @interface IMsgValsetUpdatedClaim
       * @property {number|Long|null} [eventNonce] MsgValsetUpdatedClaim eventNonce
       * @property {number|Long|null} [valsetNonce] MsgValsetUpdatedClaim valsetNonce
       * @property {number|Long|null} [blockHeight] MsgValsetUpdatedClaim blockHeight
       * @property {Array.<gravity.v1.IBridgeValidator>|null} [members] MsgValsetUpdatedClaim members
       * @property {string|null} [rewardAmount] MsgValsetUpdatedClaim rewardAmount
       * @property {string|null} [rewardToken] MsgValsetUpdatedClaim rewardToken
       * @property {string|null} [orchestrator] MsgValsetUpdatedClaim orchestrator
       */

      /**
       * Constructs a new MsgValsetUpdatedClaim.
       * @memberof gravity.v1
       * @classdesc Represents a MsgValsetUpdatedClaim.
       * @implements IMsgValsetUpdatedClaim
       * @constructor
       * @param {gravity.v1.IMsgValsetUpdatedClaim=} [properties] Properties to set
       */
      function MsgValsetUpdatedClaim(properties) {
        this.members = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgValsetUpdatedClaim eventNonce.
       * @member {number|Long} eventNonce
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.eventNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgValsetUpdatedClaim valsetNonce.
       * @member {number|Long} valsetNonce
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.valsetNonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgValsetUpdatedClaim blockHeight.
       * @member {number|Long} blockHeight
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgValsetUpdatedClaim members.
       * @member {Array.<gravity.v1.IBridgeValidator>} members
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.members = $util.emptyArray;

      /**
       * MsgValsetUpdatedClaim rewardAmount.
       * @member {string} rewardAmount
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.rewardAmount = "";

      /**
       * MsgValsetUpdatedClaim rewardToken.
       * @member {string} rewardToken
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.rewardToken = "";

      /**
       * MsgValsetUpdatedClaim orchestrator.
       * @member {string} orchestrator
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       */
      MsgValsetUpdatedClaim.prototype.orchestrator = "";

      /**
       * Creates a new MsgValsetUpdatedClaim instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {gravity.v1.IMsgValsetUpdatedClaim=} [properties] Properties to set
       * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim instance
       */
      MsgValsetUpdatedClaim.create = function create(properties) {
        return new MsgValsetUpdatedClaim(properties);
      };

      /**
       * Encodes the specified MsgValsetUpdatedClaim message. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaim.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {gravity.v1.IMsgValsetUpdatedClaim} message MsgValsetUpdatedClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetUpdatedClaim.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.eventNonce != null && Object.hasOwnProperty.call(message, "eventNonce"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eventNonce);
        if (message.valsetNonce != null && Object.hasOwnProperty.call(message, "valsetNonce"))
          writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.valsetNonce);
        if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
          writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.blockHeight);
        if (message.members != null && message.members.length)
          for (let i = 0; i < message.members.length; ++i)
            $root.gravity.v1.BridgeValidator.encode(message.members[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.rewardAmount != null && Object.hasOwnProperty.call(message, "rewardAmount"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message.rewardAmount);
        if (message.rewardToken != null && Object.hasOwnProperty.call(message, "rewardToken"))
          writer.uint32(/* id 6, wireType 2 =*/50).string(message.rewardToken);
        if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
          writer.uint32(/* id 7, wireType 2 =*/58).string(message.orchestrator);
        return writer;
      };

      /**
       * Encodes the specified MsgValsetUpdatedClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {gravity.v1.IMsgValsetUpdatedClaim} message MsgValsetUpdatedClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetUpdatedClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgValsetUpdatedClaim message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetUpdatedClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetUpdatedClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.eventNonce = reader.uint64();
              break;
            case 2:
              message.valsetNonce = reader.uint64();
              break;
            case 3:
              message.blockHeight = reader.uint64();
              break;
            case 4:
              if (!(message.members && message.members.length))
                message.members = [];
              message.members.push($root.gravity.v1.BridgeValidator.decode(reader, reader.uint32()));
              break;
            case 5:
              message.rewardAmount = reader.string();
              break;
            case 6:
              message.rewardToken = reader.string();
              break;
            case 7:
              message.orchestrator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgValsetUpdatedClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetUpdatedClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgValsetUpdatedClaim message.
       * @function verify
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgValsetUpdatedClaim.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (!$util.isInteger(message.eventNonce) && !(message.eventNonce && $util.isInteger(message.eventNonce.low) && $util.isInteger(message.eventNonce.high)))
            return "eventNonce: integer|Long expected";
        if (message.valsetNonce != null && message.hasOwnProperty("valsetNonce"))
          if (!$util.isInteger(message.valsetNonce) && !(message.valsetNonce && $util.isInteger(message.valsetNonce.low) && $util.isInteger(message.valsetNonce.high)))
            return "valsetNonce: integer|Long expected";
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
            return "blockHeight: integer|Long expected";
        if (message.members != null && message.hasOwnProperty("members")) {
          if (!Array.isArray(message.members))
            return "members: array expected";
          for (let i = 0; i < message.members.length; ++i) {
            let error = $root.gravity.v1.BridgeValidator.verify(message.members[i]);
            if (error)
              return "members." + error;
          }
        }
        if (message.rewardAmount != null && message.hasOwnProperty("rewardAmount"))
          if (!$util.isString(message.rewardAmount))
            return "rewardAmount: string expected";
        if (message.rewardToken != null && message.hasOwnProperty("rewardToken"))
          if (!$util.isString(message.rewardToken))
            return "rewardToken: string expected";
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          if (!$util.isString(message.orchestrator))
            return "orchestrator: string expected";
        return null;
      };

      /**
       * Creates a MsgValsetUpdatedClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim
       */
      MsgValsetUpdatedClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgValsetUpdatedClaim)
          return object;
        let message = new $root.gravity.v1.MsgValsetUpdatedClaim();
        if (object.eventNonce != null)
          if ($util.Long)
            (message.eventNonce = $util.Long.fromValue(object.eventNonce)).unsigned = true;
          else if (typeof object.eventNonce === "string")
            message.eventNonce = parseInt(object.eventNonce, 10);
          else if (typeof object.eventNonce === "number")
            message.eventNonce = object.eventNonce;
          else if (typeof object.eventNonce === "object")
            message.eventNonce = new $util.LongBits(object.eventNonce.low >>> 0, object.eventNonce.high >>> 0).toNumber(true);
        if (object.valsetNonce != null)
          if ($util.Long)
            (message.valsetNonce = $util.Long.fromValue(object.valsetNonce)).unsigned = true;
          else if (typeof object.valsetNonce === "string")
            message.valsetNonce = parseInt(object.valsetNonce, 10);
          else if (typeof object.valsetNonce === "number")
            message.valsetNonce = object.valsetNonce;
          else if (typeof object.valsetNonce === "object")
            message.valsetNonce = new $util.LongBits(object.valsetNonce.low >>> 0, object.valsetNonce.high >>> 0).toNumber(true);
        if (object.blockHeight != null)
          if ($util.Long)
            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
          else if (typeof object.blockHeight === "string")
            message.blockHeight = parseInt(object.blockHeight, 10);
          else if (typeof object.blockHeight === "number")
            message.blockHeight = object.blockHeight;
          else if (typeof object.blockHeight === "object")
            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
        if (object.members) {
          if (!Array.isArray(object.members))
            throw TypeError(".gravity.v1.MsgValsetUpdatedClaim.members: array expected");
          message.members = [];
          for (let i = 0; i < object.members.length; ++i) {
            if (typeof object.members[i] !== "object")
              throw TypeError(".gravity.v1.MsgValsetUpdatedClaim.members: object expected");
            message.members[i] = $root.gravity.v1.BridgeValidator.fromObject(object.members[i]);
          }
        }
        if (object.rewardAmount != null)
          message.rewardAmount = String(object.rewardAmount);
        if (object.rewardToken != null)
          message.rewardToken = String(object.rewardToken);
        if (object.orchestrator != null)
          message.orchestrator = String(object.orchestrator);
        return message;
      };

      /**
       * Creates a plain object from a MsgValsetUpdatedClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @static
       * @param {gravity.v1.MsgValsetUpdatedClaim} message MsgValsetUpdatedClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgValsetUpdatedClaim.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.members = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.eventNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.eventNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.valsetNonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.valsetNonce = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.blockHeight = options.longs === String ? "0" : 0;
          object.rewardAmount = "";
          object.rewardToken = "";
          object.orchestrator = "";
        }
        if (message.eventNonce != null && message.hasOwnProperty("eventNonce"))
          if (typeof message.eventNonce === "number")
            object.eventNonce = options.longs === String ? String(message.eventNonce) : message.eventNonce;
          else
            object.eventNonce = options.longs === String ? $util.Long.prototype.toString.call(message.eventNonce) : options.longs === Number ? new $util.LongBits(message.eventNonce.low >>> 0, message.eventNonce.high >>> 0).toNumber(true) : message.eventNonce;
        if (message.valsetNonce != null && message.hasOwnProperty("valsetNonce"))
          if (typeof message.valsetNonce === "number")
            object.valsetNonce = options.longs === String ? String(message.valsetNonce) : message.valsetNonce;
          else
            object.valsetNonce = options.longs === String ? $util.Long.prototype.toString.call(message.valsetNonce) : options.longs === Number ? new $util.LongBits(message.valsetNonce.low >>> 0, message.valsetNonce.high >>> 0).toNumber(true) : message.valsetNonce;
        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
          if (typeof message.blockHeight === "number")
            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
          else
            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
        if (message.members && message.members.length) {
          object.members = [];
          for (let j = 0; j < message.members.length; ++j)
            object.members[j] = $root.gravity.v1.BridgeValidator.toObject(message.members[j], options);
        }
        if (message.rewardAmount != null && message.hasOwnProperty("rewardAmount"))
          object.rewardAmount = message.rewardAmount;
        if (message.rewardToken != null && message.hasOwnProperty("rewardToken"))
          object.rewardToken = message.rewardToken;
        if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
          object.orchestrator = message.orchestrator;
        return object;
      };

      /**
       * Converts this MsgValsetUpdatedClaim to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgValsetUpdatedClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgValsetUpdatedClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgValsetUpdatedClaim;
    })();

    v1.MsgValsetUpdatedClaimResponse = (function() {

      /**
       * Properties of a MsgValsetUpdatedClaimResponse.
       * @memberof gravity.v1
       * @interface IMsgValsetUpdatedClaimResponse
       */

      /**
       * Constructs a new MsgValsetUpdatedClaimResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgValsetUpdatedClaimResponse.
       * @implements IMsgValsetUpdatedClaimResponse
       * @constructor
       * @param {gravity.v1.IMsgValsetUpdatedClaimResponse=} [properties] Properties to set
       */
      function MsgValsetUpdatedClaimResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgValsetUpdatedClaimResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {gravity.v1.IMsgValsetUpdatedClaimResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse instance
       */
      MsgValsetUpdatedClaimResponse.create = function create(properties) {
        return new MsgValsetUpdatedClaimResponse(properties);
      };

      /**
       * Encodes the specified MsgValsetUpdatedClaimResponse message. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaimResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {gravity.v1.IMsgValsetUpdatedClaimResponse} message MsgValsetUpdatedClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetUpdatedClaimResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgValsetUpdatedClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaimResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {gravity.v1.IMsgValsetUpdatedClaimResponse} message MsgValsetUpdatedClaimResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgValsetUpdatedClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgValsetUpdatedClaimResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetUpdatedClaimResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetUpdatedClaimResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgValsetUpdatedClaimResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgValsetUpdatedClaimResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgValsetUpdatedClaimResponse message.
       * @function verify
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgValsetUpdatedClaimResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgValsetUpdatedClaimResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse
       */
      MsgValsetUpdatedClaimResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgValsetUpdatedClaimResponse)
          return object;
        return new $root.gravity.v1.MsgValsetUpdatedClaimResponse();
      };

      /**
       * Creates a plain object from a MsgValsetUpdatedClaimResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @static
       * @param {gravity.v1.MsgValsetUpdatedClaimResponse} message MsgValsetUpdatedClaimResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgValsetUpdatedClaimResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgValsetUpdatedClaimResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgValsetUpdatedClaimResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgValsetUpdatedClaimResponse;
    })();

    v1.MsgCancelSendToEth = (function() {

      /**
       * Properties of a MsgCancelSendToEth.
       * @memberof gravity.v1
       * @interface IMsgCancelSendToEth
       * @property {number|Long|null} [transactionId] MsgCancelSendToEth transactionId
       * @property {string|null} [sender] MsgCancelSendToEth sender
       */

      /**
       * Constructs a new MsgCancelSendToEth.
       * @memberof gravity.v1
       * @classdesc Represents a MsgCancelSendToEth.
       * @implements IMsgCancelSendToEth
       * @constructor
       * @param {gravity.v1.IMsgCancelSendToEth=} [properties] Properties to set
       */
      function MsgCancelSendToEth(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCancelSendToEth transactionId.
       * @member {number|Long} transactionId
       * @memberof gravity.v1.MsgCancelSendToEth
       * @instance
       */
      MsgCancelSendToEth.prototype.transactionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * MsgCancelSendToEth sender.
       * @member {string} sender
       * @memberof gravity.v1.MsgCancelSendToEth
       * @instance
       */
      MsgCancelSendToEth.prototype.sender = "";

      /**
       * Creates a new MsgCancelSendToEth instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {gravity.v1.IMsgCancelSendToEth=} [properties] Properties to set
       * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth instance
       */
      MsgCancelSendToEth.create = function create(properties) {
        return new MsgCancelSendToEth(properties);
      };

      /**
       * Encodes the specified MsgCancelSendToEth message. Does not implicitly {@link gravity.v1.MsgCancelSendToEth.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {gravity.v1.IMsgCancelSendToEth} message MsgCancelSendToEth message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelSendToEth.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
          writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.transactionId);
        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
        return writer;
      };

      /**
       * Encodes the specified MsgCancelSendToEth message, length delimited. Does not implicitly {@link gravity.v1.MsgCancelSendToEth.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {gravity.v1.IMsgCancelSendToEth} message MsgCancelSendToEth message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelSendToEth.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelSendToEth message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelSendToEth.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgCancelSendToEth();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.transactionId = reader.uint64();
              break;
            case 2:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelSendToEth message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelSendToEth.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelSendToEth message.
       * @function verify
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelSendToEth.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
          if (!$util.isInteger(message.transactionId) && !(message.transactionId && $util.isInteger(message.transactionId.low) && $util.isInteger(message.transactionId.high)))
            return "transactionId: integer|Long expected";
        if (message.sender != null && message.hasOwnProperty("sender"))
          if (!$util.isString(message.sender))
            return "sender: string expected";
        return null;
      };

      /**
       * Creates a MsgCancelSendToEth message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth
       */
      MsgCancelSendToEth.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgCancelSendToEth)
          return object;
        let message = new $root.gravity.v1.MsgCancelSendToEth();
        if (object.transactionId != null)
          if ($util.Long)
            (message.transactionId = $util.Long.fromValue(object.transactionId)).unsigned = true;
          else if (typeof object.transactionId === "string")
            message.transactionId = parseInt(object.transactionId, 10);
          else if (typeof object.transactionId === "number")
            message.transactionId = object.transactionId;
          else if (typeof object.transactionId === "object")
            message.transactionId = new $util.LongBits(object.transactionId.low >>> 0, object.transactionId.high >>> 0).toNumber(true);
        if (object.sender != null)
          message.sender = String(object.sender);
        return message;
      };

      /**
       * Creates a plain object from a MsgCancelSendToEth message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgCancelSendToEth
       * @static
       * @param {gravity.v1.MsgCancelSendToEth} message MsgCancelSendToEth
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelSendToEth.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.transactionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.transactionId = options.longs === String ? "0" : 0;
          object.sender = "";
        }
        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
          if (typeof message.transactionId === "number")
            object.transactionId = options.longs === String ? String(message.transactionId) : message.transactionId;
          else
            object.transactionId = options.longs === String ? $util.Long.prototype.toString.call(message.transactionId) : options.longs === Number ? new $util.LongBits(message.transactionId.low >>> 0, message.transactionId.high >>> 0).toNumber(true) : message.transactionId;
        if (message.sender != null && message.hasOwnProperty("sender"))
          object.sender = message.sender;
        return object;
      };

      /**
       * Converts this MsgCancelSendToEth to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgCancelSendToEth
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelSendToEth.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelSendToEth;
    })();

    v1.MsgCancelSendToEthResponse = (function() {

      /**
       * Properties of a MsgCancelSendToEthResponse.
       * @memberof gravity.v1
       * @interface IMsgCancelSendToEthResponse
       */

      /**
       * Constructs a new MsgCancelSendToEthResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgCancelSendToEthResponse.
       * @implements IMsgCancelSendToEthResponse
       * @constructor
       * @param {gravity.v1.IMsgCancelSendToEthResponse=} [properties] Properties to set
       */
      function MsgCancelSendToEthResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgCancelSendToEthResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {gravity.v1.IMsgCancelSendToEthResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse instance
       */
      MsgCancelSendToEthResponse.create = function create(properties) {
        return new MsgCancelSendToEthResponse(properties);
      };

      /**
       * Encodes the specified MsgCancelSendToEthResponse message. Does not implicitly {@link gravity.v1.MsgCancelSendToEthResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {gravity.v1.IMsgCancelSendToEthResponse} message MsgCancelSendToEthResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelSendToEthResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelSendToEthResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgCancelSendToEthResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {gravity.v1.IMsgCancelSendToEthResponse} message MsgCancelSendToEthResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelSendToEthResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelSendToEthResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelSendToEthResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgCancelSendToEthResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelSendToEthResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelSendToEthResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelSendToEthResponse message.
       * @function verify
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelSendToEthResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgCancelSendToEthResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse
       */
      MsgCancelSendToEthResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgCancelSendToEthResponse)
          return object;
        return new $root.gravity.v1.MsgCancelSendToEthResponse();
      };

      /**
       * Creates a plain object from a MsgCancelSendToEthResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @static
       * @param {gravity.v1.MsgCancelSendToEthResponse} message MsgCancelSendToEthResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelSendToEthResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCancelSendToEthResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgCancelSendToEthResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelSendToEthResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelSendToEthResponse;
    })();

    v1.MsgSubmitBadSignatureEvidence = (function() {

      /**
       * Properties of a MsgSubmitBadSignatureEvidence.
       * @memberof gravity.v1
       * @interface IMsgSubmitBadSignatureEvidence
       * @property {google.protobuf.IAny|null} [subject] MsgSubmitBadSignatureEvidence subject
       * @property {string|null} [signature] MsgSubmitBadSignatureEvidence signature
       * @property {string|null} [sender] MsgSubmitBadSignatureEvidence sender
       */

      /**
       * Constructs a new MsgSubmitBadSignatureEvidence.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSubmitBadSignatureEvidence.
       * @implements IMsgSubmitBadSignatureEvidence
       * @constructor
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidence=} [properties] Properties to set
       */
      function MsgSubmitBadSignatureEvidence(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSubmitBadSignatureEvidence subject.
       * @member {google.protobuf.IAny|null|undefined} subject
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @instance
       */
      MsgSubmitBadSignatureEvidence.prototype.subject = null;

      /**
       * MsgSubmitBadSignatureEvidence signature.
       * @member {string} signature
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @instance
       */
      MsgSubmitBadSignatureEvidence.prototype.signature = "";

      /**
       * MsgSubmitBadSignatureEvidence sender.
       * @member {string} sender
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @instance
       */
      MsgSubmitBadSignatureEvidence.prototype.sender = "";

      /**
       * Creates a new MsgSubmitBadSignatureEvidence instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidence=} [properties] Properties to set
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence instance
       */
      MsgSubmitBadSignatureEvidence.create = function create(properties) {
        return new MsgSubmitBadSignatureEvidence(properties);
      };

      /**
       * Encodes the specified MsgSubmitBadSignatureEvidence message. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidence.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} message MsgSubmitBadSignatureEvidence message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSubmitBadSignatureEvidence.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
          $root.google.protobuf.Any.encode(message.subject, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
        if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.sender);
        return writer;
      };

      /**
       * Encodes the specified MsgSubmitBadSignatureEvidence message, length delimited. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidence.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} message MsgSubmitBadSignatureEvidence message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSubmitBadSignatureEvidence.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSubmitBadSignatureEvidence message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSubmitBadSignatureEvidence.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSubmitBadSignatureEvidence();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subject = $root.google.protobuf.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.signature = reader.string();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSubmitBadSignatureEvidence message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSubmitBadSignatureEvidence.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSubmitBadSignatureEvidence message.
       * @function verify
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSubmitBadSignatureEvidence.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.subject != null && message.hasOwnProperty("subject")) {
          let error = $root.google.protobuf.Any.verify(message.subject);
          if (error)
            return "subject." + error;
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
          if (!$util.isString(message.signature))
            return "signature: string expected";
        if (message.sender != null && message.hasOwnProperty("sender"))
          if (!$util.isString(message.sender))
            return "sender: string expected";
        return null;
      };

      /**
       * Creates a MsgSubmitBadSignatureEvidence message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence
       */
      MsgSubmitBadSignatureEvidence.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSubmitBadSignatureEvidence)
          return object;
        let message = new $root.gravity.v1.MsgSubmitBadSignatureEvidence();
        if (object.subject != null) {
          if (typeof object.subject !== "object")
            throw TypeError(".gravity.v1.MsgSubmitBadSignatureEvidence.subject: object expected");
          message.subject = $root.google.protobuf.Any.fromObject(object.subject);
        }
        if (object.signature != null)
          message.signature = String(object.signature);
        if (object.sender != null)
          message.sender = String(object.sender);
        return message;
      };

      /**
       * Creates a plain object from a MsgSubmitBadSignatureEvidence message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @static
       * @param {gravity.v1.MsgSubmitBadSignatureEvidence} message MsgSubmitBadSignatureEvidence
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSubmitBadSignatureEvidence.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.subject = null;
          object.signature = "";
          object.sender = "";
        }
        if (message.subject != null && message.hasOwnProperty("subject"))
          object.subject = $root.google.protobuf.Any.toObject(message.subject, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.sender != null && message.hasOwnProperty("sender"))
          object.sender = message.sender;
        return object;
      };

      /**
       * Converts this MsgSubmitBadSignatureEvidence to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSubmitBadSignatureEvidence.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSubmitBadSignatureEvidence;
    })();

    v1.MsgSubmitBadSignatureEvidenceResponse = (function() {

      /**
       * Properties of a MsgSubmitBadSignatureEvidenceResponse.
       * @memberof gravity.v1
       * @interface IMsgSubmitBadSignatureEvidenceResponse
       */

      /**
       * Constructs a new MsgSubmitBadSignatureEvidenceResponse.
       * @memberof gravity.v1
       * @classdesc Represents a MsgSubmitBadSignatureEvidenceResponse.
       * @implements IMsgSubmitBadSignatureEvidenceResponse
       * @constructor
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse=} [properties] Properties to set
       */
      function MsgSubmitBadSignatureEvidenceResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new MsgSubmitBadSignatureEvidenceResponse instance using the specified properties.
       * @function create
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse=} [properties] Properties to set
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse instance
       */
      MsgSubmitBadSignatureEvidenceResponse.create = function create(properties) {
        return new MsgSubmitBadSignatureEvidenceResponse(properties);
      };

      /**
       * Encodes the specified MsgSubmitBadSignatureEvidenceResponse message. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidenceResponse.verify|verify} messages.
       * @function encode
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse} message MsgSubmitBadSignatureEvidenceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSubmitBadSignatureEvidenceResponse.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSubmitBadSignatureEvidenceResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidenceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse} message MsgSubmitBadSignatureEvidenceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSubmitBadSignatureEvidenceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSubmitBadSignatureEvidenceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSubmitBadSignatureEvidenceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSubmitBadSignatureEvidenceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSubmitBadSignatureEvidenceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSubmitBadSignatureEvidenceResponse message.
       * @function verify
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSubmitBadSignatureEvidenceResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        return null;
      };

      /**
       * Creates a MsgSubmitBadSignatureEvidenceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse
       */
      MsgSubmitBadSignatureEvidenceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse)
          return object;
        return new $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse();
      };

      /**
       * Creates a plain object from a MsgSubmitBadSignatureEvidenceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @static
       * @param {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} message MsgSubmitBadSignatureEvidenceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSubmitBadSignatureEvidenceResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSubmitBadSignatureEvidenceResponse to JSON.
       * @function toJSON
       * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSubmitBadSignatureEvidenceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSubmitBadSignatureEvidenceResponse;
    })();

    return v1;
  })();

  return gravity;
})();

export const google = $root.google = (() => {

  /**
   * Namespace google.
   * @exports google
   * @namespace
   */
  const google = {};

  google.protobuf = (function() {

    /**
     * Namespace protobuf.
     * @memberof google
     * @namespace
     */
    const protobuf = {};

    protobuf.Any = (function() {

      /**
       * Properties of an Any.
       * @memberof google.protobuf
       * @interface IAny
       * @property {string|null} [type_url] Any type_url
       * @property {Uint8Array|null} [value] Any value
       */

      /**
       * Constructs a new Any.
       * @memberof google.protobuf
       * @classdesc Represents an Any.
       * @implements IAny
       * @constructor
       * @param {google.protobuf.IAny=} [properties] Properties to set
       */
      function Any(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Any type_url.
       * @member {string} type_url
       * @memberof google.protobuf.Any
       * @instance
       */
      Any.prototype.type_url = "";

      /**
       * Any value.
       * @member {Uint8Array} value
       * @memberof google.protobuf.Any
       * @instance
       */
      Any.prototype.value = $util.newBuffer([]);

      /**
       * Creates a new Any instance using the specified properties.
       * @function create
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny=} [properties] Properties to set
       * @returns {google.protobuf.Any} Any instance
       */
      Any.create = function create(properties) {
        return new Any(properties);
      };

      /**
       * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny} message Any message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Any.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
          writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
        return writer;
      };

      /**
       * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny} message Any message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Any.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an Any message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Any
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Any} Any
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Any.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type_url = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an Any message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Any
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Any} Any
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Any.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an Any message.
       * @function verify
       * @memberof google.protobuf.Any
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Any.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.type_url != null && message.hasOwnProperty("type_url"))
          if (!$util.isString(message.type_url))
            return "type_url: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
          if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
            return "value: buffer expected";
        return null;
      };

      /**
       * Creates an Any message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Any
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Any} Any
       */
      Any.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Any)
          return object;
        let message = new $root.google.protobuf.Any();
        if (object.type_url != null)
          message.type_url = String(object.type_url);
        if (object.value != null)
          if (typeof object.value === "string")
            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
          else if (object.value.length)
            message.value = object.value;
        return message;
      };

      /**
       * Creates a plain object from an Any message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.Any} message Any
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Any.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.type_url = "";
          if (options.bytes === String)
            object.value = "";
          else {
            object.value = [];
            if (options.bytes !== Array)
              object.value = $util.newBuffer(object.value);
          }
        }
        if (message.type_url != null && message.hasOwnProperty("type_url"))
          object.type_url = message.type_url;
        if (message.value != null && message.hasOwnProperty("value"))
          object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
        return object;
      };

      /**
       * Converts this Any to JSON.
       * @function toJSON
       * @memberof google.protobuf.Any
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Any.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Any;
    })();

    protobuf.FileDescriptorSet = (function() {

      /**
       * Properties of a FileDescriptorSet.
       * @memberof google.protobuf
       * @interface IFileDescriptorSet
       * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
       */

      /**
       * Constructs a new FileDescriptorSet.
       * @memberof google.protobuf
       * @classdesc Represents a FileDescriptorSet.
       * @implements IFileDescriptorSet
       * @constructor
       * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
       */
      function FileDescriptorSet(properties) {
        this.file = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileDescriptorSet file.
       * @member {Array.<google.protobuf.IFileDescriptorProto>} file
       * @memberof google.protobuf.FileDescriptorSet
       * @instance
       */
      FileDescriptorSet.prototype.file = $util.emptyArray;

      /**
       * Creates a new FileDescriptorSet instance using the specified properties.
       * @function create
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
       */
      FileDescriptorSet.create = function create(properties) {
        return new FileDescriptorSet(properties);
      };

      /**
       * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorSet.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.file != null && message.file.length)
          for (let i = 0; i < message.file.length; ++i)
            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileDescriptorSet message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.file && message.file.length))
                message.file = [];
              message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileDescriptorSet message.
       * @function verify
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileDescriptorSet.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.file != null && message.hasOwnProperty("file")) {
          if (!Array.isArray(message.file))
            return "file: array expected";
          for (let i = 0; i < message.file.length; ++i) {
            let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
            if (error)
              return "file." + error;
          }
        }
        return null;
      };

      /**
       * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       */
      FileDescriptorSet.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileDescriptorSet)
          return object;
        let message = new $root.google.protobuf.FileDescriptorSet();
        if (object.file) {
          if (!Array.isArray(object.file))
            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
          message.file = [];
          for (let i = 0; i < object.file.length; ++i) {
            if (typeof object.file[i] !== "object")
              throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileDescriptorSet.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.file = [];
        if (message.file && message.file.length) {
          object.file = [];
          for (let j = 0; j < message.file.length; ++j)
            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
        }
        return object;
      };

      /**
       * Converts this FileDescriptorSet to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileDescriptorSet
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileDescriptorSet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FileDescriptorSet;
    })();

    protobuf.FileDescriptorProto = (function() {

      /**
       * Properties of a FileDescriptorProto.
       * @memberof google.protobuf
       * @interface IFileDescriptorProto
       * @property {string|null} [name] FileDescriptorProto name
       * @property {string|null} ["package"] FileDescriptorProto package
       * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
       * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
       * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
       * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
       * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
       * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
       * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
       * @property {string|null} [syntax] FileDescriptorProto syntax
       */

      /**
       * Constructs a new FileDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a FileDescriptorProto.
       * @implements IFileDescriptorProto
       * @constructor
       * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
       */
      function FileDescriptorProto(properties) {
        this.dependency = [];
        this.publicDependency = [];
        this.weakDependency = [];
        this.messageType = [];
        this.enumType = [];
        this.service = [];
        this.extension = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.name = "";

      /**
       * FileDescriptorProto package.
       * @member {string} package
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype["package"] = "";

      /**
       * FileDescriptorProto dependency.
       * @member {Array.<string>} dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.dependency = $util.emptyArray;

      /**
       * FileDescriptorProto publicDependency.
       * @member {Array.<number>} publicDependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

      /**
       * FileDescriptorProto weakDependency.
       * @member {Array.<number>} weakDependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

      /**
       * FileDescriptorProto messageType.
       * @member {Array.<google.protobuf.IDescriptorProto>} messageType
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.messageType = $util.emptyArray;

      /**
       * FileDescriptorProto enumType.
       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.enumType = $util.emptyArray;

      /**
       * FileDescriptorProto service.
       * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.service = $util.emptyArray;

      /**
       * FileDescriptorProto extension.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.extension = $util.emptyArray;

      /**
       * FileDescriptorProto options.
       * @member {google.protobuf.IFileOptions|null|undefined} options
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.options = null;

      /**
       * FileDescriptorProto sourceCodeInfo.
       * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.sourceCodeInfo = null;

      /**
       * FileDescriptorProto syntax.
       * @member {string} syntax
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.syntax = "";

      /**
       * Creates a new FileDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
       */
      FileDescriptorProto.create = function create(properties) {
        return new FileDescriptorProto(properties);
      };

      /**
       * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
        if (message.dependency != null && message.dependency.length)
          for (let i = 0; i < message.dependency.length; ++i)
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
        if (message.messageType != null && message.messageType.length)
          for (let i = 0; i < message.messageType.length; ++i)
            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.enumType != null && message.enumType.length)
          for (let i = 0; i < message.enumType.length; ++i)
            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.service != null && message.service.length)
          for (let i = 0; i < message.service.length; ++i)
            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.extension != null && message.extension.length)
          for (let i = 0; i < message.extension.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
          $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.publicDependency != null && message.publicDependency.length)
          for (let i = 0; i < message.publicDependency.length; ++i)
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
        if (message.weakDependency != null && message.weakDependency.length)
          for (let i = 0; i < message.weakDependency.length; ++i)
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
        if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
          writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
        return writer;
      };

      /**
       * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message["package"] = reader.string();
              break;
            case 3:
              if (!(message.dependency && message.dependency.length))
                message.dependency = [];
              message.dependency.push(reader.string());
              break;
            case 10:
              if (!(message.publicDependency && message.publicDependency.length))
                message.publicDependency = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicDependency.push(reader.int32());
              } else
                message.publicDependency.push(reader.int32());
              break;
            case 11:
              if (!(message.weakDependency && message.weakDependency.length))
                message.weakDependency = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.weakDependency.push(reader.int32());
              } else
                message.weakDependency.push(reader.int32());
              break;
            case 4:
              if (!(message.messageType && message.messageType.length))
                message.messageType = [];
              message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.enumType && message.enumType.length))
                message.enumType = [];
              message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.service && message.service.length))
                message.service = [];
              message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 7:
              if (!(message.extension && message.extension.length))
                message.extension = [];
              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 8:
              message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
              break;
            case 9:
              message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
              break;
            case 12:
              message.syntax = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message["package"] != null && message.hasOwnProperty("package"))
          if (!$util.isString(message["package"]))
            return "package: string expected";
        if (message.dependency != null && message.hasOwnProperty("dependency")) {
          if (!Array.isArray(message.dependency))
            return "dependency: array expected";
          for (let i = 0; i < message.dependency.length; ++i)
            if (!$util.isString(message.dependency[i]))
              return "dependency: string[] expected";
        }
        if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
          if (!Array.isArray(message.publicDependency))
            return "publicDependency: array expected";
          for (let i = 0; i < message.publicDependency.length; ++i)
            if (!$util.isInteger(message.publicDependency[i]))
              return "publicDependency: integer[] expected";
        }
        if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
          if (!Array.isArray(message.weakDependency))
            return "weakDependency: array expected";
          for (let i = 0; i < message.weakDependency.length; ++i)
            if (!$util.isInteger(message.weakDependency[i]))
              return "weakDependency: integer[] expected";
        }
        if (message.messageType != null && message.hasOwnProperty("messageType")) {
          if (!Array.isArray(message.messageType))
            return "messageType: array expected";
          for (let i = 0; i < message.messageType.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
            if (error)
              return "messageType." + error;
          }
        }
        if (message.enumType != null && message.hasOwnProperty("enumType")) {
          if (!Array.isArray(message.enumType))
            return "enumType: array expected";
          for (let i = 0; i < message.enumType.length; ++i) {
            let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
            if (error)
              return "enumType." + error;
          }
        }
        if (message.service != null && message.hasOwnProperty("service")) {
          if (!Array.isArray(message.service))
            return "service: array expected";
          for (let i = 0; i < message.service.length; ++i) {
            let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
            if (error)
              return "service." + error;
          }
        }
        if (message.extension != null && message.hasOwnProperty("extension")) {
          if (!Array.isArray(message.extension))
            return "extension: array expected";
          for (let i = 0; i < message.extension.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
            if (error)
              return "extension." + error;
          }
        }
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.FileOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
          let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
          if (error)
            return "sourceCodeInfo." + error;
        }
        if (message.syntax != null && message.hasOwnProperty("syntax"))
          if (!$util.isString(message.syntax))
            return "syntax: string expected";
        return null;
      };

      /**
       * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       */
      FileDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileDescriptorProto)
          return object;
        let message = new $root.google.protobuf.FileDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object["package"] != null)
          message["package"] = String(object["package"]);
        if (object.dependency) {
          if (!Array.isArray(object.dependency))
            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
          message.dependency = [];
          for (let i = 0; i < object.dependency.length; ++i)
            message.dependency[i] = String(object.dependency[i]);
        }
        if (object.publicDependency) {
          if (!Array.isArray(object.publicDependency))
            throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
          message.publicDependency = [];
          for (let i = 0; i < object.publicDependency.length; ++i)
            message.publicDependency[i] = object.publicDependency[i] | 0;
        }
        if (object.weakDependency) {
          if (!Array.isArray(object.weakDependency))
            throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
          message.weakDependency = [];
          for (let i = 0; i < object.weakDependency.length; ++i)
            message.weakDependency[i] = object.weakDependency[i] | 0;
        }
        if (object.messageType) {
          if (!Array.isArray(object.messageType))
            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
          message.messageType = [];
          for (let i = 0; i < object.messageType.length; ++i) {
            if (typeof object.messageType[i] !== "object")
              throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
            message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
          }
        }
        if (object.enumType) {
          if (!Array.isArray(object.enumType))
            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
          message.enumType = [];
          for (let i = 0; i < object.enumType.length; ++i) {
            if (typeof object.enumType[i] !== "object")
              throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
            message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
          }
        }
        if (object.service) {
          if (!Array.isArray(object.service))
            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
          message.service = [];
          for (let i = 0; i < object.service.length; ++i) {
            if (typeof object.service[i] !== "object")
              throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
          }
        }
        if (object.extension) {
          if (!Array.isArray(object.extension))
            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
          message.extension = [];
          for (let i = 0; i < object.extension.length; ++i) {
            if (typeof object.extension[i] !== "object")
              throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
        }
        if (object.sourceCodeInfo != null) {
          if (typeof object.sourceCodeInfo !== "object")
            throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
          message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
        }
        if (object.syntax != null)
          message.syntax = String(object.syntax);
        return message;
      };

      /**
       * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.dependency = [];
          object.messageType = [];
          object.enumType = [];
          object.service = [];
          object.extension = [];
          object.publicDependency = [];
          object.weakDependency = [];
        }
        if (options.defaults) {
          object.name = "";
          object["package"] = "";
          object.options = null;
          object.sourceCodeInfo = null;
          object.syntax = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message["package"] != null && message.hasOwnProperty("package"))
          object["package"] = message["package"];
        if (message.dependency && message.dependency.length) {
          object.dependency = [];
          for (let j = 0; j < message.dependency.length; ++j)
            object.dependency[j] = message.dependency[j];
        }
        if (message.messageType && message.messageType.length) {
          object.messageType = [];
          for (let j = 0; j < message.messageType.length; ++j)
            object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
        }
        if (message.enumType && message.enumType.length) {
          object.enumType = [];
          for (let j = 0; j < message.enumType.length; ++j)
            object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
        }
        if (message.service && message.service.length) {
          object.service = [];
          for (let j = 0; j < message.service.length; ++j)
            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
        }
        if (message.extension && message.extension.length) {
          object.extension = [];
          for (let j = 0; j < message.extension.length; ++j)
            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
        }
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
        if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
          object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
        if (message.publicDependency && message.publicDependency.length) {
          object.publicDependency = [];
          for (let j = 0; j < message.publicDependency.length; ++j)
            object.publicDependency[j] = message.publicDependency[j];
        }
        if (message.weakDependency && message.weakDependency.length) {
          object.weakDependency = [];
          for (let j = 0; j < message.weakDependency.length; ++j)
            object.weakDependency[j] = message.weakDependency[j];
        }
        if (message.syntax != null && message.hasOwnProperty("syntax"))
          object.syntax = message.syntax;
        return object;
      };

      /**
       * Converts this FileDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FileDescriptorProto;
    })();

    protobuf.DescriptorProto = (function() {

      /**
       * Properties of a DescriptorProto.
       * @memberof google.protobuf
       * @interface IDescriptorProto
       * @property {string|null} [name] DescriptorProto name
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
       * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
       * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
       * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
       * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
       * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
       * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
       */

      /**
       * Constructs a new DescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a DescriptorProto.
       * @implements IDescriptorProto
       * @constructor
       * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
       */
      function DescriptorProto(properties) {
        this.field = [];
        this.extension = [];
        this.nestedType = [];
        this.enumType = [];
        this.extensionRange = [];
        this.oneofDecl = [];
        this.reservedRange = [];
        this.reservedName = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * DescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.name = "";

      /**
       * DescriptorProto field.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.field = $util.emptyArray;

      /**
       * DescriptorProto extension.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.extension = $util.emptyArray;

      /**
       * DescriptorProto nestedType.
       * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.nestedType = $util.emptyArray;

      /**
       * DescriptorProto enumType.
       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.enumType = $util.emptyArray;

      /**
       * DescriptorProto extensionRange.
       * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.extensionRange = $util.emptyArray;

      /**
       * DescriptorProto oneofDecl.
       * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.oneofDecl = $util.emptyArray;

      /**
       * DescriptorProto options.
       * @member {google.protobuf.IMessageOptions|null|undefined} options
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.options = null;

      /**
       * DescriptorProto reservedRange.
       * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.reservedRange = $util.emptyArray;

      /**
       * DescriptorProto reservedName.
       * @member {Array.<string>} reservedName
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.reservedName = $util.emptyArray;

      /**
       * Creates a new DescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
       */
      DescriptorProto.create = function create(properties) {
        return new DescriptorProto(properties);
      };

      /**
       * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.field != null && message.field.length)
          for (let i = 0; i < message.field.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.nestedType != null && message.nestedType.length)
          for (let i = 0; i < message.nestedType.length; ++i)
            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.enumType != null && message.enumType.length)
          for (let i = 0; i < message.enumType.length; ++i)
            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.extensionRange != null && message.extensionRange.length)
          for (let i = 0; i < message.extensionRange.length; ++i)
            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.extension != null && message.extension.length)
          for (let i = 0; i < message.extension.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.oneofDecl != null && message.oneofDecl.length)
          for (let i = 0; i < message.oneofDecl.length; ++i)
            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.reservedRange != null && message.reservedRange.length)
          for (let i = 0; i < message.reservedRange.length; ++i)
            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.reservedName != null && message.reservedName.length)
          for (let i = 0; i < message.reservedName.length; ++i)
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
        return writer;
      };

      /**
       * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.field && message.field.length))
                message.field = [];
              message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.extension && message.extension.length))
                message.extension = [];
              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.nestedType && message.nestedType.length))
                message.nestedType = [];
              message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
              break;
            case 4:
              if (!(message.enumType && message.enumType.length))
                message.enumType = [];
              message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.extensionRange && message.extensionRange.length))
                message.extensionRange = [];
              message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
              break;
            case 8:
              if (!(message.oneofDecl && message.oneofDecl.length))
                message.oneofDecl = [];
              message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 7:
              message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
              break;
            case 9:
              if (!(message.reservedRange && message.reservedRange.length))
                message.reservedRange = [];
              message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
              break;
            case 10:
              if (!(message.reservedName && message.reservedName.length))
                message.reservedName = [];
              message.reservedName.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DescriptorProto message.
       * @function verify
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.field != null && message.hasOwnProperty("field")) {
          if (!Array.isArray(message.field))
            return "field: array expected";
          for (let i = 0; i < message.field.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
            if (error)
              return "field." + error;
          }
        }
        if (message.extension != null && message.hasOwnProperty("extension")) {
          if (!Array.isArray(message.extension))
            return "extension: array expected";
          for (let i = 0; i < message.extension.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
            if (error)
              return "extension." + error;
          }
        }
        if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
          if (!Array.isArray(message.nestedType))
            return "nestedType: array expected";
          for (let i = 0; i < message.nestedType.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
            if (error)
              return "nestedType." + error;
          }
        }
        if (message.enumType != null && message.hasOwnProperty("enumType")) {
          if (!Array.isArray(message.enumType))
            return "enumType: array expected";
          for (let i = 0; i < message.enumType.length; ++i) {
            let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
            if (error)
              return "enumType." + error;
          }
        }
        if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
          if (!Array.isArray(message.extensionRange))
            return "extensionRange: array expected";
          for (let i = 0; i < message.extensionRange.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
            if (error)
              return "extensionRange." + error;
          }
        }
        if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
          if (!Array.isArray(message.oneofDecl))
            return "oneofDecl: array expected";
          for (let i = 0; i < message.oneofDecl.length; ++i) {
            let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
            if (error)
              return "oneofDecl." + error;
          }
        }
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.MessageOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
          if (!Array.isArray(message.reservedRange))
            return "reservedRange: array expected";
          for (let i = 0; i < message.reservedRange.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
            if (error)
              return "reservedRange." + error;
          }
        }
        if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
          if (!Array.isArray(message.reservedName))
            return "reservedName: array expected";
          for (let i = 0; i < message.reservedName.length; ++i)
            if (!$util.isString(message.reservedName[i]))
              return "reservedName: string[] expected";
        }
        return null;
      };

      /**
       * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       */
      DescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.DescriptorProto)
          return object;
        let message = new $root.google.protobuf.DescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.field) {
          if (!Array.isArray(object.field))
            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
          message.field = [];
          for (let i = 0; i < object.field.length; ++i) {
            if (typeof object.field[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
          }
        }
        if (object.extension) {
          if (!Array.isArray(object.extension))
            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
          message.extension = [];
          for (let i = 0; i < object.extension.length; ++i) {
            if (typeof object.extension[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
          }
        }
        if (object.nestedType) {
          if (!Array.isArray(object.nestedType))
            throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
          message.nestedType = [];
          for (let i = 0; i < object.nestedType.length; ++i) {
            if (typeof object.nestedType[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
            message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
          }
        }
        if (object.enumType) {
          if (!Array.isArray(object.enumType))
            throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
          message.enumType = [];
          for (let i = 0; i < object.enumType.length; ++i) {
            if (typeof object.enumType[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
            message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
          }
        }
        if (object.extensionRange) {
          if (!Array.isArray(object.extensionRange))
            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
          message.extensionRange = [];
          for (let i = 0; i < object.extensionRange.length; ++i) {
            if (typeof object.extensionRange[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
            message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
          }
        }
        if (object.oneofDecl) {
          if (!Array.isArray(object.oneofDecl))
            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
          message.oneofDecl = [];
          for (let i = 0; i < object.oneofDecl.length; ++i) {
            if (typeof object.oneofDecl[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
            message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
          message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
        }
        if (object.reservedRange) {
          if (!Array.isArray(object.reservedRange))
            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
          message.reservedRange = [];
          for (let i = 0; i < object.reservedRange.length; ++i) {
            if (typeof object.reservedRange[i] !== "object")
              throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
            message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
          }
        }
        if (object.reservedName) {
          if (!Array.isArray(object.reservedName))
            throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
          message.reservedName = [];
          for (let i = 0; i < object.reservedName.length; ++i)
            message.reservedName[i] = String(object.reservedName[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.DescriptorProto} message DescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.field = [];
          object.nestedType = [];
          object.enumType = [];
          object.extensionRange = [];
          object.extension = [];
          object.oneofDecl = [];
          object.reservedRange = [];
          object.reservedName = [];
        }
        if (options.defaults) {
          object.name = "";
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.field && message.field.length) {
          object.field = [];
          for (let j = 0; j < message.field.length; ++j)
            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
        }
        if (message.nestedType && message.nestedType.length) {
          object.nestedType = [];
          for (let j = 0; j < message.nestedType.length; ++j)
            object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
        }
        if (message.enumType && message.enumType.length) {
          object.enumType = [];
          for (let j = 0; j < message.enumType.length; ++j)
            object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
        }
        if (message.extensionRange && message.extensionRange.length) {
          object.extensionRange = [];
          for (let j = 0; j < message.extensionRange.length; ++j)
            object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
        }
        if (message.extension && message.extension.length) {
          object.extension = [];
          for (let j = 0; j < message.extension.length; ++j)
            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
        }
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
        if (message.oneofDecl && message.oneofDecl.length) {
          object.oneofDecl = [];
          for (let j = 0; j < message.oneofDecl.length; ++j)
            object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
        }
        if (message.reservedRange && message.reservedRange.length) {
          object.reservedRange = [];
          for (let j = 0; j < message.reservedRange.length; ++j)
            object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
        }
        if (message.reservedName && message.reservedName.length) {
          object.reservedName = [];
          for (let j = 0; j < message.reservedName.length; ++j)
            object.reservedName[j] = message.reservedName[j];
        }
        return object;
      };

      /**
       * Converts this DescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.DescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      DescriptorProto.ExtensionRange = (function() {

        /**
         * Properties of an ExtensionRange.
         * @memberof google.protobuf.DescriptorProto
         * @interface IExtensionRange
         * @property {number|null} [start] ExtensionRange start
         * @property {number|null} [end] ExtensionRange end
         */

        /**
         * Constructs a new ExtensionRange.
         * @memberof google.protobuf.DescriptorProto
         * @classdesc Represents an ExtensionRange.
         * @implements IExtensionRange
         * @constructor
         * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
         */
        function ExtensionRange(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExtensionRange start.
         * @member {number} start
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         */
        ExtensionRange.prototype.start = 0;

        /**
         * ExtensionRange end.
         * @member {number} end
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         */
        ExtensionRange.prototype.end = 0;

        /**
         * Creates a new ExtensionRange instance using the specified properties.
         * @function create
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
         */
        ExtensionRange.create = function create(properties) {
          return new ExtensionRange(properties);
        };

        /**
         * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtensionRange.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, "start"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, "end"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExtensionRange message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtensionRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = reader.int32();
                break;
              case 2:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExtensionRange message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExtensionRange.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.start != null && message.hasOwnProperty("start"))
            if (!$util.isInteger(message.start))
              return "start: integer expected";
          if (message.end != null && message.hasOwnProperty("end"))
            if (!$util.isInteger(message.end))
              return "end: integer expected";
          return null;
        };

        /**
         * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         */
        ExtensionRange.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
            return object;
          let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
          if (object.start != null)
            message.start = object.start | 0;
          if (object.end != null)
            message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExtensionRange.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.start = 0;
            object.end = 0;
          }
          if (message.start != null && message.hasOwnProperty("start"))
            object.start = message.start;
          if (message.end != null && message.hasOwnProperty("end"))
            object.end = message.end;
          return object;
        };

        /**
         * Converts this ExtensionRange to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExtensionRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExtensionRange;
      })();

      DescriptorProto.ReservedRange = (function() {

        /**
         * Properties of a ReservedRange.
         * @memberof google.protobuf.DescriptorProto
         * @interface IReservedRange
         * @property {number|null} [start] ReservedRange start
         * @property {number|null} [end] ReservedRange end
         */

        /**
         * Constructs a new ReservedRange.
         * @memberof google.protobuf.DescriptorProto
         * @classdesc Represents a ReservedRange.
         * @implements IReservedRange
         * @constructor
         * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
         */
        function ReservedRange(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReservedRange start.
         * @member {number} start
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         */
        ReservedRange.prototype.start = 0;

        /**
         * ReservedRange end.
         * @member {number} end
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         */
        ReservedRange.prototype.end = 0;

        /**
         * Creates a new ReservedRange instance using the specified properties.
         * @function create
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
         */
        ReservedRange.create = function create(properties) {
          return new ReservedRange(properties);
        };

        /**
         * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReservedRange.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, "start"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, "end"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReservedRange message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReservedRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = reader.int32();
                break;
              case 2:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReservedRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReservedRange message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReservedRange.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.start != null && message.hasOwnProperty("start"))
            if (!$util.isInteger(message.start))
              return "start: integer expected";
          if (message.end != null && message.hasOwnProperty("end"))
            if (!$util.isInteger(message.end))
              return "end: integer expected";
          return null;
        };

        /**
         * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         */
        ReservedRange.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
            return object;
          let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
          if (object.start != null)
            message.start = object.start | 0;
          if (object.end != null)
            message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReservedRange.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.start = 0;
            object.end = 0;
          }
          if (message.start != null && message.hasOwnProperty("start"))
            object.start = message.start;
          if (message.end != null && message.hasOwnProperty("end"))
            object.end = message.end;
          return object;
        };

        /**
         * Converts this ReservedRange to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReservedRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReservedRange;
      })();

      return DescriptorProto;
    })();

    protobuf.FieldDescriptorProto = (function() {

      /**
       * Properties of a FieldDescriptorProto.
       * @memberof google.protobuf
       * @interface IFieldDescriptorProto
       * @property {string|null} [name] FieldDescriptorProto name
       * @property {number|null} [number] FieldDescriptorProto number
       * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
       * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
       * @property {string|null} [typeName] FieldDescriptorProto typeName
       * @property {string|null} [extendee] FieldDescriptorProto extendee
       * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
       * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
       * @property {string|null} [jsonName] FieldDescriptorProto jsonName
       * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
       */

      /**
       * Constructs a new FieldDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a FieldDescriptorProto.
       * @implements IFieldDescriptorProto
       * @constructor
       * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
       */
      function FieldDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * FieldDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.name = "";

      /**
       * FieldDescriptorProto number.
       * @member {number} number
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.number = 0;

      /**
       * FieldDescriptorProto label.
       * @member {google.protobuf.FieldDescriptorProto.Label} label
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.label = 1;

      /**
       * FieldDescriptorProto type.
       * @member {google.protobuf.FieldDescriptorProto.Type} type
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.type = 1;

      /**
       * FieldDescriptorProto typeName.
       * @member {string} typeName
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.typeName = "";

      /**
       * FieldDescriptorProto extendee.
       * @member {string} extendee
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.extendee = "";

      /**
       * FieldDescriptorProto defaultValue.
       * @member {string} defaultValue
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.defaultValue = "";

      /**
       * FieldDescriptorProto oneofIndex.
       * @member {number} oneofIndex
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.oneofIndex = 0;

      /**
       * FieldDescriptorProto jsonName.
       * @member {string} jsonName
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.jsonName = "";

      /**
       * FieldDescriptorProto options.
       * @member {google.protobuf.IFieldOptions|null|undefined} options
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.options = null;

      /**
       * Creates a new FieldDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
       */
      FieldDescriptorProto.create = function create(properties) {
        return new FieldDescriptorProto(properties);
      };

      /**
       * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
        if (message.number != null && Object.hasOwnProperty.call(message, "number"))
          writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
          writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
          writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
        if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
          writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
        if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
          writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
          writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
        if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
          writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
        return writer;
      };

      /**
       * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FieldDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 3:
              message.number = reader.int32();
              break;
            case 4:
              message.label = reader.int32();
              break;
            case 5:
              message.type = reader.int32();
              break;
            case 6:
              message.typeName = reader.string();
              break;
            case 2:
              message.extendee = reader.string();
              break;
            case 7:
              message.defaultValue = reader.string();
              break;
            case 9:
              message.oneofIndex = reader.int32();
              break;
            case 10:
              message.jsonName = reader.string();
              break;
            case 8:
              message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FieldDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FieldDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.number != null && message.hasOwnProperty("number"))
          if (!$util.isInteger(message.number))
            return "number: integer expected";
        if (message.label != null && message.hasOwnProperty("label"))
          switch (message.label) {
            default:
              return "label: enum value expected";
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.type != null && message.hasOwnProperty("type"))
          switch (message.type) {
            default:
              return "type: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
              break;
          }
        if (message.typeName != null && message.hasOwnProperty("typeName"))
          if (!$util.isString(message.typeName))
            return "typeName: string expected";
        if (message.extendee != null && message.hasOwnProperty("extendee"))
          if (!$util.isString(message.extendee))
            return "extendee: string expected";
        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
          if (!$util.isString(message.defaultValue))
            return "defaultValue: string expected";
        if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
          if (!$util.isInteger(message.oneofIndex))
            return "oneofIndex: integer expected";
        if (message.jsonName != null && message.hasOwnProperty("jsonName"))
          if (!$util.isString(message.jsonName))
            return "jsonName: string expected";
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.FieldOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        return null;
      };

      /**
       * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       */
      FieldDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FieldDescriptorProto)
          return object;
        let message = new $root.google.protobuf.FieldDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.number != null)
          message.number = object.number | 0;
        switch (object.label) {
          case "LABEL_OPTIONAL":
          case 1:
            message.label = 1;
            break;
          case "LABEL_REQUIRED":
          case 2:
            message.label = 2;
            break;
          case "LABEL_REPEATED":
          case 3:
            message.label = 3;
            break;
        }
        switch (object.type) {
          case "TYPE_DOUBLE":
          case 1:
            message.type = 1;
            break;
          case "TYPE_FLOAT":
          case 2:
            message.type = 2;
            break;
          case "TYPE_INT64":
          case 3:
            message.type = 3;
            break;
          case "TYPE_UINT64":
          case 4:
            message.type = 4;
            break;
          case "TYPE_INT32":
          case 5:
            message.type = 5;
            break;
          case "TYPE_FIXED64":
          case 6:
            message.type = 6;
            break;
          case "TYPE_FIXED32":
          case 7:
            message.type = 7;
            break;
          case "TYPE_BOOL":
          case 8:
            message.type = 8;
            break;
          case "TYPE_STRING":
          case 9:
            message.type = 9;
            break;
          case "TYPE_GROUP":
          case 10:
            message.type = 10;
            break;
          case "TYPE_MESSAGE":
          case 11:
            message.type = 11;
            break;
          case "TYPE_BYTES":
          case 12:
            message.type = 12;
            break;
          case "TYPE_UINT32":
          case 13:
            message.type = 13;
            break;
          case "TYPE_ENUM":
          case 14:
            message.type = 14;
            break;
          case "TYPE_SFIXED32":
          case 15:
            message.type = 15;
            break;
          case "TYPE_SFIXED64":
          case 16:
            message.type = 16;
            break;
          case "TYPE_SINT32":
          case 17:
            message.type = 17;
            break;
          case "TYPE_SINT64":
          case 18:
            message.type = 18;
            break;
        }
        if (object.typeName != null)
          message.typeName = String(object.typeName);
        if (object.extendee != null)
          message.extendee = String(object.extendee);
        if (object.defaultValue != null)
          message.defaultValue = String(object.defaultValue);
        if (object.oneofIndex != null)
          message.oneofIndex = object.oneofIndex | 0;
        if (object.jsonName != null)
          message.jsonName = String(object.jsonName);
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FieldDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.name = "";
          object.extendee = "";
          object.number = 0;
          object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
          object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
          object.typeName = "";
          object.defaultValue = "";
          object.options = null;
          object.oneofIndex = 0;
          object.jsonName = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.extendee != null && message.hasOwnProperty("extendee"))
          object.extendee = message.extendee;
        if (message.number != null && message.hasOwnProperty("number"))
          object.number = message.number;
        if (message.label != null && message.hasOwnProperty("label"))
          object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
        if (message.type != null && message.hasOwnProperty("type"))
          object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
        if (message.typeName != null && message.hasOwnProperty("typeName"))
          object.typeName = message.typeName;
        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
          object.defaultValue = message.defaultValue;
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
        if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
          object.oneofIndex = message.oneofIndex;
        if (message.jsonName != null && message.hasOwnProperty("jsonName"))
          object.jsonName = message.jsonName;
        return object;
      };

      /**
       * Converts this FieldDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FieldDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * Type enum.
       * @name google.protobuf.FieldDescriptorProto.Type
       * @enum {number}
       * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
       * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
       * @property {number} TYPE_INT64=3 TYPE_INT64 value
       * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
       * @property {number} TYPE_INT32=5 TYPE_INT32 value
       * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
       * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
       * @property {number} TYPE_BOOL=8 TYPE_BOOL value
       * @property {number} TYPE_STRING=9 TYPE_STRING value
       * @property {number} TYPE_GROUP=10 TYPE_GROUP value
       * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
       * @property {number} TYPE_BYTES=12 TYPE_BYTES value
       * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
       * @property {number} TYPE_ENUM=14 TYPE_ENUM value
       * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
       * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
       * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
       * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
       */
      FieldDescriptorProto.Type = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "TYPE_DOUBLE"] = 1;
        values[valuesById[2] = "TYPE_FLOAT"] = 2;
        values[valuesById[3] = "TYPE_INT64"] = 3;
        values[valuesById[4] = "TYPE_UINT64"] = 4;
        values[valuesById[5] = "TYPE_INT32"] = 5;
        values[valuesById[6] = "TYPE_FIXED64"] = 6;
        values[valuesById[7] = "TYPE_FIXED32"] = 7;
        values[valuesById[8] = "TYPE_BOOL"] = 8;
        values[valuesById[9] = "TYPE_STRING"] = 9;
        values[valuesById[10] = "TYPE_GROUP"] = 10;
        values[valuesById[11] = "TYPE_MESSAGE"] = 11;
        values[valuesById[12] = "TYPE_BYTES"] = 12;
        values[valuesById[13] = "TYPE_UINT32"] = 13;
        values[valuesById[14] = "TYPE_ENUM"] = 14;
        values[valuesById[15] = "TYPE_SFIXED32"] = 15;
        values[valuesById[16] = "TYPE_SFIXED64"] = 16;
        values[valuesById[17] = "TYPE_SINT32"] = 17;
        values[valuesById[18] = "TYPE_SINT64"] = 18;
        return values;
      })();

      /**
       * Label enum.
       * @name google.protobuf.FieldDescriptorProto.Label
       * @enum {number}
       * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
       * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
       * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
       */
      FieldDescriptorProto.Label = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
        values[valuesById[2] = "LABEL_REQUIRED"] = 2;
        values[valuesById[3] = "LABEL_REPEATED"] = 3;
        return values;
      })();

      return FieldDescriptorProto;
    })();

    protobuf.OneofDescriptorProto = (function() {

      /**
       * Properties of an OneofDescriptorProto.
       * @memberof google.protobuf
       * @interface IOneofDescriptorProto
       * @property {string|null} [name] OneofDescriptorProto name
       * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
       */

      /**
       * Constructs a new OneofDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an OneofDescriptorProto.
       * @implements IOneofDescriptorProto
       * @constructor
       * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
       */
      function OneofDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * OneofDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       */
      OneofDescriptorProto.prototype.name = "";

      /**
       * OneofDescriptorProto options.
       * @member {google.protobuf.IOneofOptions|null|undefined} options
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       */
      OneofDescriptorProto.prototype.options = null;

      /**
       * Creates a new OneofDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
       */
      OneofDescriptorProto.create = function create(properties) {
        return new OneofDescriptorProto(properties);
      };

      /**
       * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OneofDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OneofDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OneofDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.OneofOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        return null;
      };

      /**
       * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       */
      OneofDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.OneofDescriptorProto)
          return object;
        let message = new $root.google.protobuf.OneofDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OneofDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.name = "";
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this OneofDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OneofDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OneofDescriptorProto;
    })();

    protobuf.EnumDescriptorProto = (function() {

      /**
       * Properties of an EnumDescriptorProto.
       * @memberof google.protobuf
       * @interface IEnumDescriptorProto
       * @property {string|null} [name] EnumDescriptorProto name
       * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
       * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
       */

      /**
       * Constructs a new EnumDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an EnumDescriptorProto.
       * @implements IEnumDescriptorProto
       * @constructor
       * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
       */
      function EnumDescriptorProto(properties) {
        this.value = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.name = "";

      /**
       * EnumDescriptorProto value.
       * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.value = $util.emptyArray;

      /**
       * EnumDescriptorProto options.
       * @member {google.protobuf.IEnumOptions|null|undefined} options
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.options = null;

      /**
       * Creates a new EnumDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
       */
      EnumDescriptorProto.create = function create(properties) {
        return new EnumDescriptorProto(properties);
      };

      /**
       * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.value != null && message.value.length)
          for (let i = 0; i < message.value.length; ++i)
            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.value && message.value.length))
                message.value = [];
              message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.value != null && message.hasOwnProperty("value")) {
          if (!Array.isArray(message.value))
            return "value: array expected";
          for (let i = 0; i < message.value.length; ++i) {
            let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
            if (error)
              return "value." + error;
          }
        }
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.EnumOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        return null;
      };

      /**
       * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       */
      EnumDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumDescriptorProto)
          return object;
        let message = new $root.google.protobuf.EnumDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.value) {
          if (!Array.isArray(object.value))
            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
          message.value = [];
          for (let i = 0; i < object.value.length; ++i) {
            if (typeof object.value[i] !== "object")
              throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.value = [];
        if (options.defaults) {
          object.name = "";
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.value && message.value.length) {
          object.value = [];
          for (let j = 0; j < message.value.length; ++j)
            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
        }
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this EnumDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumDescriptorProto;
    })();

    protobuf.EnumValueDescriptorProto = (function() {

      /**
       * Properties of an EnumValueDescriptorProto.
       * @memberof google.protobuf
       * @interface IEnumValueDescriptorProto
       * @property {string|null} [name] EnumValueDescriptorProto name
       * @property {number|null} [number] EnumValueDescriptorProto number
       * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
       */

      /**
       * Constructs a new EnumValueDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an EnumValueDescriptorProto.
       * @implements IEnumValueDescriptorProto
       * @constructor
       * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
       */
      function EnumValueDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumValueDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.name = "";

      /**
       * EnumValueDescriptorProto number.
       * @member {number} number
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.number = 0;

      /**
       * EnumValueDescriptorProto options.
       * @member {google.protobuf.IEnumValueOptions|null|undefined} options
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.options = null;

      /**
       * Creates a new EnumValueDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
       */
      EnumValueDescriptorProto.create = function create(properties) {
        return new EnumValueDescriptorProto(properties);
      };

      /**
       * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.number != null && Object.hasOwnProperty.call(message, "number"))
          writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.number = reader.int32();
              break;
            case 3:
              message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumValueDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumValueDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.number != null && message.hasOwnProperty("number"))
          if (!$util.isInteger(message.number))
            return "number: integer expected";
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        return null;
      };

      /**
       * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       */
      EnumValueDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
          return object;
        let message = new $root.google.protobuf.EnumValueDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.number != null)
          message.number = object.number | 0;
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumValueDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.name = "";
          object.number = 0;
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.number != null && message.hasOwnProperty("number"))
          object.number = message.number;
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this EnumValueDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumValueDescriptorProto;
    })();

    protobuf.ServiceDescriptorProto = (function() {

      /**
       * Properties of a ServiceDescriptorProto.
       * @memberof google.protobuf
       * @interface IServiceDescriptorProto
       * @property {string|null} [name] ServiceDescriptorProto name
       * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
       * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
       */

      /**
       * Constructs a new ServiceDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a ServiceDescriptorProto.
       * @implements IServiceDescriptorProto
       * @constructor
       * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
       */
      function ServiceDescriptorProto(properties) {
        this.method = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.name = "";

      /**
       * ServiceDescriptorProto method.
       * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.method = $util.emptyArray;

      /**
       * ServiceDescriptorProto options.
       * @member {google.protobuf.IServiceOptions|null|undefined} options
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.options = null;

      /**
       * Creates a new ServiceDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
       */
      ServiceDescriptorProto.create = function create(properties) {
        return new ServiceDescriptorProto(properties);
      };

      /**
       * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.method != null && message.method.length)
          for (let i = 0; i < message.method.length; ++i)
            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.method && message.method.length))
                message.method = [];
              message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.method != null && message.hasOwnProperty("method")) {
          if (!Array.isArray(message.method))
            return "method: array expected";
          for (let i = 0; i < message.method.length; ++i) {
            let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
            if (error)
              return "method." + error;
          }
        }
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.ServiceOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        return null;
      };

      /**
       * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       */
      ServiceDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
          return object;
        let message = new $root.google.protobuf.ServiceDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.method) {
          if (!Array.isArray(object.method))
            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
          message.method = [];
          for (let i = 0; i < object.method.length; ++i) {
            if (typeof object.method[i] !== "object")
              throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.method = [];
        if (options.defaults) {
          object.name = "";
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.method && message.method.length) {
          object.method = [];
          for (let j = 0; j < message.method.length; ++j)
            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
        }
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this ServiceDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ServiceDescriptorProto;
    })();

    protobuf.MethodDescriptorProto = (function() {

      /**
       * Properties of a MethodDescriptorProto.
       * @memberof google.protobuf
       * @interface IMethodDescriptorProto
       * @property {string|null} [name] MethodDescriptorProto name
       * @property {string|null} [inputType] MethodDescriptorProto inputType
       * @property {string|null} [outputType] MethodDescriptorProto outputType
       * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
       * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
       * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
       */

      /**
       * Constructs a new MethodDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a MethodDescriptorProto.
       * @implements IMethodDescriptorProto
       * @constructor
       * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
       */
      function MethodDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MethodDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.name = "";

      /**
       * MethodDescriptorProto inputType.
       * @member {string} inputType
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.inputType = "";

      /**
       * MethodDescriptorProto outputType.
       * @member {string} outputType
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.outputType = "";

      /**
       * MethodDescriptorProto options.
       * @member {google.protobuf.IMethodOptions|null|undefined} options
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.options = null;

      /**
       * MethodDescriptorProto clientStreaming.
       * @member {boolean} clientStreaming
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.clientStreaming = false;

      /**
       * MethodDescriptorProto serverStreaming.
       * @member {boolean} serverStreaming
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.serverStreaming = false;

      /**
       * Creates a new MethodDescriptorProto instance using the specified properties.
       * @function create
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
       */
      MethodDescriptorProto.create = function create(properties) {
        return new MethodDescriptorProto(properties);
      };

      /**
       * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodDescriptorProto.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
        if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
        if (message.options != null && Object.hasOwnProperty.call(message, "options"))
          $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
          writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
        if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
          writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
        return writer;
      };

      /**
       * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MethodDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.inputType = reader.string();
              break;
            case 3:
              message.outputType = reader.string();
              break;
            case 4:
              message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
              break;
            case 5:
              message.clientStreaming = reader.bool();
              break;
            case 6:
              message.serverStreaming = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MethodDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MethodDescriptorProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
          if (!$util.isString(message.name))
            return "name: string expected";
        if (message.inputType != null && message.hasOwnProperty("inputType"))
          if (!$util.isString(message.inputType))
            return "inputType: string expected";
        if (message.outputType != null && message.hasOwnProperty("outputType"))
          if (!$util.isString(message.outputType))
            return "outputType: string expected";
        if (message.options != null && message.hasOwnProperty("options")) {
          let error = $root.google.protobuf.MethodOptions.verify(message.options);
          if (error)
            return "options." + error;
        }
        if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
          if (typeof message.clientStreaming !== "boolean")
            return "clientStreaming: boolean expected";
        if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
          if (typeof message.serverStreaming !== "boolean")
            return "serverStreaming: boolean expected";
        return null;
      };

      /**
       * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       */
      MethodDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MethodDescriptorProto)
          return object;
        let message = new $root.google.protobuf.MethodDescriptorProto();
        if (object.name != null)
          message.name = String(object.name);
        if (object.inputType != null)
          message.inputType = String(object.inputType);
        if (object.outputType != null)
          message.outputType = String(object.outputType);
        if (object.options != null) {
          if (typeof object.options !== "object")
            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
          message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
        }
        if (object.clientStreaming != null)
          message.clientStreaming = Boolean(object.clientStreaming);
        if (object.serverStreaming != null)
          message.serverStreaming = Boolean(object.serverStreaming);
        return message;
      };

      /**
       * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MethodDescriptorProto.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.name = "";
          object.inputType = "";
          object.outputType = "";
          object.options = null;
          object.clientStreaming = false;
          object.serverStreaming = false;
        }
        if (message.name != null && message.hasOwnProperty("name"))
          object.name = message.name;
        if (message.inputType != null && message.hasOwnProperty("inputType"))
          object.inputType = message.inputType;
        if (message.outputType != null && message.hasOwnProperty("outputType"))
          object.outputType = message.outputType;
        if (message.options != null && message.hasOwnProperty("options"))
          object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
        if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
          object.clientStreaming = message.clientStreaming;
        if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
          object.serverStreaming = message.serverStreaming;
        return object;
      };

      /**
       * Converts this MethodDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MethodDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MethodDescriptorProto;
    })();

    protobuf.FileOptions = (function() {

      /**
       * Properties of a FileOptions.
       * @memberof google.protobuf
       * @interface IFileOptions
       * @property {string|null} [javaPackage] FileOptions javaPackage
       * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
       * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
       * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
       * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
       * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
       * @property {string|null} [goPackage] FileOptions goPackage
       * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
       * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
       * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
       * @property {boolean|null} [deprecated] FileOptions deprecated
       * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
       * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
       * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
       */

      /**
       * Constructs a new FileOptions.
       * @memberof google.protobuf
       * @classdesc Represents a FileOptions.
       * @implements IFileOptions
       * @constructor
       * @param {google.protobuf.IFileOptions=} [properties] Properties to set
       */
      function FileOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileOptions javaPackage.
       * @member {string} javaPackage
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.javaPackage = "";

      /**
       * FileOptions javaOuterClassname.
       * @member {string} javaOuterClassname
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.javaOuterClassname = "";

      /**
       * FileOptions javaMultipleFiles.
       * @member {boolean} javaMultipleFiles
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.javaMultipleFiles = false;

      /**
       * FileOptions javaGenerateEqualsAndHash.
       * @member {boolean} javaGenerateEqualsAndHash
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.javaGenerateEqualsAndHash = false;

      /**
       * FileOptions javaStringCheckUtf8.
       * @member {boolean} javaStringCheckUtf8
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.javaStringCheckUtf8 = false;

      /**
       * FileOptions optimizeFor.
       * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.optimizeFor = 1;

      /**
       * FileOptions goPackage.
       * @member {string} goPackage
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.goPackage = "";

      /**
       * FileOptions ccGenericServices.
       * @member {boolean} ccGenericServices
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.ccGenericServices = false;

      /**
       * FileOptions javaGenericServices.
       * @member {boolean} javaGenericServices
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.javaGenericServices = false;

      /**
       * FileOptions pyGenericServices.
       * @member {boolean} pyGenericServices
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.pyGenericServices = false;

      /**
       * FileOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.deprecated = false;

      /**
       * FileOptions ccEnableArenas.
       * @member {boolean} ccEnableArenas
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.ccEnableArenas = false;

      /**
       * FileOptions objcClassPrefix.
       * @member {string} objcClassPrefix
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.objcClassPrefix = "";

      /**
       * FileOptions csharpNamespace.
       * @member {string} csharpNamespace
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.csharpNamespace = "";

      /**
       * FileOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new FileOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions=} [properties] Properties to set
       * @returns {google.protobuf.FileOptions} FileOptions instance
       */
      FileOptions.create = function create(properties) {
        return new FileOptions(properties);
      };

      /**
       * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
        if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
          writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
        if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
          writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
        if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
          writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
        if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
          writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
        if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
          writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
        if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
          writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
        if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
          writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
        if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
          writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
        if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
          writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
        if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
          writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
        if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
          writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
        if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
          writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileOptions} FileOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.javaPackage = reader.string();
              break;
            case 8:
              message.javaOuterClassname = reader.string();
              break;
            case 10:
              message.javaMultipleFiles = reader.bool();
              break;
            case 20:
              message.javaGenerateEqualsAndHash = reader.bool();
              break;
            case 27:
              message.javaStringCheckUtf8 = reader.bool();
              break;
            case 9:
              message.optimizeFor = reader.int32();
              break;
            case 11:
              message.goPackage = reader.string();
              break;
            case 16:
              message.ccGenericServices = reader.bool();
              break;
            case 17:
              message.javaGenericServices = reader.bool();
              break;
            case 18:
              message.pyGenericServices = reader.bool();
              break;
            case 23:
              message.deprecated = reader.bool();
              break;
            case 31:
              message.ccEnableArenas = reader.bool();
              break;
            case 36:
              message.objcClassPrefix = reader.string();
              break;
            case 37:
              message.csharpNamespace = reader.string();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileOptions} FileOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileOptions message.
       * @function verify
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
          if (!$util.isString(message.javaPackage))
            return "javaPackage: string expected";
        if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
          if (!$util.isString(message.javaOuterClassname))
            return "javaOuterClassname: string expected";
        if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
          if (typeof message.javaMultipleFiles !== "boolean")
            return "javaMultipleFiles: boolean expected";
        if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
          if (typeof message.javaGenerateEqualsAndHash !== "boolean")
            return "javaGenerateEqualsAndHash: boolean expected";
        if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
          if (typeof message.javaStringCheckUtf8 !== "boolean")
            return "javaStringCheckUtf8: boolean expected";
        if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
          switch (message.optimizeFor) {
            default:
              return "optimizeFor: enum value expected";
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.goPackage != null && message.hasOwnProperty("goPackage"))
          if (!$util.isString(message.goPackage))
            return "goPackage: string expected";
        if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
          if (typeof message.ccGenericServices !== "boolean")
            return "ccGenericServices: boolean expected";
        if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
          if (typeof message.javaGenericServices !== "boolean")
            return "javaGenericServices: boolean expected";
        if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
          if (typeof message.pyGenericServices !== "boolean")
            return "pyGenericServices: boolean expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
          if (typeof message.ccEnableArenas !== "boolean")
            return "ccEnableArenas: boolean expected";
        if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
          if (!$util.isString(message.objcClassPrefix))
            return "objcClassPrefix: string expected";
        if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
          if (!$util.isString(message.csharpNamespace))
            return "csharpNamespace: string expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileOptions} FileOptions
       */
      FileOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileOptions)
          return object;
        let message = new $root.google.protobuf.FileOptions();
        if (object.javaPackage != null)
          message.javaPackage = String(object.javaPackage);
        if (object.javaOuterClassname != null)
          message.javaOuterClassname = String(object.javaOuterClassname);
        if (object.javaMultipleFiles != null)
          message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
        if (object.javaGenerateEqualsAndHash != null)
          message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
        if (object.javaStringCheckUtf8 != null)
          message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
        switch (object.optimizeFor) {
          case "SPEED":
          case 1:
            message.optimizeFor = 1;
            break;
          case "CODE_SIZE":
          case 2:
            message.optimizeFor = 2;
            break;
          case "LITE_RUNTIME":
          case 3:
            message.optimizeFor = 3;
            break;
        }
        if (object.goPackage != null)
          message.goPackage = String(object.goPackage);
        if (object.ccGenericServices != null)
          message.ccGenericServices = Boolean(object.ccGenericServices);
        if (object.javaGenericServices != null)
          message.javaGenericServices = Boolean(object.javaGenericServices);
        if (object.pyGenericServices != null)
          message.pyGenericServices = Boolean(object.pyGenericServices);
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.ccEnableArenas != null)
          message.ccEnableArenas = Boolean(object.ccEnableArenas);
        if (object.objcClassPrefix != null)
          message.objcClassPrefix = String(object.objcClassPrefix);
        if (object.csharpNamespace != null)
          message.csharpNamespace = String(object.csharpNamespace);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.FileOptions} message FileOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults) {
          object.javaPackage = "";
          object.javaOuterClassname = "";
          object.optimizeFor = options.enums === String ? "SPEED" : 1;
          object.javaMultipleFiles = false;
          object.goPackage = "";
          object.ccGenericServices = false;
          object.javaGenericServices = false;
          object.pyGenericServices = false;
          object.javaGenerateEqualsAndHash = false;
          object.deprecated = false;
          object.javaStringCheckUtf8 = false;
          object.ccEnableArenas = false;
          object.objcClassPrefix = "";
          object.csharpNamespace = "";
        }
        if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
          object.javaPackage = message.javaPackage;
        if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
          object.javaOuterClassname = message.javaOuterClassname;
        if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
          object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
        if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
          object.javaMultipleFiles = message.javaMultipleFiles;
        if (message.goPackage != null && message.hasOwnProperty("goPackage"))
          object.goPackage = message.goPackage;
        if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
          object.ccGenericServices = message.ccGenericServices;
        if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
          object.javaGenericServices = message.javaGenericServices;
        if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
          object.pyGenericServices = message.pyGenericServices;
        if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
          object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
          object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
        if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
          object.ccEnableArenas = message.ccEnableArenas;
        if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
          object.objcClassPrefix = message.objcClassPrefix;
        if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
          object.csharpNamespace = message.csharpNamespace;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this FileOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * OptimizeMode enum.
       * @name google.protobuf.FileOptions.OptimizeMode
       * @enum {number}
       * @property {number} SPEED=1 SPEED value
       * @property {number} CODE_SIZE=2 CODE_SIZE value
       * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
       */
      FileOptions.OptimizeMode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPEED"] = 1;
        values[valuesById[2] = "CODE_SIZE"] = 2;
        values[valuesById[3] = "LITE_RUNTIME"] = 3;
        return values;
      })();

      return FileOptions;
    })();

    protobuf.MessageOptions = (function() {

      /**
       * Properties of a MessageOptions.
       * @memberof google.protobuf
       * @interface IMessageOptions
       * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
       * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
       * @property {boolean|null} [deprecated] MessageOptions deprecated
       * @property {boolean|null} [mapEntry] MessageOptions mapEntry
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
       */

      /**
       * Constructs a new MessageOptions.
       * @memberof google.protobuf
       * @classdesc Represents a MessageOptions.
       * @implements IMessageOptions
       * @constructor
       * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
       */
      function MessageOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MessageOptions messageSetWireFormat.
       * @member {boolean} messageSetWireFormat
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.messageSetWireFormat = false;

      /**
       * MessageOptions noStandardDescriptorAccessor.
       * @member {boolean} noStandardDescriptorAccessor
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.noStandardDescriptorAccessor = false;

      /**
       * MessageOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.deprecated = false;

      /**
       * MessageOptions mapEntry.
       * @member {boolean} mapEntry
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.mapEntry = false;

      /**
       * MessageOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new MessageOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
       * @returns {google.protobuf.MessageOptions} MessageOptions instance
       */
      MessageOptions.create = function create(properties) {
        return new MessageOptions(properties);
      };

      /**
       * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MessageOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
          writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
        if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
          writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
        if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
          writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MessageOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MessageOptions} MessageOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MessageOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messageSetWireFormat = reader.bool();
              break;
            case 2:
              message.noStandardDescriptorAccessor = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 7:
              message.mapEntry = reader.bool();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MessageOptions} MessageOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MessageOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MessageOptions message.
       * @function verify
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MessageOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
          if (typeof message.messageSetWireFormat !== "boolean")
            return "messageSetWireFormat: boolean expected";
        if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
          if (typeof message.noStandardDescriptorAccessor !== "boolean")
            return "noStandardDescriptorAccessor: boolean expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
          if (typeof message.mapEntry !== "boolean")
            return "mapEntry: boolean expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MessageOptions} MessageOptions
       */
      MessageOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MessageOptions)
          return object;
        let message = new $root.google.protobuf.MessageOptions();
        if (object.messageSetWireFormat != null)
          message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
        if (object.noStandardDescriptorAccessor != null)
          message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.mapEntry != null)
          message.mapEntry = Boolean(object.mapEntry);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.MessageOptions} message MessageOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MessageOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults) {
          object.messageSetWireFormat = false;
          object.noStandardDescriptorAccessor = false;
          object.deprecated = false;
          object.mapEntry = false;
        }
        if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
          object.messageSetWireFormat = message.messageSetWireFormat;
        if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
          object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
          object.mapEntry = message.mapEntry;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this MessageOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.MessageOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MessageOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MessageOptions;
    })();

    protobuf.FieldOptions = (function() {

      /**
       * Properties of a FieldOptions.
       * @memberof google.protobuf
       * @interface IFieldOptions
       * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
       * @property {boolean|null} [packed] FieldOptions packed
       * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
       * @property {boolean|null} [lazy] FieldOptions lazy
       * @property {boolean|null} [deprecated] FieldOptions deprecated
       * @property {boolean|null} [weak] FieldOptions weak
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
       */

      /**
       * Constructs a new FieldOptions.
       * @memberof google.protobuf
       * @classdesc Represents a FieldOptions.
       * @implements IFieldOptions
       * @constructor
       * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
       */
      function FieldOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * FieldOptions ctype.
       * @member {google.protobuf.FieldOptions.CType} ctype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.ctype = 0;

      /**
       * FieldOptions packed.
       * @member {boolean} packed
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.packed = false;

      /**
       * FieldOptions jstype.
       * @member {google.protobuf.FieldOptions.JSType} jstype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.jstype = 0;

      /**
       * FieldOptions lazy.
       * @member {boolean} lazy
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.lazy = false;

      /**
       * FieldOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.deprecated = false;

      /**
       * FieldOptions weak.
       * @member {boolean} weak
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.weak = false;

      /**
       * FieldOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new FieldOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
       * @returns {google.protobuf.FieldOptions} FieldOptions instance
       */
      FieldOptions.create = function create(properties) {
        return new FieldOptions(properties);
      };

      /**
       * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
          writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
        if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
          writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
        if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
          writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
        if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
          writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
        if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
          writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FieldOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FieldOptions} FieldOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ctype = reader.int32();
              break;
            case 2:
              message.packed = reader.bool();
              break;
            case 6:
              message.jstype = reader.int32();
              break;
            case 5:
              message.lazy = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 10:
              message.weak = reader.bool();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FieldOptions} FieldOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FieldOptions message.
       * @function verify
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FieldOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.ctype != null && message.hasOwnProperty("ctype"))
          switch (message.ctype) {
            default:
              return "ctype: enum value expected";
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.packed != null && message.hasOwnProperty("packed"))
          if (typeof message.packed !== "boolean")
            return "packed: boolean expected";
        if (message.jstype != null && message.hasOwnProperty("jstype"))
          switch (message.jstype) {
            default:
              return "jstype: enum value expected";
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.lazy != null && message.hasOwnProperty("lazy"))
          if (typeof message.lazy !== "boolean")
            return "lazy: boolean expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.weak != null && message.hasOwnProperty("weak"))
          if (typeof message.weak !== "boolean")
            return "weak: boolean expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FieldOptions} FieldOptions
       */
      FieldOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FieldOptions)
          return object;
        let message = new $root.google.protobuf.FieldOptions();
        switch (object.ctype) {
          case "STRING":
          case 0:
            message.ctype = 0;
            break;
          case "CORD":
          case 1:
            message.ctype = 1;
            break;
          case "STRING_PIECE":
          case 2:
            message.ctype = 2;
            break;
        }
        if (object.packed != null)
          message.packed = Boolean(object.packed);
        switch (object.jstype) {
          case "JS_NORMAL":
          case 0:
            message.jstype = 0;
            break;
          case "JS_STRING":
          case 1:
            message.jstype = 1;
            break;
          case "JS_NUMBER":
          case 2:
            message.jstype = 2;
            break;
        }
        if (object.lazy != null)
          message.lazy = Boolean(object.lazy);
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.weak != null)
          message.weak = Boolean(object.weak);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.FieldOptions} message FieldOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FieldOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults) {
          object.ctype = options.enums === String ? "STRING" : 0;
          object.packed = false;
          object.deprecated = false;
          object.lazy = false;
          object.jstype = options.enums === String ? "JS_NORMAL" : 0;
          object.weak = false;
        }
        if (message.ctype != null && message.hasOwnProperty("ctype"))
          object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
        if (message.packed != null && message.hasOwnProperty("packed"))
          object.packed = message.packed;
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.lazy != null && message.hasOwnProperty("lazy"))
          object.lazy = message.lazy;
        if (message.jstype != null && message.hasOwnProperty("jstype"))
          object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
        if (message.weak != null && message.hasOwnProperty("weak"))
          object.weak = message.weak;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this FieldOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.FieldOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FieldOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * CType enum.
       * @name google.protobuf.FieldOptions.CType
       * @enum {number}
       * @property {number} STRING=0 STRING value
       * @property {number} CORD=1 CORD value
       * @property {number} STRING_PIECE=2 STRING_PIECE value
       */
      FieldOptions.CType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "STRING"] = 0;
        values[valuesById[1] = "CORD"] = 1;
        values[valuesById[2] = "STRING_PIECE"] = 2;
        return values;
      })();

      /**
       * JSType enum.
       * @name google.protobuf.FieldOptions.JSType
       * @enum {number}
       * @property {number} JS_NORMAL=0 JS_NORMAL value
       * @property {number} JS_STRING=1 JS_STRING value
       * @property {number} JS_NUMBER=2 JS_NUMBER value
       */
      FieldOptions.JSType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "JS_NORMAL"] = 0;
        values[valuesById[1] = "JS_STRING"] = 1;
        values[valuesById[2] = "JS_NUMBER"] = 2;
        return values;
      })();

      return FieldOptions;
    })();

    protobuf.OneofOptions = (function() {

      /**
       * Properties of an OneofOptions.
       * @memberof google.protobuf
       * @interface IOneofOptions
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
       */

      /**
       * Constructs a new OneofOptions.
       * @memberof google.protobuf
       * @classdesc Represents an OneofOptions.
       * @implements IOneofOptions
       * @constructor
       * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
       */
      function OneofOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * OneofOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.OneofOptions
       * @instance
       */
      OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new OneofOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
       * @returns {google.protobuf.OneofOptions} OneofOptions instance
       */
      OneofOptions.create = function create(properties) {
        return new OneofOptions(properties);
      };

      /**
       * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OneofOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.OneofOptions} OneofOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.OneofOptions} OneofOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OneofOptions message.
       * @function verify
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OneofOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.OneofOptions} OneofOptions
       */
      OneofOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.OneofOptions)
          return object;
        let message = new $root.google.protobuf.OneofOptions();
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.OneofOptions} message OneofOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OneofOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this OneofOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.OneofOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OneofOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OneofOptions;
    })();

    protobuf.EnumOptions = (function() {

      /**
       * Properties of an EnumOptions.
       * @memberof google.protobuf
       * @interface IEnumOptions
       * @property {boolean|null} [allowAlias] EnumOptions allowAlias
       * @property {boolean|null} [deprecated] EnumOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
       */

      /**
       * Constructs a new EnumOptions.
       * @memberof google.protobuf
       * @classdesc Represents an EnumOptions.
       * @implements IEnumOptions
       * @constructor
       * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
       */
      function EnumOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumOptions allowAlias.
       * @member {boolean} allowAlias
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.allowAlias = false;

      /**
       * EnumOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.deprecated = false;

      /**
       * EnumOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new EnumOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
       * @returns {google.protobuf.EnumOptions} EnumOptions instance
       */
      EnumOptions.create = function create(properties) {
        return new EnumOptions(properties);
      };

      /**
       * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
          writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumOptions} EnumOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.allowAlias = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumOptions} EnumOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumOptions message.
       * @function verify
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
          if (typeof message.allowAlias !== "boolean")
            return "allowAlias: boolean expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumOptions} EnumOptions
       */
      EnumOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumOptions)
          return object;
        let message = new $root.google.protobuf.EnumOptions();
        if (object.allowAlias != null)
          message.allowAlias = Boolean(object.allowAlias);
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.EnumOptions} message EnumOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults) {
          object.allowAlias = false;
          object.deprecated = false;
        }
        if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
          object.allowAlias = message.allowAlias;
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this EnumOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumOptions;
    })();

    protobuf.EnumValueOptions = (function() {

      /**
       * Properties of an EnumValueOptions.
       * @memberof google.protobuf
       * @interface IEnumValueOptions
       * @property {boolean|null} [deprecated] EnumValueOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
       */

      /**
       * Constructs a new EnumValueOptions.
       * @memberof google.protobuf
       * @classdesc Represents an EnumValueOptions.
       * @implements IEnumValueOptions
       * @constructor
       * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
       */
      function EnumValueOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumValueOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype.deprecated = false;

      /**
       * EnumValueOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new EnumValueOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
       */
      EnumValueOptions.create = function create(properties) {
        return new EnumValueOptions(properties);
      };

      /**
       * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumValueOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumValueOptions message.
       * @function verify
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumValueOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       */
      EnumValueOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumValueOptions)
          return object;
        let message = new $root.google.protobuf.EnumValueOptions();
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumValueOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults)
          object.deprecated = false;
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this EnumValueOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumValueOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumValueOptions;
    })();

    protobuf.ServiceOptions = (function() {

      /**
       * Properties of a ServiceOptions.
       * @memberof google.protobuf
       * @interface IServiceOptions
       * @property {boolean|null} [deprecated] ServiceOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
       */

      /**
       * Constructs a new ServiceOptions.
       * @memberof google.protobuf
       * @classdesc Represents a ServiceOptions.
       * @implements IServiceOptions
       * @constructor
       * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
       */
      function ServiceOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype.deprecated = false;

      /**
       * ServiceOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * Creates a new ServiceOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
       * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
       */
      ServiceOptions.create = function create(properties) {
        return new ServiceOptions(properties);
      };

      /**
       * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 33:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceOptions message.
       * @function verify
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        return null;
      };

      /**
       * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       */
      ServiceOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.ServiceOptions)
          return object;
        let message = new $root.google.protobuf.ServiceOptions();
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.ServiceOptions} message ServiceOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults)
          object.deprecated = false;
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        return object;
      };

      /**
       * Converts this ServiceOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.ServiceOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ServiceOptions;
    })();

    protobuf.MethodOptions = (function() {

      /**
       * Properties of a MethodOptions.
       * @memberof google.protobuf
       * @interface IMethodOptions
       * @property {boolean|null} [deprecated] MethodOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
       * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
       */

      /**
       * Constructs a new MethodOptions.
       * @memberof google.protobuf
       * @classdesc Represents a MethodOptions.
       * @implements IMethodOptions
       * @constructor
       * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
       */
      function MethodOptions(properties) {
        this.uninterpretedOption = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * MethodOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype.deprecated = false;

      /**
       * MethodOptions uninterpretedOption.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

      /**
       * MethodOptions .google.api.http.
       * @member {google.api.IHttpRule|null|undefined} .google.api.http
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype[".google.api.http"] = null;

      /**
       * Creates a new MethodOptions instance using the specified properties.
       * @function create
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
       * @returns {google.protobuf.MethodOptions} MethodOptions instance
       */
      MethodOptions.create = function create(properties) {
        return new MethodOptions(properties);
      };

      /**
       * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodOptions.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
          writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
        if (message.uninterpretedOption != null && message.uninterpretedOption.length)
          for (let i = 0; i < message.uninterpretedOption.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
        if (message[".google.api.http"] != null && Object.hasOwnProperty.call(message, ".google.api.http"))
          $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MethodOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MethodOptions} MethodOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 33:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                message.uninterpretedOption = [];
              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 72295728:
              message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MethodOptions} MethodOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MethodOptions message.
       * @function verify
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MethodOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          if (typeof message.deprecated !== "boolean")
            return "deprecated: boolean expected";
        if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
          if (!Array.isArray(message.uninterpretedOption))
            return "uninterpretedOption: array expected";
          for (let i = 0; i < message.uninterpretedOption.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
            if (error)
              return "uninterpretedOption." + error;
          }
        }
        if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
          let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
          if (error)
            return ".google.api.http." + error;
        }
        return null;
      };

      /**
       * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MethodOptions} MethodOptions
       */
      MethodOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MethodOptions)
          return object;
        let message = new $root.google.protobuf.MethodOptions();
        if (object.deprecated != null)
          message.deprecated = Boolean(object.deprecated);
        if (object.uninterpretedOption) {
          if (!Array.isArray(object.uninterpretedOption))
            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
          message.uninterpretedOption = [];
          for (let i = 0; i < object.uninterpretedOption.length; ++i) {
            if (typeof object.uninterpretedOption[i] !== "object")
              throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
          }
        }
        if (object[".google.api.http"] != null) {
          if (typeof object[".google.api.http"] !== "object")
            throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
          message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
        }
        return message;
      };

      /**
       * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.MethodOptions} message MethodOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MethodOptions.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.uninterpretedOption = [];
        if (options.defaults) {
          object.deprecated = false;
          object[".google.api.http"] = null;
        }
        if (message.deprecated != null && message.hasOwnProperty("deprecated"))
          object.deprecated = message.deprecated;
        if (message.uninterpretedOption && message.uninterpretedOption.length) {
          object.uninterpretedOption = [];
          for (let j = 0; j < message.uninterpretedOption.length; ++j)
            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
        }
        if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
          object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
        return object;
      };

      /**
       * Converts this MethodOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.MethodOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MethodOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MethodOptions;
    })();

    protobuf.UninterpretedOption = (function() {

      /**
       * Properties of an UninterpretedOption.
       * @memberof google.protobuf
       * @interface IUninterpretedOption
       * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
       * @property {string|null} [identifierValue] UninterpretedOption identifierValue
       * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
       * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
       * @property {number|null} [doubleValue] UninterpretedOption doubleValue
       * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
       * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
       */

      /**
       * Constructs a new UninterpretedOption.
       * @memberof google.protobuf
       * @classdesc Represents an UninterpretedOption.
       * @implements IUninterpretedOption
       * @constructor
       * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
       */
      function UninterpretedOption(properties) {
        this.name = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * UninterpretedOption name.
       * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.name = $util.emptyArray;

      /**
       * UninterpretedOption identifierValue.
       * @member {string} identifierValue
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.identifierValue = "";

      /**
       * UninterpretedOption positiveIntValue.
       * @member {number|Long} positiveIntValue
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * UninterpretedOption negativeIntValue.
       * @member {number|Long} negativeIntValue
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

      /**
       * UninterpretedOption doubleValue.
       * @member {number} doubleValue
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.doubleValue = 0;

      /**
       * UninterpretedOption stringValue.
       * @member {Uint8Array} stringValue
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

      /**
       * UninterpretedOption aggregateValue.
       * @member {string} aggregateValue
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.aggregateValue = "";

      /**
       * Creates a new UninterpretedOption instance using the specified properties.
       * @function create
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
       */
      UninterpretedOption.create = function create(properties) {
        return new UninterpretedOption(properties);
      };

      /**
       * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UninterpretedOption.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.name != null && message.name.length)
          for (let i = 0; i < message.name.length; ++i)
            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
        if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
          writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
        if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
          writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
        if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
          writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
        if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
          writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
        if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
          writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
        return writer;
      };

      /**
       * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an UninterpretedOption message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UninterpretedOption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              if (!(message.name && message.name.length))
                message.name = [];
              message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
              break;
            case 3:
              message.identifierValue = reader.string();
              break;
            case 4:
              message.positiveIntValue = reader.uint64();
              break;
            case 5:
              message.negativeIntValue = reader.int64();
              break;
            case 6:
              message.doubleValue = reader.double();
              break;
            case 7:
              message.stringValue = reader.bytes();
              break;
            case 8:
              message.aggregateValue = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an UninterpretedOption message.
       * @function verify
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      UninterpretedOption.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.name != null && message.hasOwnProperty("name")) {
          if (!Array.isArray(message.name))
            return "name: array expected";
          for (let i = 0; i < message.name.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
            if (error)
              return "name." + error;
          }
        }
        if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
          if (!$util.isString(message.identifierValue))
            return "identifierValue: string expected";
        if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
          if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
            return "positiveIntValue: integer|Long expected";
        if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
          if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
            return "negativeIntValue: integer|Long expected";
        if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
          if (typeof message.doubleValue !== "number")
            return "doubleValue: number expected";
        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
          if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
            return "stringValue: buffer expected";
        if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
          if (!$util.isString(message.aggregateValue))
            return "aggregateValue: string expected";
        return null;
      };

      /**
       * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       */
      UninterpretedOption.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.UninterpretedOption)
          return object;
        let message = new $root.google.protobuf.UninterpretedOption();
        if (object.name) {
          if (!Array.isArray(object.name))
            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
          message.name = [];
          for (let i = 0; i < object.name.length; ++i) {
            if (typeof object.name[i] !== "object")
              throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
          }
        }
        if (object.identifierValue != null)
          message.identifierValue = String(object.identifierValue);
        if (object.positiveIntValue != null)
          if ($util.Long)
            (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
          else if (typeof object.positiveIntValue === "string")
            message.positiveIntValue = parseInt(object.positiveIntValue, 10);
          else if (typeof object.positiveIntValue === "number")
            message.positiveIntValue = object.positiveIntValue;
          else if (typeof object.positiveIntValue === "object")
            message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
        if (object.negativeIntValue != null)
          if ($util.Long)
            (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
          else if (typeof object.negativeIntValue === "string")
            message.negativeIntValue = parseInt(object.negativeIntValue, 10);
          else if (typeof object.negativeIntValue === "number")
            message.negativeIntValue = object.negativeIntValue;
          else if (typeof object.negativeIntValue === "object")
            message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
        if (object.doubleValue != null)
          message.doubleValue = Number(object.doubleValue);
        if (object.stringValue != null)
          if (typeof object.stringValue === "string")
            $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
          else if (object.stringValue.length)
            message.stringValue = object.stringValue;
        if (object.aggregateValue != null)
          message.aggregateValue = String(object.aggregateValue);
        return message;
      };

      /**
       * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      UninterpretedOption.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.name = [];
        if (options.defaults) {
          object.identifierValue = "";
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.positiveIntValue = options.longs === String ? "0" : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else
            object.negativeIntValue = options.longs === String ? "0" : 0;
          object.doubleValue = 0;
          if (options.bytes === String)
            object.stringValue = "";
          else {
            object.stringValue = [];
            if (options.bytes !== Array)
              object.stringValue = $util.newBuffer(object.stringValue);
          }
          object.aggregateValue = "";
        }
        if (message.name && message.name.length) {
          object.name = [];
          for (let j = 0; j < message.name.length; ++j)
            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
        }
        if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
          object.identifierValue = message.identifierValue;
        if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
          if (typeof message.positiveIntValue === "number")
            object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
          else
            object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
        if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
          if (typeof message.negativeIntValue === "number")
            object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
          else
            object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
        if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
          object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
          object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
        if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
          object.aggregateValue = message.aggregateValue;
        return object;
      };

      /**
       * Converts this UninterpretedOption to JSON.
       * @function toJSON
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      UninterpretedOption.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      UninterpretedOption.NamePart = (function() {

        /**
         * Properties of a NamePart.
         * @memberof google.protobuf.UninterpretedOption
         * @interface INamePart
         * @property {string} namePart NamePart namePart
         * @property {boolean} isExtension NamePart isExtension
         */

        /**
         * Constructs a new NamePart.
         * @memberof google.protobuf.UninterpretedOption
         * @classdesc Represents a NamePart.
         * @implements INamePart
         * @constructor
         * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
         */
        function NamePart(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * NamePart namePart.
         * @member {string} namePart
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         */
        NamePart.prototype.namePart = "";

        /**
         * NamePart isExtension.
         * @member {boolean} isExtension
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         */
        NamePart.prototype.isExtension = false;

        /**
         * Creates a new NamePart instance using the specified properties.
         * @function create
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
         */
        NamePart.create = function create(properties) {
          return new NamePart(properties);
        };

        /**
         * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NamePart.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
          writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
          return writer;
        };

        /**
         * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NamePart.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NamePart message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NamePart.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.namePart = reader.string();
                break;
              case 2:
                message.isExtension = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty("namePart"))
            throw $util.ProtocolError("missing required 'namePart'", { instance: message });
          if (!message.hasOwnProperty("isExtension"))
            throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
          return message;
        };

        /**
         * Decodes a NamePart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NamePart.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NamePart message.
         * @function verify
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NamePart.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (!$util.isString(message.namePart))
            return "namePart: string expected";
          if (typeof message.isExtension !== "boolean")
            return "isExtension: boolean expected";
          return null;
        };

        /**
         * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         */
        NamePart.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
            return object;
          let message = new $root.google.protobuf.UninterpretedOption.NamePart();
          if (object.namePart != null)
            message.namePart = String(object.namePart);
          if (object.isExtension != null)
            message.isExtension = Boolean(object.isExtension);
          return message;
        };

        /**
         * Creates a plain object from a NamePart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NamePart.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.namePart = "";
            object.isExtension = false;
          }
          if (message.namePart != null && message.hasOwnProperty("namePart"))
            object.namePart = message.namePart;
          if (message.isExtension != null && message.hasOwnProperty("isExtension"))
            object.isExtension = message.isExtension;
          return object;
        };

        /**
         * Converts this NamePart to JSON.
         * @function toJSON
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NamePart.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NamePart;
      })();

      return UninterpretedOption;
    })();

    protobuf.SourceCodeInfo = (function() {

      /**
       * Properties of a SourceCodeInfo.
       * @memberof google.protobuf
       * @interface ISourceCodeInfo
       * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
       */

      /**
       * Constructs a new SourceCodeInfo.
       * @memberof google.protobuf
       * @classdesc Represents a SourceCodeInfo.
       * @implements ISourceCodeInfo
       * @constructor
       * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
       */
      function SourceCodeInfo(properties) {
        this.location = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * SourceCodeInfo location.
       * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
       * @memberof google.protobuf.SourceCodeInfo
       * @instance
       */
      SourceCodeInfo.prototype.location = $util.emptyArray;

      /**
       * Creates a new SourceCodeInfo instance using the specified properties.
       * @function create
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
       */
      SourceCodeInfo.create = function create(properties) {
        return new SourceCodeInfo(properties);
      };

      /**
       * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SourceCodeInfo.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.location != null && message.location.length)
          for (let i = 0; i < message.location.length; ++i)
            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SourceCodeInfo message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SourceCodeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.location && message.location.length))
                message.location = [];
              message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SourceCodeInfo message.
       * @function verify
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SourceCodeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.location != null && message.hasOwnProperty("location")) {
          if (!Array.isArray(message.location))
            return "location: array expected";
          for (let i = 0; i < message.location.length; ++i) {
            let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
            if (error)
              return "location." + error;
          }
        }
        return null;
      };

      /**
       * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       */
      SourceCodeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.SourceCodeInfo)
          return object;
        let message = new $root.google.protobuf.SourceCodeInfo();
        if (object.location) {
          if (!Array.isArray(object.location))
            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
          message.location = [];
          for (let i = 0; i < object.location.length; ++i) {
            if (typeof object.location[i] !== "object")
              throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SourceCodeInfo.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.location = [];
        if (message.location && message.location.length) {
          object.location = [];
          for (let j = 0; j < message.location.length; ++j)
            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
        }
        return object;
      };

      /**
       * Converts this SourceCodeInfo to JSON.
       * @function toJSON
       * @memberof google.protobuf.SourceCodeInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SourceCodeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      SourceCodeInfo.Location = (function() {

        /**
         * Properties of a Location.
         * @memberof google.protobuf.SourceCodeInfo
         * @interface ILocation
         * @property {Array.<number>|null} [path] Location path
         * @property {Array.<number>|null} [span] Location span
         * @property {string|null} [leadingComments] Location leadingComments
         * @property {string|null} [trailingComments] Location trailingComments
         * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
         */

        /**
         * Constructs a new Location.
         * @memberof google.protobuf.SourceCodeInfo
         * @classdesc Represents a Location.
         * @implements ILocation
         * @constructor
         * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
         */
        function Location(properties) {
          this.path = [];
          this.span = [];
          this.leadingDetachedComments = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Location path.
         * @member {Array.<number>} path
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.path = $util.emptyArray;

        /**
         * Location span.
         * @member {Array.<number>} span
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.span = $util.emptyArray;

        /**
         * Location leadingComments.
         * @member {string} leadingComments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.leadingComments = "";

        /**
         * Location trailingComments.
         * @member {string} trailingComments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.trailingComments = "";

        /**
         * Location leadingDetachedComments.
         * @member {Array.<string>} leadingDetachedComments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.leadingDetachedComments = $util.emptyArray;

        /**
         * Creates a new Location instance using the specified properties.
         * @function create
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
         * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
         */
        Location.create = function create(properties) {
          return new Location(properties);
        };

        /**
         * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.path != null && message.path.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (let i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          if (message.span != null && message.span.length) {
            writer.uint32(/* id 2, wireType 2 =*/18).fork();
            for (let i = 0; i < message.span.length; ++i)
              writer.int32(message.span[i]);
            writer.ldelim();
          }
          if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
          if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
          if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
            for (let i = 0; i < message.leadingDetachedComments.length; ++i)
              writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
          return writer;
        };

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              case 2:
                if (!(message.span && message.span.length))
                  message.span = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.span.push(reader.int32());
                } else
                  message.span.push(reader.int32());
                break;
              case 3:
                message.leadingComments = reader.string();
                break;
              case 4:
                message.trailingComments = reader.string();
                break;
              case 6:
                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                  message.leadingDetachedComments = [];
                message.leadingDetachedComments.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Location message.
         * @function verify
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Location.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (let i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          if (message.span != null && message.hasOwnProperty("span")) {
            if (!Array.isArray(message.span))
              return "span: array expected";
            for (let i = 0; i < message.span.length; ++i)
              if (!$util.isInteger(message.span[i]))
                return "span: integer[] expected";
          }
          if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
            if (!$util.isString(message.leadingComments))
              return "leadingComments: string expected";
          if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
            if (!$util.isString(message.trailingComments))
              return "trailingComments: string expected";
          if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
            if (!Array.isArray(message.leadingDetachedComments))
              return "leadingDetachedComments: array expected";
            for (let i = 0; i < message.leadingDetachedComments.length; ++i)
              if (!$util.isString(message.leadingDetachedComments[i]))
                return "leadingDetachedComments: string[] expected";
          }
          return null;
        };

        /**
         * Creates a Location message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         */
        Location.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
            return object;
          let message = new $root.google.protobuf.SourceCodeInfo.Location();
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
            message.path = [];
            for (let i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          if (object.span) {
            if (!Array.isArray(object.span))
              throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
            message.span = [];
            for (let i = 0; i < object.span.length; ++i)
              message.span[i] = object.span[i] | 0;
          }
          if (object.leadingComments != null)
            message.leadingComments = String(object.leadingComments);
          if (object.trailingComments != null)
            message.trailingComments = String(object.trailingComments);
          if (object.leadingDetachedComments) {
            if (!Array.isArray(object.leadingDetachedComments))
              throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
            message.leadingDetachedComments = [];
            for (let i = 0; i < object.leadingDetachedComments.length; ++i)
              message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.Location} message Location
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Location.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults) {
            object.path = [];
            object.span = [];
            object.leadingDetachedComments = [];
          }
          if (options.defaults) {
            object.leadingComments = "";
            object.trailingComments = "";
          }
          if (message.path && message.path.length) {
            object.path = [];
            for (let j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          if (message.span && message.span.length) {
            object.span = [];
            for (let j = 0; j < message.span.length; ++j)
              object.span[j] = message.span[j];
          }
          if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
            object.leadingComments = message.leadingComments;
          if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
            object.trailingComments = message.trailingComments;
          if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
            object.leadingDetachedComments = [];
            for (let j = 0; j < message.leadingDetachedComments.length; ++j)
              object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
          }
          return object;
        };

        /**
         * Converts this Location to JSON.
         * @function toJSON
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Location.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Location;
      })();

      return SourceCodeInfo;
    })();

    protobuf.GeneratedCodeInfo = (function() {

      /**
       * Properties of a GeneratedCodeInfo.
       * @memberof google.protobuf
       * @interface IGeneratedCodeInfo
       * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
       */

      /**
       * Constructs a new GeneratedCodeInfo.
       * @memberof google.protobuf
       * @classdesc Represents a GeneratedCodeInfo.
       * @implements IGeneratedCodeInfo
       * @constructor
       * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
       */
      function GeneratedCodeInfo(properties) {
        this.annotation = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * GeneratedCodeInfo annotation.
       * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
       * @memberof google.protobuf.GeneratedCodeInfo
       * @instance
       */
      GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

      /**
       * Creates a new GeneratedCodeInfo instance using the specified properties.
       * @function create
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
       */
      GeneratedCodeInfo.create = function create(properties) {
        return new GeneratedCodeInfo(properties);
      };

      /**
       * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GeneratedCodeInfo.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.annotation != null && message.annotation.length)
          for (let i = 0; i < message.annotation.length; ++i)
            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GeneratedCodeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.annotation && message.annotation.length))
                message.annotation = [];
              message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GeneratedCodeInfo message.
       * @function verify
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GeneratedCodeInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.annotation != null && message.hasOwnProperty("annotation")) {
          if (!Array.isArray(message.annotation))
            return "annotation: array expected";
          for (let i = 0; i < message.annotation.length; ++i) {
            let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
            if (error)
              return "annotation." + error;
          }
        }
        return null;
      };

      /**
       * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       */
      GeneratedCodeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
          return object;
        let message = new $root.google.protobuf.GeneratedCodeInfo();
        if (object.annotation) {
          if (!Array.isArray(object.annotation))
            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
          message.annotation = [];
          for (let i = 0; i < object.annotation.length; ++i) {
            if (typeof object.annotation[i] !== "object")
              throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GeneratedCodeInfo.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.annotation = [];
        if (message.annotation && message.annotation.length) {
          object.annotation = [];
          for (let j = 0; j < message.annotation.length; ++j)
            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
        }
        return object;
      };

      /**
       * Converts this GeneratedCodeInfo to JSON.
       * @function toJSON
       * @memberof google.protobuf.GeneratedCodeInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GeneratedCodeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      GeneratedCodeInfo.Annotation = (function() {

        /**
         * Properties of an Annotation.
         * @memberof google.protobuf.GeneratedCodeInfo
         * @interface IAnnotation
         * @property {Array.<number>|null} [path] Annotation path
         * @property {string|null} [sourceFile] Annotation sourceFile
         * @property {number|null} [begin] Annotation begin
         * @property {number|null} [end] Annotation end
         */

        /**
         * Constructs a new Annotation.
         * @memberof google.protobuf.GeneratedCodeInfo
         * @classdesc Represents an Annotation.
         * @implements IAnnotation
         * @constructor
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
         */
        function Annotation(properties) {
          this.path = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
        }

        /**
         * Annotation path.
         * @member {Array.<number>} path
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.path = $util.emptyArray;

        /**
         * Annotation sourceFile.
         * @member {string} sourceFile
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.sourceFile = "";

        /**
         * Annotation begin.
         * @member {number} begin
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.begin = 0;

        /**
         * Annotation end.
         * @member {number} end
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.end = 0;

        /**
         * Creates a new Annotation instance using the specified properties.
         * @function create
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
         */
        Annotation.create = function create(properties) {
          return new Annotation(properties);
        };

        /**
         * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Annotation.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.path != null && message.path.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (let i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
          if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
          if (message.end != null && Object.hasOwnProperty.call(message, "end"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Annotation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Annotation message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Annotation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              case 2:
                message.sourceFile = reader.string();
                break;
              case 3:
                message.begin = reader.int32();
                break;
              case 4:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Annotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Annotation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Annotation message.
         * @function verify
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Annotation.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (let i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
            if (!$util.isString(message.sourceFile))
              return "sourceFile: string expected";
          if (message.begin != null && message.hasOwnProperty("begin"))
            if (!$util.isInteger(message.begin))
              return "begin: integer expected";
          if (message.end != null && message.hasOwnProperty("end"))
            if (!$util.isInteger(message.end))
              return "end: integer expected";
          return null;
        };

        /**
         * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         */
        Annotation.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
            return object;
          let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
            message.path = [];
            for (let i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          if (object.sourceFile != null)
            message.sourceFile = String(object.sourceFile);
          if (object.begin != null)
            message.begin = object.begin | 0;
          if (object.end != null)
            message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from an Annotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Annotation.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            object.sourceFile = "";
            object.begin = 0;
            object.end = 0;
          }
          if (message.path && message.path.length) {
            object.path = [];
            for (let j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
            object.sourceFile = message.sourceFile;
          if (message.begin != null && message.hasOwnProperty("begin"))
            object.begin = message.begin;
          if (message.end != null && message.hasOwnProperty("end"))
            object.end = message.end;
          return object;
        };

        /**
         * Converts this Annotation to JSON.
         * @function toJSON
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Annotation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Annotation;
      })();

      return GeneratedCodeInfo;
    })();

    return protobuf;
  })();

  google.api = (function() {

    /**
     * Namespace api.
     * @memberof google
     * @namespace
     */
    const api = {};

    api.Http = (function() {

      /**
       * Properties of a Http.
       * @memberof google.api
       * @interface IHttp
       * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
       */

      /**
       * Constructs a new Http.
       * @memberof google.api
       * @classdesc Represents a Http.
       * @implements IHttp
       * @constructor
       * @param {google.api.IHttp=} [properties] Properties to set
       */
      function Http(properties) {
        this.rules = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Http rules.
       * @member {Array.<google.api.IHttpRule>} rules
       * @memberof google.api.Http
       * @instance
       */
      Http.prototype.rules = $util.emptyArray;

      /**
       * Creates a new Http instance using the specified properties.
       * @function create
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp=} [properties] Properties to set
       * @returns {google.api.Http} Http instance
       */
      Http.create = function create(properties) {
        return new Http(properties);
      };

      /**
       * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
       * @function encode
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp} message Http message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Http.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.rules != null && message.rules.length)
          for (let i = 0; i < message.rules.length; ++i)
            $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp} message Http message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Http.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Http message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.Http
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.Http} Http
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Http.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.rules && message.rules.length))
                message.rules = [];
              message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Http message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.Http
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.Http} Http
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Http.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Http message.
       * @function verify
       * @memberof google.api.Http
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Http.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.rules != null && message.hasOwnProperty("rules")) {
          if (!Array.isArray(message.rules))
            return "rules: array expected";
          for (let i = 0; i < message.rules.length; ++i) {
            let error = $root.google.api.HttpRule.verify(message.rules[i]);
            if (error)
              return "rules." + error;
          }
        }
        return null;
      };

      /**
       * Creates a Http message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.Http
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.Http} Http
       */
      Http.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.Http)
          return object;
        let message = new $root.google.api.Http();
        if (object.rules) {
          if (!Array.isArray(object.rules))
            throw TypeError(".google.api.Http.rules: array expected");
          message.rules = [];
          for (let i = 0; i < object.rules.length; ++i) {
            if (typeof object.rules[i] !== "object")
              throw TypeError(".google.api.Http.rules: object expected");
            message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Http message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.Http
       * @static
       * @param {google.api.Http} message Http
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Http.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.rules = [];
        if (message.rules && message.rules.length) {
          object.rules = [];
          for (let j = 0; j < message.rules.length; ++j)
            object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
        }
        return object;
      };

      /**
       * Converts this Http to JSON.
       * @function toJSON
       * @memberof google.api.Http
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Http.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Http;
    })();

    api.HttpRule = (function() {

      /**
       * Properties of a HttpRule.
       * @memberof google.api
       * @interface IHttpRule
       * @property {string|null} [get] HttpRule get
       * @property {string|null} [put] HttpRule put
       * @property {string|null} [post] HttpRule post
       * @property {string|null} ["delete"] HttpRule delete
       * @property {string|null} [patch] HttpRule patch
       * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
       * @property {string|null} [selector] HttpRule selector
       * @property {string|null} [body] HttpRule body
       * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
       */

      /**
       * Constructs a new HttpRule.
       * @memberof google.api
       * @classdesc Represents a HttpRule.
       * @implements IHttpRule
       * @constructor
       * @param {google.api.IHttpRule=} [properties] Properties to set
       */
      function HttpRule(properties) {
        this.additionalBindings = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * HttpRule get.
       * @member {string|null|undefined} get
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.get = null;

      /**
       * HttpRule put.
       * @member {string|null|undefined} put
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.put = null;

      /**
       * HttpRule post.
       * @member {string|null|undefined} post
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.post = null;

      /**
       * HttpRule delete.
       * @member {string|null|undefined} delete
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype["delete"] = null;

      /**
       * HttpRule patch.
       * @member {string|null|undefined} patch
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.patch = null;

      /**
       * HttpRule custom.
       * @member {google.api.ICustomHttpPattern|null|undefined} custom
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.custom = null;

      /**
       * HttpRule selector.
       * @member {string} selector
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.selector = "";

      /**
       * HttpRule body.
       * @member {string} body
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.body = "";

      /**
       * HttpRule additionalBindings.
       * @member {Array.<google.api.IHttpRule>} additionalBindings
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.additionalBindings = $util.emptyArray;

      // OneOf field names bound to virtual getters and setters
      let $oneOfFields;

      /**
       * HttpRule pattern.
       * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
       * @memberof google.api.HttpRule
       * @instance
       */
      Object.defineProperty(HttpRule.prototype, "pattern", {
        get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
        set: $util.oneOfSetter($oneOfFields)
      });

      /**
       * Creates a new HttpRule instance using the specified properties.
       * @function create
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule=} [properties] Properties to set
       * @returns {google.api.HttpRule} HttpRule instance
       */
      HttpRule.create = function create(properties) {
        return new HttpRule(properties);
      };

      /**
       * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
       * @function encode
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HttpRule.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.selector != null && Object.hasOwnProperty.call(message, "selector"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
        if (message.get != null && Object.hasOwnProperty.call(message, "get"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
        if (message.put != null && Object.hasOwnProperty.call(message, "put"))
          writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
        if (message.post != null && Object.hasOwnProperty.call(message, "post"))
          writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
        if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
          writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
        if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
          writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
        if (message.body != null && Object.hasOwnProperty.call(message, "body"))
          writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
        if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
          $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.additionalBindings != null && message.additionalBindings.length)
          for (let i = 0; i < message.additionalBindings.length; ++i)
            $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a HttpRule message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.HttpRule
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.HttpRule} HttpRule
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HttpRule.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.get = reader.string();
              break;
            case 3:
              message.put = reader.string();
              break;
            case 4:
              message.post = reader.string();
              break;
            case 5:
              message["delete"] = reader.string();
              break;
            case 6:
              message.patch = reader.string();
              break;
            case 8:
              message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
              break;
            case 1:
              message.selector = reader.string();
              break;
            case 7:
              message.body = reader.string();
              break;
            case 11:
              if (!(message.additionalBindings && message.additionalBindings.length))
                message.additionalBindings = [];
              message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a HttpRule message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.HttpRule
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.HttpRule} HttpRule
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HttpRule.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a HttpRule message.
       * @function verify
       * @memberof google.api.HttpRule
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      HttpRule.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        let properties = {};
        if (message.get != null && message.hasOwnProperty("get")) {
          properties.pattern = 1;
          if (!$util.isString(message.get))
            return "get: string expected";
        }
        if (message.put != null && message.hasOwnProperty("put")) {
          if (properties.pattern === 1)
            return "pattern: multiple values";
          properties.pattern = 1;
          if (!$util.isString(message.put))
            return "put: string expected";
        }
        if (message.post != null && message.hasOwnProperty("post")) {
          if (properties.pattern === 1)
            return "pattern: multiple values";
          properties.pattern = 1;
          if (!$util.isString(message.post))
            return "post: string expected";
        }
        if (message["delete"] != null && message.hasOwnProperty("delete")) {
          if (properties.pattern === 1)
            return "pattern: multiple values";
          properties.pattern = 1;
          if (!$util.isString(message["delete"]))
            return "delete: string expected";
        }
        if (message.patch != null && message.hasOwnProperty("patch")) {
          if (properties.pattern === 1)
            return "pattern: multiple values";
          properties.pattern = 1;
          if (!$util.isString(message.patch))
            return "patch: string expected";
        }
        if (message.custom != null && message.hasOwnProperty("custom")) {
          if (properties.pattern === 1)
            return "pattern: multiple values";
          properties.pattern = 1;
          {
            let error = $root.google.api.CustomHttpPattern.verify(message.custom);
            if (error)
              return "custom." + error;
          }
        }
        if (message.selector != null && message.hasOwnProperty("selector"))
          if (!$util.isString(message.selector))
            return "selector: string expected";
        if (message.body != null && message.hasOwnProperty("body"))
          if (!$util.isString(message.body))
            return "body: string expected";
        if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
          if (!Array.isArray(message.additionalBindings))
            return "additionalBindings: array expected";
          for (let i = 0; i < message.additionalBindings.length; ++i) {
            let error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
            if (error)
              return "additionalBindings." + error;
          }
        }
        return null;
      };

      /**
       * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.HttpRule
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.HttpRule} HttpRule
       */
      HttpRule.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.HttpRule)
          return object;
        let message = new $root.google.api.HttpRule();
        if (object.get != null)
          message.get = String(object.get);
        if (object.put != null)
          message.put = String(object.put);
        if (object.post != null)
          message.post = String(object.post);
        if (object["delete"] != null)
          message["delete"] = String(object["delete"]);
        if (object.patch != null)
          message.patch = String(object.patch);
        if (object.custom != null) {
          if (typeof object.custom !== "object")
            throw TypeError(".google.api.HttpRule.custom: object expected");
          message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
        }
        if (object.selector != null)
          message.selector = String(object.selector);
        if (object.body != null)
          message.body = String(object.body);
        if (object.additionalBindings) {
          if (!Array.isArray(object.additionalBindings))
            throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
          message.additionalBindings = [];
          for (let i = 0; i < object.additionalBindings.length; ++i) {
            if (typeof object.additionalBindings[i] !== "object")
              throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
            message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.HttpRule} message HttpRule
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      HttpRule.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.additionalBindings = [];
        if (options.defaults) {
          object.selector = "";
          object.body = "";
        }
        if (message.selector != null && message.hasOwnProperty("selector"))
          object.selector = message.selector;
        if (message.get != null && message.hasOwnProperty("get")) {
          object.get = message.get;
          if (options.oneofs)
            object.pattern = "get";
        }
        if (message.put != null && message.hasOwnProperty("put")) {
          object.put = message.put;
          if (options.oneofs)
            object.pattern = "put";
        }
        if (message.post != null && message.hasOwnProperty("post")) {
          object.post = message.post;
          if (options.oneofs)
            object.pattern = "post";
        }
        if (message["delete"] != null && message.hasOwnProperty("delete")) {
          object["delete"] = message["delete"];
          if (options.oneofs)
            object.pattern = "delete";
        }
        if (message.patch != null && message.hasOwnProperty("patch")) {
          object.patch = message.patch;
          if (options.oneofs)
            object.pattern = "patch";
        }
        if (message.body != null && message.hasOwnProperty("body"))
          object.body = message.body;
        if (message.custom != null && message.hasOwnProperty("custom")) {
          object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
          if (options.oneofs)
            object.pattern = "custom";
        }
        if (message.additionalBindings && message.additionalBindings.length) {
          object.additionalBindings = [];
          for (let j = 0; j < message.additionalBindings.length; ++j)
            object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
        }
        return object;
      };

      /**
       * Converts this HttpRule to JSON.
       * @function toJSON
       * @memberof google.api.HttpRule
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      HttpRule.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return HttpRule;
    })();

    api.CustomHttpPattern = (function() {

      /**
       * Properties of a CustomHttpPattern.
       * @memberof google.api
       * @interface ICustomHttpPattern
       * @property {string|null} [kind] CustomHttpPattern kind
       * @property {string|null} [path] CustomHttpPattern path
       */

      /**
       * Constructs a new CustomHttpPattern.
       * @memberof google.api
       * @classdesc Represents a CustomHttpPattern.
       * @implements ICustomHttpPattern
       * @constructor
       * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
       */
      function CustomHttpPattern(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * CustomHttpPattern kind.
       * @member {string} kind
       * @memberof google.api.CustomHttpPattern
       * @instance
       */
      CustomHttpPattern.prototype.kind = "";

      /**
       * CustomHttpPattern path.
       * @member {string} path
       * @memberof google.api.CustomHttpPattern
       * @instance
       */
      CustomHttpPattern.prototype.path = "";

      /**
       * Creates a new CustomHttpPattern instance using the specified properties.
       * @function create
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
       */
      CustomHttpPattern.create = function create(properties) {
        return new CustomHttpPattern(properties);
      };

      /**
       * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
       * @function encode
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CustomHttpPattern.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
          writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
        if (message.path != null && Object.hasOwnProperty.call(message, "path"))
          writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
        return writer;
      };

      /**
       * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CustomHttpPattern message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CustomHttpPattern.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.kind = reader.string();
              break;
            case 2:
              message.path = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CustomHttpPattern message.
       * @function verify
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CustomHttpPattern.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.kind != null && message.hasOwnProperty("kind"))
          if (!$util.isString(message.kind))
            return "kind: string expected";
        if (message.path != null && message.hasOwnProperty("path"))
          if (!$util.isString(message.path))
            return "path: string expected";
        return null;
      };

      /**
       * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       */
      CustomHttpPattern.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.CustomHttpPattern)
          return object;
        let message = new $root.google.api.CustomHttpPattern();
        if (object.kind != null)
          message.kind = String(object.kind);
        if (object.path != null)
          message.path = String(object.path);
        return message;
      };

      /**
       * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.CustomHttpPattern} message CustomHttpPattern
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CustomHttpPattern.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.kind = "";
          object.path = "";
        }
        if (message.kind != null && message.hasOwnProperty("kind"))
          object.kind = message.kind;
        if (message.path != null && message.hasOwnProperty("path"))
          object.path = message.path;
        return object;
      };

      /**
       * Converts this CustomHttpPattern to JSON.
       * @function toJSON
       * @memberof google.api.CustomHttpPattern
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CustomHttpPattern.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CustomHttpPattern;
    })();

    return api;
  })();

  return google;
})();
